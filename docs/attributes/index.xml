<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Attributes on Molecule</title>
    <link>http://scalamolecule.org/docs/attributes/</link>
    <description>Recent content in Attributes on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Jan 2015 22:06:44 +0100</lastBuildDate>
    
	<atom:link href="http://scalamolecule.org/docs/attributes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Basics</title>
      <link>http://scalamolecule.org/docs/attributes/basics/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/attributes/basics/</guid>
      <description>Attribute basics Tests&amp;hellip;
When we have defined a schema, Molecule generates the necessary boilerplate code so that we can build &amp;ldquo;molecular data structures&amp;rdquo; by building sequences of Attributes separated with dots (the &amp;ldquo;builder pattern&amp;rdquo;).
We could for instance build a molecule representing the data structure of Persons with name, age and gender Attributes:
Person.name.age.gender // etc  The fundamental building blocks are Namespaces like Person and Attributes like name, age and gender.</description>
    </item>
    
    <item>
      <title>Mandatory/Tacet/Optional</title>
      <link>http://scalamolecule.org/docs/attributes/modes/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/attributes/modes/</guid>
      <description>3 attribute modes 1. Mandatory attr When we use a molecule to query the Datomic database we ask for entities having all our Attributes associated with them.
Note that this is different from selecting rows from a sql table where you can also get null values back!
If for instance we have entities representing Persons in our data set that haven&amp;rsquo;t got any age Attribute associated with them then this query will not return those entities:</description>
    </item>
    
    <item>
      <title>Map attributes</title>
      <link>http://scalamolecule.org/docs/attributes/mapped/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/attributes/mapped/</guid>
      <description>Map Attributes Tests&amp;hellip;
Mapped values can be saved with mapped attributes in Molecule. It&amp;rsquo;s a special Molecule construct that makes it easy to save for instance multi-lingual data without having to create language-variations of each attribute. But they can also be used for any other key-value indexed data.
Say you want to save famous Persons names in multiple languages. Then you could use a mapString:
// In definition file val name = mapString // Insert mapped data Person.</description>
    </item>
    
    <item>
      <title>Expressions</title>
      <link>http://scalamolecule.org/docs/attributes/expressions/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/attributes/expressions/</guid>
      <description>Expressions Tests&amp;hellip;
Equality Tests&amp;hellip;
We can apply values to Attributes in order to filter the data structures we are looking for. We could for instance find people who like pizza:
Person.likes.apply(&amp;quot;pizza&amp;quot;)  or simply
Person.likes(&amp;quot;pizza&amp;quot;)  Since the applied value &amp;ldquo;pizza&amp;rdquo; ensures that the attributes returned has this value we will get redundant information back for the likes attribute (&amp;ldquo;pizza&amp;rdquo; is returned for all persons):
Person.name.likes(&amp;quot;pizza&amp;quot;).get === List( (&amp;quot;Fred&amp;quot;, &amp;quot;pizza&amp;quot;), (&amp;quot;Ben&amp;quot;, &amp;quot;pizza&amp;quot;) )  This is an ideomatic place to use a tacit attribute likes_ to say &amp;ldquo;Give me names of persons that like pizza&amp;rdquo; without returning the likes value &amp;ldquo;pizza&amp;rdquo; over and over again.</description>
    </item>
    
    <item>
      <title>Aggregates</title>
      <link>http://scalamolecule.org/docs/attributes/aggregates/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/attributes/aggregates/</guid>
      <description>Aggregates Tests&amp;hellip;
Molecule wraps Datomic&amp;rsquo;s native aggregate functions by applying special aggregate keyword objects to the attribute we want to aggregate on. The keyword objects are made available with the molecule._ import.
Aggregate functions either return a single value or a collection of values:
Aggregates returning a single value min/max Applying the min or max aggregate keyword object as a value to the age attribute returns the lowest/highest ages.</description>
    </item>
    
    <item>
      <title>Parameterized</title>
      <link>http://scalamolecule.org/docs/attributes/parameterized/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/attributes/parameterized/</guid>
      <description>Parameterized Input-molecules Tests&amp;hellip;
Molecules can be parameterized by applying the input placeholder ? as a value to an attribute. The molecule then expects input for that attribute at runtime.
By assigning parameterized &amp;ldquo;Input-molecules&amp;rdquo; to variables we can re-use those variables to query for similar data structures where only some data part varies:
// 1 input parameter val person = m(Person.name(?)) val john = person(&amp;quot;John&amp;quot;).get.head val lisa = person(&amp;quot;Lisa&amp;quot;).get.head  Of course more complex molecules would benefit even more from this approach.</description>
    </item>
    
  </channel>
</rss>