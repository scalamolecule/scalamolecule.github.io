<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Relationships on Molecule</title>
    <link>http://scalamolecule.org/docs/relationships/</link>
    <description>Recent content in Relationships on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Jan 2015 22:06:44 +0100</lastBuildDate>
    
	<atom:link href="http://scalamolecule.org/docs/relationships/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Cardinality one</title>
      <link>http://scalamolecule.org/docs/relationships/card-one/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/relationships/card-one/</guid>
      <description>Card-one relationships Tests&amp;hellip;
In Molecule we model a cardinality-one relationship in our schema definition file with the one[&amp;lt;RefNamespace&amp;gt;] syntax:
object YourDomainDefinition { trait Person { val name = oneString val home = one[Addr] } trait Addr { val street = oneString val city = oneString } }  The ref attribute home has a card-one relationship to namespace Addr. When our schema is then translated to Molecule boilerplate code our home ref attribute is accessible as a value:</description>
    </item>
    
    <item>
      <title>Cardinality many</title>
      <link>http://scalamolecule.org/docs/relationships/card-many/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/relationships/card-many/</guid>
      <description>Card-many relationships Tests&amp;hellip;
Cardinality-many relationships in Molecule are modelled with the many[&amp;lt;RefNamespace&amp;gt;] syntax:
object OrderDefinition { trait Order { val id = oneString val items = many[LineItem].subComponents } trait LineItem { val qty = oneInt val product = oneString val price = oneDouble } }  An Order can have multiple LineItems so we define a cardinality-many ref attribute items that points to the LineItem namespace.
Note how we also make LineItems subComponents of the Order.</description>
    </item>
    
    <item>
      <title>Composites</title>
      <link>http://scalamolecule.org/docs/relationships/composites/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/relationships/composites/</guid>
      <description>Composites Tests&amp;hellip;
As we saw earlier, Entities are simply groups of facts that share an entity id:
The last fact is kind of a black sheep though since the :site/cat attribute is not in the Person namespace.
Avoid non-intrinsic pollution Since entities can have attributes from any namespace we have a challenge of how to model this in our schema definiton. It would be quick and easy to just make a relationship from a Person namespace to the Site namespace:</description>
    </item>
    
    <item>
      <title>Bidirectional</title>
      <link>http://scalamolecule.org/docs/relationships/bidirectional/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/docs/relationships/bidirectional/</guid>
      <description>Bidirectional references Tests&amp;hellip;
Unidirectional reference limitations Normal Datomic references are unidirectional. If we add a friend reference from Ann to Ben
Person.name(&amp;quot;Ann&amp;quot;).Friends.name(&amp;quot;Ben&amp;quot;).save  Then we can naturally query to get friends of Ann
Person.name_(&amp;quot;Ann&amp;quot;).Friends.name.get === List(&amp;quot;Ben&amp;quot;)  But what if we want to find friends of Ben? This will give us nothing since our reference only went from Ann to Ben:
Person.name_(&amp;quot;Ben&amp;quot;).Friends.name.get === List()  Instead we would have to think backwards to get the back reference &amp;ldquo;who referenced Ben?</description>
    </item>
    
  </channel>
</rss>