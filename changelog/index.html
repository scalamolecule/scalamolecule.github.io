<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon"/>
    <title>Changelog</title>
    <link rel="stylesheet" type='text/css' href="https://www.scalamolecule.org/css/bootstrap.min.css">
    <link rel="stylesheet" type='text/css' href="https://www.scalamolecule.org/css/highlight/styles/solarized_light.css"/>
    <link rel="stylesheet" type='text/css' href="https://www.scalamolecule.org/css/syntax-custom.css"/>
    <link rel="stylesheet" type='text/css' href="https://www.scalamolecule.org/vendor/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type='text/css' href="https://www.scalamolecule.org/css/style.css">
    <link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic,500,600,700,700italic,800,800italic'>

    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://www.scalamolecule.org/img/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="https://www.scalamolecule.org/img/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://www.scalamolecule.org/img/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="https://www.scalamolecule.org/img/apple-touch-icon-57-precomposed.png">

    
    
</head>
<body data-spy="scroll" data-target="#sidebar" data-offset="110">
<header class="bs-docs-header">

    <nav class="navbar navbar-inverse">
        <div class="container-fluid" style="max-width:1170px;padding-top:3px">
            
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a href="../" style="padding-left: 6px; padding-right: 13px;"><img src="https://www.scalamolecule.org/img/logo/MoleculeLogo150.png"></a>
            </div>

            
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    
                    
                        
                            <li class="dropdown">
                                <a href="../intro/" target="_top">Intro</a>
                            </li>
                        
                    
                        
                            <li class="dropdown">
                                <a href="../setup/" target="_top">Setup</a>
                            </li>
                        
                    
                        
                            <li class="dropdown">
                                <a href="../documentation/" target="_top">Documentation</a>
                            </li>
                        
                    
                        
                            <li class="dropdown">
                                <a href="../dev/" target="_top">Dev</a>
                            </li>
                        
                    
                        
                            <li class="dropdown">
                                <a href="../community/" target="_top">Community</a>
                            </li>
                        
                    
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="https://javadoc.io/doc/org.scalamolecule/molecule_2.13/latest/index.html" target="_blank" style="">ScalaDocs</a></li>
                    <li><a href="../changelog" style="">v1.0.3</a></li>
                    <li><a href="https://github.com/scalamolecule/molecule" target="_blank">
                        <img src="https://www.scalamolecule.org/vendor/GitHub-Mark/PNG/GitHub-Mark-Light-32px.png"
                             style="margin-top:-4px;padding-left:15px;opacity:0.6;width:42px;">
                    </a></li>
                </ul>
            </div>
        </div>
    </nav>

</header>

<div class="wrapper">

<div class="container-fluid" style="max-width:1170px">

    <div class="col-sm-10 " style="padding-left:8px;">
        <h1 id="molecule-changelog">Molecule changelog</h1>
<p><a href="https://github.com/scalamolecule/molecule/releases">Github releases</a></p>
<ul>
<li>2021-12-27 v1.0.3 <a href="#49">Adjustments to molecule RPC interface</a></li>
<li>2021-12-25 v1.0.2 <a href="#48">Upgrade datomic-client-api-java-scala to 1.0.3</a></li>
<li>2021-12-19 v1.0.1 <a href="#47">Upgrade to Scala.js 1.8, js-dom 2.0</a></li>
<li>2021-11-29 v1.0.0 <a href="#46">Molecule 1.0.0</a></li>
<li>2021-03-14 v0.25.1 <a href="#45">Time getters for object output</a></li>
<li>2021-03-04 v0.25.0 <a href="#44">Molecule object output and dynamic molecules</a></li>
<li>2021-01-16 v0.24.0 <a href="#43">Json output dropped</a></li>
<li>2021-01-03 v0.23.0 <a href="#42">Targeting Datomic Peer + Peer-Server + Cloud</a></li>
<li>2020-10-31 v0.22.8 <a href="#41">Upgrade to ScalaJS 1.3</a></li>
<li>2020-07-17 v0.22.7 <a href="#40">Allow all implicit widening conversions for numeric variables</a></li>
<li>2020-07-17 v0.22.6 <a href="#39">BigDecimal accepting non-decimal numbers correctly</a></li>
<li>2020-06-16 v0.22.5 <a href="#38">Apply <code>Iterable</code> instead of <code>Seq</code> to values</a></li>
<li>2020-06-11 v0.22.4 <a href="#37">Time zones in distribution</a></li>
<li>2020-06-08 v0.22.3 <a href="#36">Resolve mutable identifiers in Scala 2.13</a></li>
<li>2020-05-17 v0.22.2 <a href="#35">Upgrade to ScalaJS 1.1.0</a></li>
<li>2020-04-10 v0.22.1 <a href="#34">Bugfix: Query optimization resolves fulltext search correctly</a></li>
<li>2020-04-07 v0.22.0 <a href="#33">Automatic Query optimization</a></li>
<li>2019-12-20 v0.21.0 <a href="#32">Optional nested data</a></li>
<li>2019-10-24 v0.20.0 <a href="#31">Molecule for Scala.js</a></li>
<li>2019-10-20 v0.19.1 <a href="#30">Date handling corrected</a></li>
<li>2019-09-22 v0.19.0 <a href="#29">Cross-compiling to Scala 2.13.1 and 2.12.10</a></li>
<li>2019-05-17 v0.18.5 <a href="#28">Adapting to sbt-molecule 0.8.1</a></li>
<li>2019-05-13 v0.18.4 <a href="#27">Aggregates for card-many attributes</a></li>
<li>2019-04-02 v0.18.3 <a href="#26">Bug fixes</a></li>
<li>2019-03-10 v0.18.2 <a href="#25">Meta becomes Generic</a></li>
<li>2019-03-09 v0.18.1 <a href="#24">Shift Meta semantics</a></li>
<li>2019-03-07 v0.18.0 <a href="#23">Synchronized internal naming scheme + bug fixes</a></li>
<li>2019-01-15 v0.17.0 <a href="#22">Datoms, Indexes, Log, Schema and debugging</a></li>
<li>2018-12-02 v0.16.1 <a href="#21">Sbt-molecule 0.7.0, bootstrap speed optimization</a></li>
<li>2018-11-25 v0.16.0 <a href="#20">Async API + tx functions</a></li>
<li>2018-10-25 v0.15.0 <a href="#19">10x-100x Compilation speed boost</a></li>
<li>2018-09-06 v0.14.0 <a href="#18">Scala docs and semantic updates</a></li>
<li>2017-11-13 v0.13.0 <a href="#17">Native Json output</a></li>
<li>2017-05-28 v0.12.0 <a href="#16">Optional values in save-molecules</a></li>
<li>2017-05-19 v0.11.0 <a href="#15">Time API</a></li>
<li>2016-10-19 v0.10.0 <a href="#14">Entity selection retrieval and manipulation</a></li>
<li>2016-07-24 v0.9.0 <a href="#13">Bidirectional references</a></li>
<li>2016-06-13 v0.8.0 <a href="#12">Composites &amp; Tx meta data</a></li>
<li>2016-06-04 v0.7.0 <a href="#11">sbt-molecule plugin code generation</a></li>
<li>2016-05-30 v0.6.2 <a href="#10">Various improvements and bug fixes</a></li>
<li>2016-04-25 v0.6.1 <a href="#9">Keyed attribute maps</a></li>
<li>2015-12-14 v0.5.0 <a href="#8">Map Attributes - Multilingual support</a></li>
<li>2015-11-14 v0.4.3 <a href="#7">Nested adjacent references</a></li>
<li>2015-11-13 v0.4.2 <a href="#6">Back references in nested inserts/gets</a></li>
<li>2015-10-28 v0.4.1 <a href="#5">Differentiating between optional values in insert/get</a></li>
<li>2015-10-25 v0.4.0 <a href="#4">Optional values (like Null)</a></li>
<li>2015-10-04 v0.3.0 <a href="#3">Nested data structures</a></li>
<li>2014-12-25 v0.2.0 <a href="#2">Implemented Day-Of-Datomic and MBrainz</a></li>
<li>2014-07-02 v0.1.0 <a href="#1">Initial commit - Seattle tutorial</a></li>
</ul>
<h2 id="top-adjustments-to-molecule-rpc-interface-49"><a href="#top">☝︎</a> Adjustments to molecule RPC interface {$49}</h2>
<p><em>2021-12-27 v1.0.3</em></p>
<p>RPC method args as generic java.nio.ByteBuffer instead of akka.util.ByteString.</p>
<h2 id="top-upgrade-datomic-client-api-java-scala-to-103-48"><a href="#top">☝︎</a> Upgrade datomic-client-api-java-scala to 1.0.3 {$48}</h2>
<p><em>2021-12-25 v1.0.2</em></p>
<p>Upgrading datomic-client-api-java-scala to 1.0.3 (transient fs2 upgrade to 3.2.3)</p>
<h2 id="47"><a href="#top">☝︎</a> Upgrade to Scala.js 1.8, js-dom 2.0</h2>
<p><em>2021-12-19 v1.0.1</em></p>
<p>Introduces <code>&quot;org.scala-js&quot; %%% &quot;scala-js-macrotask-executor&quot; % &quot;1.0.0&quot;</code> as ExecutionContext in most of the code base.</p>
<h2 id="46"><a href="#top">☝︎</a> Molecule 1.0.0</h2>
<p><em>2021-11-29 v1.0.0</em></p>
<p>This is the first major release of Molecule! Here are some of the major changes compared to earlier iterations:</p>
<h3 id="asynchronous-and-non-blocking-api">Asynchronous and non-blocking api</h3>
<p>Molecule is now fully asynchronous and non-blocking. Futures with data are returned that we can then map over:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// transactions
</span><span class="c1"></span><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="n">age</span><span class="o">(</span><span class="mi">42</span><span class="o">).</span><span class="n">save</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">txReport</span> <span class="k">=&gt;</span> <span class="o">...)</span>

<span class="c1">// queries
</span><span class="c1"></span><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">data</span> <span class="k">=&gt;</span> <span class="o">...)</span>

<span class="c1">// Multiple transactions/queries
</span><span class="c1"></span><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="n">age</span><span class="o">(</span><span class="mi">42</span><span class="o">).</span><span class="n">save</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">get</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
</code></pre></div><h3 id="scalajs-implementation">Scala.js implementation</h3>
<p>Molecule is now fully implemented with Scala.js too. This allows us to transact and query data directly from the client/js side without needing to implement shared RPC interfaces on the server side!</p>
<p>Molecule transparently sends and retrieves data via ajax calls to the server and takes care of marshalling data back and forth with highly efficient Byte encoding/decoding using <a href="https://boopickle.suzaku.io">BooPickle</a>.</p>
<p>You can therefore now make transparent RPC calls with molecules from the client exactly as if the call was made from the server side.</p>
<h3 id="float-and-byte-types-dropped">Float and Byte types dropped</h3>
<p>Due to <a href="http://www.scala-js.org/doc/semantics.html">limitations in JavaScript</a>, some <code>Float</code> precision is lost on the js platform. Since Molecule is intended to be used on the Scala.js platform too, the Float type is therefore not implemented. Please use <code>Double</code> instead to ensure double precision.</p>
<p>Due to certain Datomic <a href="https://docs.datomic.com/on-prem/schema/schema.html#bytes-limitations">limitation of Bytes</a>, Molecule doesn&rsquo;t implement the Byte type neither.</p>
<h3 id="3-output-types">3 output types</h3>
<p>Fetched data can now be returned as tuples, objects or json:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">names</span>           <span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>                 <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">get</span>
<span class="k">val</span> <span class="n">namesAndAges</span>    <span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]]</span>          <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">get</span>
<span class="k">val</span> <span class="n">namesAgesMembers</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span>, <span class="kt">Boolean</span><span class="o">)]]</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">isMember</span><span class="o">.</span><span class="n">get</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">{</span>
  <span class="c1">// Single row/object
</span><span class="c1"></span>  <span class="n">ben</span> <span class="k">&lt;-</span> <span class="nc">Person</span><span class="o">.</span><span class="n">name_</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="n">age</span><span class="o">.</span><span class="n">gender</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">getObj</span>
  <span class="k">_</span> <span class="k">=</span> <span class="n">ben</span><span class="o">.</span><span class="n">age</span> <span class="o">==&gt;</span> <span class="mi">23</span>
  <span class="k">_</span> <span class="k">=</span> <span class="n">ben</span><span class="o">.</span><span class="n">gender</span> <span class="o">==&gt;</span> <span class="s">&#34;male&#34;</span>
  <span class="k">_</span> <span class="k">=</span> <span class="n">ben</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span> <span class="o">==&gt;</span> <span class="s">&#34;Broadway&#34;</span> <span class="c1">// Note Address namespacing
</span><span class="c1"></span>  <span class="k">_</span> <span class="k">=</span> <span class="n">ben</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span> <span class="o">==&gt;</span> <span class="s">&#34;New York&#34;</span> <span class="c1">// Note Address.City namespacing
</span><span class="c1"></span>  
  <span class="c1">// Multiple rows/objects
</span><span class="c1"></span>  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">getObjList</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">person</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span>
      <span class="s">s&#34;</span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> is </span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="n">age</span><span class="si">}</span><span class="s"> yeas old and lives on &#34;</span> <span class="o">+</span>
        <span class="s">s&#34;</span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span><span class="si">}</span><span class="s">, </span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s">&#34;</span>
    <span class="o">)</span>
    <span class="c1">// &#34;Ben is 23 years old and lives on Broadway, New York&#34;
</span><span class="c1"></span>    <span class="c1">// &#34;Lisa is...&#34; etc.
</span><span class="c1"></span>  <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="nc">Ref1</span><span class="o">.</span><span class="n">int1</span> <span class="n">insert</span> <span class="nc">List</span><span class="o">((</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>

  <span class="k">_</span> <span class="k">&lt;-</span> <span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="nc">Ref1</span><span class="o">.</span><span class="n">int1</span><span class="o">.</span><span class="n">getJson</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span>
    <span class="s">&#34;&#34;&#34;{
</span><span class="s">      |  &#34;data&#34;: {
</span><span class="s">      |    &#34;Ns&#34;: [
</span><span class="s">      |      {
</span><span class="s">      |        &#34;str&#34;: &#34;a&#34;,
</span><span class="s">      |        &#34;Ref1&#34;: {
</span><span class="s">      |          &#34;int1&#34;: 1
</span><span class="s">      |        }
</span><span class="s">      |      },
</span><span class="s">      |      {
</span><span class="s">      |        &#34;str&#34;: &#34;b&#34;,
</span><span class="s">      |        &#34;Ref1&#34;: {
</span><span class="s">      |          &#34;int1&#34;: 2
</span><span class="s">      |        }
</span><span class="s">      |      }
</span><span class="s">      |    ]
</span><span class="s">      |  }
</span><span class="s">      |}&#34;&#34;&#34;</span><span class="o">.</span><span class="n">stripMargin</span>
  <span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div><h2 id="45"><a href="#top">☝︎</a> Time getters for object output</h2>
<p><em>2021-03-14 v0.25.1</em></p>
<p>All time getters implemented for object output.</p>
<p>Each getter comes in a synchronous and asynchronous version:</p>
<pre><code>// All objects materialized in List
getObjListAsOf(…)       getAsyncObjListAsOf(…)
getObjListSince(…)      getAsyncObjListSince(…)
getObjListWith(…)       getAsyncObjListWith(…)
getObjListHistory(…)    getAsyncObjListHistory(…) // History only for List of objects

// All objects materialized in fast Array
getObjArrayAsOf(…)      getAsyncObjArrayAsOf(…)
getObjArraySince(…)     getAsyncObjArraySince(…)
getObjArrayWith(…)      getAsyncObjArrayWith(…)

// Object creation/casting deferred for each `next` call
getObjIterableAsOf(…)   getAsyncObjIterableAsOf(…)
getObjIterableSince(…)  getAsyncObjIterableSince(…)
getObjIterableWith(…)   getAsyncObjIterableWith(…)
</code></pre><p>Each getter can have a <code>t</code> (time t or transaction id), <code>java.util.Date</code> or <code>TxReport</code> applied plus optionally a limit on output. A List of objects as of some point in time can for instance be retrieved with the following getter signatures:</p>
<pre><code>getObjListAsOf(t: Long) // t or tx
getObjListAsOf(tx: TxReport)
getObjListAsOf(date: java.util.Date)

getObjListAsOf(t: Long, limit: Int)
getObjListAsOf(tx: TxReport, limit: Int)
getObjListAsOf(date: java.util.Date, limit: Int)
</code></pre><h2 id="44"><a href="#top">☝︎</a> Molecule object output and dynamic molecules</h2>
<p><em>2021-03-04 v0.25.0</em></p>
<p>Return each data row as an object with named properties.</p>
<p>As an alternative to tuple output, object properties make it easy to map molecules to forms and other larger structures that benefit from being able to navigate many attributes/properties by name rather than tuple arity position (_1, _2 etc). Property names and types are inferred by the IDE even for references to related data that can nest up to 7 levels deep.</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">ben</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">name_</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="n">age</span><span class="o">.</span><span class="n">gender</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">getObj</span>

<span class="n">ben</span><span class="o">.</span><span class="n">age</span> <span class="o">===</span> <span class="mi">23</span>
<span class="n">ben</span><span class="o">.</span><span class="n">gender</span> <span class="o">===</span> <span class="s">&#34;male&#34;</span>
<span class="n">ben</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span> <span class="o">===</span> <span class="s">&#34;Broadway&#34;</span>
<span class="n">ben</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span> <span class="o">===</span> <span class="s">&#34;New York&#34;</span>
</code></pre></div><p>Fetch multiple objects with <code>getObjList</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">getObjList</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">person</span> <span class="k">=&gt;</span>
  <span class="n">println</span><span class="o">(</span><span class="s">s&#34;</span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> is </span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="n">age</span><span class="si">}</span><span class="s"> yeas old and lives on </span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span><span class="si">}</span><span class="s">, </span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s">&#34;</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div><h3 id="dynamic-molecules">Dynamic molecules</h3>
<p>An exotic new feature that could help domain modelling is the ability to add a code body to a molecule! A Molecule macro makes data of a single molecule object available to a locally defined body of code. And Scala&rsquo;s Dynamic feature makes the code dynamically available from the outside:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">ben</span> <span class="k">=</span> <span class="n">m</span><span class="o">(</span><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="n">age</span><span class="o">.</span><span class="n">gender</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">getObj</span><span class="o">)</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">info</span> <span class="k">=</span> <span class="s">s&#34;</span><span class="si">${</span><span class="n">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> (</span><span class="si">${</span><span class="n">self</span><span class="o">.</span><span class="n">age</span><span class="si">}</span><span class="s">, </span><span class="si">${</span><span class="n">self</span><span class="o">.</span><span class="n">gender</span><span class="si">}</span><span class="s">) lives on </span><span class="si">${</span><span class="n">self</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span><span class="si">}</span><span class="s">, </span><span class="si">${</span><span class="n">self</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s">&#34;</span> 
<span class="o">}</span>

<span class="c1">// We can now both access data and call body code
</span><span class="c1"></span><span class="n">ben</span><span class="o">.</span><span class="n">age</span> <span class="o">===</span> <span class="mi">23</span>
<span class="n">ben</span><span class="o">.</span><span class="n">gender</span> <span class="o">===</span> <span class="s">&#34;male&#34;</span>
<span class="n">ben</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="n">street</span> <span class="o">===</span> <span class="s">&#34;Broadway&#34;</span>
<span class="n">ben</span><span class="o">.</span><span class="nc">Address</span><span class="o">.</span><span class="nc">City</span><span class="o">.</span><span class="n">name</span> <span class="o">===</span> <span class="s">&#34;New York&#34;</span>
<span class="n">ben</span><span class="o">.</span><span class="n">info</span> <span class="o">===</span> <span class="s">&#34;Ben (23, male) lives on Broadway, New York&#34;</span>
</code></pre></div><p>Dynamic molecules offer combined data and functionality as an alternative to populating more rigid external domain case classes.</p>
<h2 id="43"><a href="#top">☝︎</a> Json output dropped</h2>
<p><em>2021-01-16 v0.24.0</em></p>
<p>Json as output is dropped which means that methods <code>getJson</code> and <code>getAsyncJson</code> are no longer available on molecules.</p>
<p>The semantics were unclear and json can anyway easily be made with any desired semantics from Model and typed tuples instead. Json output also felt like a black sheep in the typed Molecule eco-system. Moving forward now with what Molecule does best: outputting typed and molecule-matching data.</p>
<h2 id="42"><a href="#top">☝︎</a> Targeting Datomic Peer + Peer-Server + Cloud</h2>
<p><em>2021-01-03 v0.23.0</em></p>
<p>Major upgrade making Molecule fully compliant with all three Datomic database systems:</p>
<ul>
<li>Peer (On-Prem, Java API)</li>
<li>Peer Server (Clojure Client API)</li>
<li>Cloud / Dev-Local (Clojure Client API)</li>
</ul>
<p>All 1400+ tests pass with all three systems. See test spec on how to set up each system.</p>
<h2 id="41"><a href="#top">☝︎</a> Upgrade to ScalaJS 1.3</h2>
<p><em>2020-10-31 v0.22.8</em></p>
<h2 id="40"><a href="#top">☝︎</a> Allow all implicit widening conversions for numeric variables</h2>
<p><em>2020-07-17 v0.22.7</em></p>
<p>Implicit widening conversion of numeric variables is now allowed in Molecule:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">int</span>   <span class="k">=</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">long</span>  <span class="k">=</span> <span class="mi">1L</span>
<span class="k">val</span> <span class="n">float</span> <span class="k">=</span> <span class="mi">1</span><span class="n">f</span>

<span class="c1">// -&gt; Float
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">.</span><span class="n">float</span><span class="o">(</span><span class="n">int</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">)</span>
<span class="nc">Ns</span><span class="o">.</span><span class="n">float</span><span class="o">(</span><span class="n">long</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mf">1.0f</span><span class="o">)</span>

<span class="c1">// -&gt; Double
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">.</span><span class="n">double</span><span class="o">(</span><span class="n">int</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
<span class="nc">Ns</span><span class="o">.</span><span class="n">double</span><span class="o">(</span><span class="n">long</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
<span class="nc">Ns</span><span class="o">.</span><span class="n">double</span><span class="o">(</span><span class="n">float</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</code></pre></div><p>The widening feature is deprecated in Scala and will thus be gone when removed from Scala.</p>
<p>Variables with Int values can now also be applied to Long attributes:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">int</span> <span class="k">=</span> <span class="mi">1</span>
<span class="nc">Ns</span><span class="o">.</span><span class="n">long</span><span class="o">(</span><span class="n">int</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1L</span><span class="o">)</span>
</code></pre></div><h2 id="39"><a href="#top">☝︎</a> BigDecimal accepting non-decimal numbers correctly</h2>
<p><em>2020-07-17 v0.22.6</em></p>
<p>Implicit conversion of for instance applied Integers to BigDecimal would end up missing the decimal point and thus not be saved correctly in Datomic. Now correct conversion is ensured both for inserting, updating and querying BigDecimals.</p>
<h2 id="38"><a href="#top">☝︎</a> Apply <code>Iterable</code> instead of <code>Seq</code> to values</h2>
<p><em>2020-06-16 v0.22.5</em></p>
<h2 id="37"><a href="#top">☝︎</a> Time zones in distribution</h2>
<p><em>2020-06-11 v0.22.4</em></p>
<p>Include transpiled <a href="http://cquiroz.github.io/scala-java-time/">scala-java-time</a> time zones for ScalaJS code. This allows dependent ScalaJS projects to have time zones available in client code that depends on <code>molecule</code> (<a href="https://github.com/scalamolecule/molecule-admin/blob/master/shared/src/test/scala/moleculeadmin/sharedtest/util/DateTransformation.scala">DateTransformatin</a> in <a href="https://github.com/scalamolecule/molecule-admin">molecule-admin</a> being an example).</p>
<h2 id="36"><a href="#top">☝︎</a> Resolve mutable identifiers in Scala 2.13</h2>
<p><em>2020-06-08 v0.22.3</em></p>
<p>Pattern match against unified interfaces in <code>molecule.ops.ModelOps</code> matching both immutable and mutable collections.</p>
<h2 id="35"><a href="#top">☝︎</a> Upgrade to ScalaJS 1.1.0</h2>
<p><em>2020-05-17 v0.22.2</em></p>
<h2 id="34"><a href="#top">☝︎</a> Bugfix: Query optimization resolves fulltext search correctly</h2>
<p><em>2020-04-10 v0.22.1</em></p>
<h2 id="33"><a href="#top">☝︎</a> Automatic Query optimization</h2>
<p><em>2020-04-07 v0.22.0</em></p>
<p>Molecule now transparently optimize all queries sent to Datomic.</p>
<p>Most selective Clauses are automatically grouped first in the :where section of the Datomic query as per the recommendation in <a href="https://docs.datomic.com/on-prem/best-practices.html#most-selective-clauses-first">Datomic Best Practices</a>.</p>
<p>This brings dramatic performance gains of in some cases beyond 100x compared to un-optimized queries. The optimization happens automatically in the background so that you can focus entirely on your domain without concern for the optimal order of attributes in your molecules.</p>
<p>Bug fixes:</p>
<ul>
<li>Correct resolution of multiple attrs in refs in tx meta data</li>
<li>Optimization of Index/Log operations</li>
<li>Optional card-many attributes now return all values (not Datomic default max 1000)</li>
<li>Correctly converting Iterables in raw queries</li>
<li>Re-use attr variable in query when applying multiple aggregates to the same attr</li>
<li>Fulltext search allowed on optional attributes</li>
</ul>
<h2 id="32"><a href="#top">☝︎</a> Optional nested data</h2>
<p><em>2019-12-20 v0.21.0</em></p>
<p>Optional nested data can now be queried with the <code>*?</code> operator:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">m</span><span class="o">(</span><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="nc">Refs1</span> <span class="o">*</span> <span class="nc">Ref1</span><span class="o">.</span><span class="n">str1</span><span class="o">)</span> <span class="n">insert</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">List</span><span class="o">())</span> <span class="c1">// (no nested data)
</span><span class="c1"></span><span class="o">)</span>

<span class="c1">// Mandatory nested data
</span><span class="c1"></span><span class="n">m</span><span class="o">(</span><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="nc">Refs1</span> <span class="o">*</span> <span class="nc">Ref1</span><span class="o">.</span><span class="n">str1</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">))</span>
<span class="o">)</span>

<span class="c1">// Optional nested data
</span><span class="c1"></span><span class="n">m</span><span class="o">(</span><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="nc">Refs1</span> <span class="o">*?</span> <span class="nc">Ref1</span><span class="o">.</span><span class="n">str1</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="s">&#34;b&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">List</span><span class="o">())</span>
<span class="o">)</span>
</code></pre></div><h2 id="31"><a href="#top">☝︎</a> Molecule for Scala.js</h2>
<p><em>2019-10-24 v0.20.0</em></p>
<p>Molecule AST&rsquo;s and generic interfaces compiled for Scala.js.</p>
<p>See the <a href="https://github.com/scalamolecule/molecule-admin">molecule-admin</a> project for an example of how Molecule is used both on the server and client side.</p>
<h2 id="30"><a href="#top">☝︎</a> Date handling corrected</h2>
<p><em>2019-10-20 v0.19.1</em></p>
<ul>
<li>Bug fixes: Date formatting with correct timezone and daylight savings</li>
<li>Bug fix: duplicate optional attributes allowed</li>
</ul>
<h2 id="29"><a href="#top">☝︎</a> Cross-compiling to Scala 2.13.1 and 2.12.10</h2>
<p><em>2019-09-22 v0.19.0</em></p>
<ul>
<li>Molecule now cross-compiles to Scala 2.12.10 and 2.13.1</li>
<li>Generic entity id <code>e</code> can now be used together with aggregates.</li>
<li><code>ReBond</code> model element simplified (only affects internally).</li>
<li>All cardinality many types now correctly casted with Entity touch.</li>
<li>Now saving/inserting correct Float precision.</li>
<li>Bug fix: correct namespace name when <code>e(count)</code> is first.</li>
<li>bug fix: generic attr before ref.</li>
<li>Internal model semantics clarification, changing <code>ns</code> to <code>nsFull</code>.</li>
</ul>
<h2 id="28"><a href="#top">☝︎</a> Adapting to sbt-molecule 0.8.1</h2>
<p><em>2019-05-17 v0.18.5</em></p>
<p>Adapting to <code>sbt-molecule</code> 0.8.1 that now no longer adds MapK attributes to the schema creation file.</p>
<h2 id="27"><a href="#top">☝︎</a> Aggregates implemented for card-many attributes</h2>
<p><em>2019-05.13 v0.18.4</em></p>
<ul>
<li>Card-many attribute values can now be aggregated.</li>
</ul>
<h2 id="26"><a href="#top">☝︎</a> Bug fixes</h2>
<p><em>2019-04-02 v0.18.3</em></p>
<p>Bugfixes:</p>
<ul>
<li>Card-many ref attributes now have the same api as other card-many attributes (Set&rsquo;s of values can now be applied to both types).</li>
<li>Variable resolution on fulltext searches added.</li>
<li>Text attributes can now handle text input with quotation marks.</li>
<li>Touching entity ids with <code>Entity</code> now correctly handles all types.</li>
</ul>
<p>Improvement:</p>
<ul>
<li>For a more direct query evaluation, applying a single value to an attribute is now <code>ground</code>ed to a variable instead of using <code>comparison</code>.</li>
</ul>
<h2 id="25"><a href="#top">☝︎</a> Meta becomes Generic</h2>
<p><em>2019-03-10 v0.18.2</em></p>
<h2 id="24"><a href="#top">☝︎</a> Shift Meta semantics</h2>
<p><em>2019-03-09 v0.18.1</em></p>
<h2 id="23"><a href="#top">☝︎</a> Synchronized internal naming scheme + bug fixes</h2>
<p><em>2019-03-07 v0.18.0</em></p>
<p>In order to synchronize scala molecule boilerplate code and its internal representation, namespace names are now capitalized also in molecule model/query/datalog. This applies when no custom partitions are defined (and namespaces not partition-prefixed):</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Namespace names are now capitalized in the model
</span><span class="c1"></span><span class="n">m</span><span class="o">(</span><span class="nc">Community</span><span class="o">.</span><span class="n">name</span><span class="o">).</span><span class="nc">_model</span> <span class="o">===</span> <span class="nc">Model</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span>
  <span class="nc">Atom</span><span class="o">(</span><span class="s">&#34;Community&#34;</span><span class="o">,</span> <span class="s">&#34;name&#34;</span><span class="o">,</span> <span class="s">&#34;String&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">VarValue</span><span class="o">)</span> <span class="c1">// &#34;Community&#34; now uppercase
</span><span class="c1"></span><span class="o">))</span>

<span class="c1">// Uppercase namespace names are also retrieved when querying the schema
</span><span class="c1"></span><span class="nc">Schema</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">ns</span><span class="o">.</span><span class="n">nsFull</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">((</span>
  <span class="s">&#34;:Community/name&#34;</span><span class="o">,</span> <span class="c1">// namespace name now uppercase 
</span><span class="c1"></span>  <span class="s">&#34;db.part/user&#34;</span><span class="o">,</span> <span class="c1">// default partition (not prefixed to namespaces)
</span><span class="c1"></span>  <span class="s">&#34;Community&#34;</span><span class="o">,</span> <span class="c1">// now uppercase
</span><span class="c1"></span>  <span class="s">&#34;Community&#34;</span><span class="o">,</span> <span class="c1">// now uppercase (has no partition prefix when no custom partition is defined)
</span><span class="c1"></span>  <span class="s">&#34;name&#34;</span>
<span class="o">))</span>

<span class="c1">// Produced Datalog queries will also use the uppercase namespace name 
</span><span class="c1"></span><span class="o">[</span><span class="kt">:find</span>  <span class="kt">?b</span>
 <span class="kt">:where</span> <span class="o">[</span><span class="kt">?a</span> <span class="kt">:Community/name</span> <span class="kt">?b</span><span class="o">]]</span>
</code></pre></div><p>This change takes away the need to lower/capitalize namespace names back and forth between the source code representation and molecule model/query/datalog representations. It also makes it easier to distinguish between namespace/attribute names in internal molecule representations.</p>
<h3 id="unaffected-with-custom-partitions">Unaffected with custom partitions</h3>
<p>As before, custom partition-prefixed namespaces are unaffected:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Namespace names are now capitalized in the model
</span><span class="c1"></span><span class="n">m</span><span class="o">(</span><span class="n">accounting_Invoice</span><span class="o">.</span><span class="n">invoiceLine</span><span class="o">).</span><span class="nc">_model</span> <span class="o">===</span> <span class="nc">Model</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span>
  <span class="nc">Atom</span><span class="o">(</span><span class="s">&#34;accounting_Invoice&#34;</span><span class="o">,</span> <span class="s">&#34;invoiceLine&#34;</span><span class="o">,</span> <span class="s">&#34;ref&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">VarValue</span><span class="o">)</span>
<span class="o">))</span>

<span class="c1">// Querying the schema
</span><span class="c1"></span><span class="nc">Schema</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">part</span><span class="o">.</span><span class="n">ns</span><span class="o">.</span><span class="n">nsFull</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">((</span>
  <span class="s">&#34;:accounting_Invoice/invoiceLine&#34;</span><span class="o">,</span> 
  <span class="s">&#34;accounting&#34;</span><span class="o">,</span> <span class="c1">// custom partition (always lowercase)
</span><span class="c1"></span>  <span class="s">&#34;Invoice&#34;</span><span class="o">,</span> <span class="c1">// namespace now uppercase
</span><span class="c1"></span>  <span class="s">&#34;accounting_Invoice&#34;</span><span class="o">,</span> <span class="c1">// partition-prefixed namespace
</span><span class="c1"></span>  <span class="s">&#34;invoiceLine&#34;</span>
<span class="o">))</span>

<span class="c1">// Datalog query 
</span><span class="c1"></span><span class="o">[</span><span class="kt">:find</span>  <span class="kt">?b</span>
 <span class="kt">:where</span> <span class="o">[</span><span class="kt">?a</span> <span class="kt">:accounting_Invoice/invoiceLine</span> <span class="kt">?b</span><span class="o">]]</span>
</code></pre></div><h3 id="working-with-non-molecule-datomic-databases">Working with non-molecule Datomic databases</h3>
<p>For the end user internal uppercase namespace names have no impact unless you are working with externally defined Datomic databases or data sets that can have lowercase namespace names defined.</p>
<p>The sbt-plugin (as of version 0.8) now generates two additional schema transaction files that can be transacted with the external lowercase database so that you can use your uppercase Molecule code with it:</p>
<h4 id="molecule-schema-uppercase--external-data-lowercase">Molecule schema (uppercase) + external data (lowercase)</h4>
<p>When importing external data (<a href="https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/seattle/SeattleTests.scala#L367-L368">example</a>) from a database with lowercase namespace names then you can transact lowercase attribute aliases (<a href="https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/seattle/SeattleSpec.scala#L18">example</a>) so that your uppercase Molecule code can recognize the imported lowercase data:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">conn</span><span class="o">.</span><span class="n">datomicConn</span><span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="nc">SchemaUpperToLower</span><span class="o">.</span><span class="n">namespaces</span><span class="o">)</span>
</code></pre></div><h4 id="external-schema-lowercase--external-data-lowercase">External schema (lowercase) + external data (lowercase)</h4>
<p>If both external schema and data is created with lowercase namespace names, then you can transact uppercase attribute aliases with the live database so that it will recognize your uppercase molecule code (<a href="https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/mbrainz/MBrainz.scala#L38">example</a>):</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">conn</span><span class="o">.</span><span class="n">datomicConn</span><span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="nc">MBrainzSchemaLowerToUpper</span><span class="o">.</span><span class="n">namespaces</span><span class="o">)</span>
</code></pre></div><h2 id="22"><a href="#top">☝︎</a> Datoms, Indexes, Log, Schema and debugging</h2>
<p><em>2019-01-15 v0.17.0</em></p>
<p>7 Generic APIs introduced/streamlined to access data and schema generically. Some examples:</p>
<h4 id="datoms">Datoms</h4>
<p>Entity id of Ben with generic datom attribute <code>e</code> on a custom molecule&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">head</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="n">benEntityId</span><span class="o">,</span> <span class="s">&#34;Ben&#34;</span><span class="o">)</span>
</code></pre></div><h4 id="eavt-index">EAVT index</h4>
<p>Attributes/values of entity id <code>e1</code>&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">EAVT</span><span class="o">(</span><span class="n">e1</span><span class="o">).</span><span class="n">e</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="s">&#34;:person/name&#34;</span><span class="o">,</span> <span class="s">&#34;Ben&#34;</span><span class="o">,</span> <span class="n">t1</span><span class="o">),</span>
  <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="s">&#34;:person/age&#34;</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="n">t2</span><span class="o">),</span>
  <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="s">&#34;:golf/score&#34;</span><span class="o">,</span> <span class="mf">5.7</span><span class="o">,</span> <span class="n">t2</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><h4 id="avet-index">AVET index</h4>
<p>Values and entity associations for attribute <code>:person/age</code>&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">AVET</span><span class="o">(</span><span class="s">&#34;:person/age&#34;</span><span class="o">).</span><span class="n">v</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="n">t2</span><span class="o">),</span>
  <span class="o">(</span><span class="mi">37</span><span class="o">,</span> <span class="n">e2</span><span class="o">,</span> <span class="n">t5</span><span class="o">),</span>
  <span class="o">(</span><span class="mi">14</span><span class="o">,</span> <span class="n">e3</span><span class="o">,</span> <span class="n">t7</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><p>Datomic&rsquo;s <a href="http://docs.datomic.com/on-prem/javadoc/datomic/Database.html#indexRange(java.lang.Object,%20java.lang.Object,%20java.lang.Object)">indexRange API</a> is also implemented&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Entities and transactions of age attribute with values between 14 and 37
</span><span class="c1"></span><span class="nc">AVET</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="s">&#34;:person/age&#34;</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">14</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">37</span><span class="o">)).</span><span class="n">v</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">14</span><span class="o">,</span> <span class="n">e4</span><span class="o">,</span> <span class="n">t7</span><span class="o">)</span> <span class="c1">// 14 is included in value range
</span><span class="c1"></span><span class="o">)</span>
</code></pre></div><h4 id="aevt-index">AEVT index</h4>
<p>Entity ids, values and transaction t&rsquo;s of attribute <code>:person/name</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">AEVT</span><span class="o">(</span><span class="s">&#34;:person/name&#34;</span><span class="o">).</span><span class="n">e</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="s">&#34;Ben&#34;</span><span class="o">,</span> <span class="n">t2</span><span class="o">),</span>
  <span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="s">&#34;Liz&#34;</span><span class="o">,</span> <span class="n">t5</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><h4 id="vaet-index">VAET index</h4>
<p>Reverse index for ref attributes&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Say we have 3 entities pointing to one entity:
</span><span class="c1"></span><span class="nc">Release</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nc">Artists</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="n">r1</span><span class="o">,</span> <span class="s">&#34;Abbey Road&#34;</span><span class="o">,</span> <span class="n">a1</span><span class="o">,</span> <span class="s">&#34;The Beatles&#34;</span><span class="o">),</span>
  <span class="o">(</span><span class="n">r2</span><span class="o">,</span> <span class="s">&#34;Magical Mystery Tour&#34;</span><span class="o">,</span> <span class="n">a1</span><span class="o">,</span> <span class="s">&#34;The Beatles&#34;</span><span class="o">),</span>
  <span class="o">(</span><span class="n">r3</span><span class="o">,</span> <span class="s">&#34;Let it be&#34;</span><span class="o">,</span> <span class="n">a1</span><span class="o">,</span> <span class="s">&#34;The Beatles&#34;</span><span class="o">),</span>
<span class="o">)</span>

<span class="c1">// .. then we can get the reverse relationships with the VAET Index:
</span><span class="c1"></span><span class="nc">VAET</span><span class="o">(</span><span class="n">a1</span><span class="o">).</span><span class="n">v</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="s">&#34;:release/artists&#34;</span><span class="o">,</span> <span class="n">r1</span><span class="o">),</span>
  <span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="s">&#34;:release/artists&#34;</span><span class="o">,</span> <span class="n">r2</span><span class="o">),</span>
  <span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="s">&#34;:release/artists&#34;</span><span class="o">,</span> <span class="n">r3</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><h4 id="log-index">Log index</h4>
<p>Access to datoms index sorted by transaction/time:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Data from transaction t1 (inclusive) until t4 (exclusive)
</span><span class="c1"></span><span class="nc">Log</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">t1</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="n">t4</span><span class="o">)).</span><span class="n">t</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="s">&#34;:person/name&#34;</span><span class="o">,</span> <span class="s">&#34;Ben&#34;</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span>
  <span class="o">(</span><span class="n">t1</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="s">&#34;:person/age&#34;</span><span class="o">,</span> <span class="mi">41</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span>

  <span class="o">(</span><span class="n">t2</span><span class="o">,</span> <span class="n">e2</span><span class="o">,</span> <span class="s">&#34;:person/name&#34;</span><span class="o">,</span> <span class="s">&#34;Liz&#34;</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span>
  <span class="o">(</span><span class="n">t2</span><span class="o">,</span> <span class="n">e2</span><span class="o">,</span> <span class="s">&#34;:person/age&#34;</span><span class="o">,</span> <span class="mi">37</span><span class="o">,</span> <span class="kc">true</span><span class="o">),</span>

  <span class="o">(</span><span class="n">t3</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="s">&#34;:person/age&#34;</span><span class="o">,</span> <span class="mi">41</span><span class="o">,</span> <span class="kc">false</span><span class="o">),</span>
  <span class="o">(</span><span class="n">t3</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="s">&#34;:person/age&#34;</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><h4 id="schema">Schema</h4>
<p>Programatically explore your <code>Schema</code> structure&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Datomic type and cardinality of attributes
</span><span class="c1"></span><span class="nc">Schema</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">tpe</span><span class="o">.</span><span class="n">card</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span> <span class="o">(</span>
  <span class="o">(</span><span class="s">&#34;:sales_customer/name&#34;</span><span class="o">,</span> <span class="s">&#34;string&#34;</span><span class="o">,</span> <span class="s">&#34;one&#34;</span><span class="o">),</span>
  <span class="o">(</span><span class="s">&#34;:accounting_invoice/invoiceLine&#34;</span><span class="o">,</span> <span class="s">&#34;ref&#34;</span><span class="o">,</span> <span class="s">&#34;many&#34;</span><span class="o">),</span>
<span class="o">)</span>
</code></pre></div><h3 id="debugging-now-inspecting">Debugging (now: Inspecting)</h3>
<p>Various debugging methods to explore molecule queries and transactional commands.</p>
<h2 id="21"><a href="#top">☝︎</a> Sbt-molecule plugin compilation speed optimizations</h2>
<p><em>2018-11-25 v0.16.1</em></p>
<p>Minor upgrade to match <a href="https://github.com/scalamolecule/sbt-molecule">sbt-molecule</a> plugin v0.7.0.</p>
<p>When compiling a molecule project with <code>sbt compile</code>, compilation of boilerplate code is now 4-5x faster than with v0.6.2. Using lazy vals for attributes and methods for reference namespaces did the trick.</p>
<p>Since attributes are now defined as lazy vals in boilerplate code, we can no longer override some super/base structure where we earlier saved the doc comments. Alternatively we could add doc comments to all arities of boilerplate attributes. But that would be a lot of redundancy. Combined with the massive compilation speed improvement doc comments are therefore skipped.</p>
<h2 id="20"><a href="#top">☝︎</a> Async API + tx functions</h2>
<p><em>2018-11-25 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.16.0">v0.16.0</a></em></p>
<h3 id="syncasyncapis">Sync/AsyncAPIs</h3>
<p>All getter methods now have an asynchronous equivalent method that returns a Scala Future with the data:</p>
<ul>
<li><code>get</code> / <code>getAsync</code> - Default List of typed tuples for convenient access to smaller data sets.</li>
<li><code>getArray</code> / <code>getAsyncArray</code> - Array of typed tuples for fast retrieval and traversing of large data sets.</li>
<li><code>getIterable</code> / <code>getAsyncIterable</code> - Iterable of typed tuples for lazy evaluation of data</li>
<li><code>getJson</code> / <code>getAsyncJson</code> - Json formatted result data</li>
<li><code>getRaw</code> / <code>getAsyncRaw</code> - Raw untyped data from Datomic</li>
</ul>
<p>All transactional operations on molecules now similarly have async implementations returning a Future with a <code>TxReport</code> containing data about the transaction.</p>
<ul>
<li><code>save</code> / <code>saveAsync</code></li>
<li><code>insert</code> / <code>insertAsync</code></li>
<li><code>update</code> / <code>updateAsync</code></li>
<li><code>retract</code> / <code>retractAsync</code></li>
</ul>
<h3 id="tx-functions">Tx functions</h3>
<p>Molecule now implements typed transaction functions.</p>
<p>Within the tx function you have access to the transaction database value so that you can ensure any synchronization constraints before returning the resulting tx statements to be transacted. To abort the whole transaction if a constraint is not met, simply throw an exception. Either all tx statements will transact successfully or none will thereby ensuring atomicity of the transaction.</p>
<p>Any complexity of logic can be performed within a tx function as long as no side effects are produced (like trying to update the database within the tx method body).</p>
<h3 id="tx-function-definitions">Tx function definitions</h3>
<p>Tx functions in Datomic are untyped (takes arguments of type <code>Object</code>). But Molecule allows you to define typed tx methods inside a <code>@TxFns</code>-annotated object that will automatically create equivalent &ldquo;twin&rdquo; functions with the shape that Datomic expects and save them in the Datamic database transparently for you.</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nd">@TxFns</span>
<span class="k">object</span> <span class="nc">myTxFns</span> <span class="o">{</span>
  <span class="c1">// Constraint check before multiple updates
</span><span class="c1"></span>  <span class="k">def</span> <span class="n">transfer</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">conn</span><span class="k">:</span> <span class="kt">Conn</span><span class="o">)</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">Statement</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="c1">// Validate sufficient funds in from-account
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">curFromBalance</span> <span class="k">=</span> <span class="nc">Ns</span><span class="o">(</span><span class="n">from</span><span class="o">).</span><span class="n">int</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">headOption</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    
    <span class="k">if</span> <span class="o">(</span><span class="n">curFromBalance</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="o">)</span>
      <span class="c1">// Throw exception to abort the whole transaction
</span><span class="c1"></span>      <span class="k">throw</span> <span class="k">new</span> <span class="nc">TxFnException</span><span class="o">(</span><span class="s">s&#34;Can&#39;t transfer </span><span class="si">$amount</span><span class="s"> from account </span><span class="si">$from</span><span class="s"> having a balance of only </span><span class="si">$curFromBalance</span><span class="s">.&#34;</span><span class="o">)</span>

    <span class="c1">// Calculate new balances
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">newFromBalance</span> <span class="k">=</span> <span class="n">curFromBalance</span> <span class="o">-</span> <span class="n">amount</span>
    <span class="k">val</span> <span class="n">newToBalance</span> <span class="k">=</span> <span class="nc">Ns</span><span class="o">(</span><span class="n">to</span><span class="o">).</span><span class="n">int</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">headOption</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">amount</span>

    <span class="c1">// Update accounts
</span><span class="c1"></span>    <span class="nc">Ns</span><span class="o">(</span><span class="n">from</span><span class="o">).</span><span class="n">int</span><span class="o">(</span><span class="n">newFromBalance</span><span class="o">).</span><span class="n">getUpdateStmts</span> <span class="o">++</span> <span class="nc">Ns</span><span class="o">(</span><span class="n">to</span><span class="o">).</span><span class="n">int</span><span class="o">(</span><span class="n">newToBalance</span><span class="o">).</span><span class="n">getUpdateStmts</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>Tx function are invoked in application code with the <code>transact</code> or <code>transactAsync</code> method:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">transact</span><span class="o">(</span><span class="n">transfer</span><span class="o">(</span><span class="n">fromAccount</span><span class="o">,</span> <span class="n">toAccount</span><span class="o">,</span> <span class="mi">20</span><span class="o">))</span>
</code></pre></div><p><code>transact</code> (or <code>transactAsync</code>) is a macro that analyzes the tx function signature to be able to invoke its generated twin method within Datomic.</p>
<h3 id="bundled-transactions">Bundled transactions</h3>
<p>If the transactional logic is not dependent on access to the transaction database value, multiple &ldquo;bundled&rdquo; tx statements can now be created by adding molecule tx statements to one of the bundling <code>transact</code> or <code>transactAsync</code> methods:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">transact</span><span class="o">(</span>
  <span class="c1">// retract
</span><span class="c1"></span>  <span class="n">e1</span><span class="o">.</span><span class="n">getRetractStmts</span><span class="o">,</span>
  <span class="c1">// save
</span><span class="c1"></span>  <span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">(</span><span class="mi">4</span><span class="o">).</span><span class="n">getSaveStmts</span><span class="o">,</span>
  <span class="c1">// insert
</span><span class="c1"></span>  <span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">getInsertStmts</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)),</span>
  <span class="c1">// update
</span><span class="c1"></span>  <span class="nc">Ns</span><span class="o">(</span><span class="n">e2</span><span class="o">).</span><span class="n">int</span><span class="o">(</span><span class="mi">20</span><span class="o">).</span><span class="n">getUpdateStmts</span>
<span class="o">)</span>
</code></pre></div><p>Tx statement getters for the molecule operations are used to get the tx statements to be transacted in one transaction. As with tx functions, only all tx statements will atomically transact or none will if there is some transactional error.</p>
<h3 id="composite-syntax">Composite syntax</h3>
<p>Composite molecules are now tied together with <code>+</code> instead of <code>~</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">m</span><span class="o">(</span><span class="nc">Ref2</span><span class="o">.</span><span class="n">int2</span> <span class="o">+</span> <span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">sorted</span> <span class="o">===</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">11</span><span class="o">),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><p>This change was made to avoid collision with the upcoming splice operator <code>~</code> in the next major version of Scala/Dotty (see <a href="https://www.scala-lang.org/blog/2018/04/30/in-a-nutshell.html">MACROS: THE PLAN FOR SCALA 3</a>)</p>
<p>Composite inserts previously had its own special insert method but now shares syntax with other inserts</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nc">List</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Ref2</span><span class="o">.</span><span class="n">int2</span> <span class="o">+</span> <span class="nc">Ns</span><span class="o">.</span><span class="n">int</span> <span class="n">insert</span> <span class="nc">Seq</span><span class="o">(</span>
  <span class="c1">// Two rows of data
</span><span class="c1"></span>  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">11</span><span class="o">),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
<span class="o">)</span> <span class="n">eids</span>
</code></pre></div><h2 id="19"><a href="#top">☝︎</a> 10x-100x Compilation speed boost!</h2>
<p><em>2018-10-25 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.15.0">v0.15.0</a></em></p>
<p>The core macro transformation engine has been re-written from the ground up and <a href="http://www.lihaoyi.com/post/MicrooptimizingyourScalacode.html#bit-packing">micro-optimizations</a> applied wherever possible. This has resulted in dramatic compilation speed improvements, some several orders of magnitude!</p>
<p>Macro materialization of molecules earlier produced a lot of code that has now been moved out to static methods. An absolute minimal amount of code is now generated minimizing the job of the macros and the compiler. As an example, the <a href="https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/seattle/SeattleTests.scala">Seattle tests</a> file sometimes took up to 70 seconds to compile and now average around 4 seconds. Some long molecules with close to 22 attributes almost never finished compiling but now take about 2 seconds to compile! This is good news since users of Molecule can therefore now freely create as large molecules as they please without any speed penalty.</p>
<h3 id="5-optimized-getter-groups">5 optimized getter groups</h3>
<p>Type casting of returned data from Datomic was earlier not completely optimized. Taking advice from <a href="http://www.lihaoyi.com/post/BenchmarkingScalaCollections.html">Haoyi&rsquo;s &ldquo;Benchmarking Scala Collections&rdquo;</a> Molecule now also returns super fast mutable pre-allocated Arrays of typed data for large data sets.</p>
<p>Json has also been thoroughly optimized to build as fast as possible directly from raw Datomic data.</p>
<p>So Molecule now offers 5 optimized <a href="http://www.scalamolecule.org/api/molecule/action/get/">getter groups</a>:</p>
<ul>
<li><code>get</code> - Default List of typed tuples for convenient access to smaller data sets.</li>
<li><code>getArray</code> - Array of typed tuples for fast retrieval and traversing of large data sets.</li>
<li><code>getIterable</code> - Iterable of typed tuples for lazy evaluation of data</li>
<li><code>getJson</code> - Json formatted result data</li>
<li><code>getRaw</code> - Raw untyped data from Datomic</li>
</ul>
<p>Each getter group comes with all time-related variations:</p>
<ul>
<li><code>get</code></li>
<li><code>getAsOf(t)</code></li>
<li><code>getSince(t)</code></li>
<li><code>getWith(txData)</code></li>
<li><code>getHistory</code> (only implemented for List getter)</li>
</ul>
<h2 id="18"><a href="#top">☝︎</a> Scala docs and semantic updates</h2>
<p><em>2018-09-06 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.14.0">v0.14.0</a></em></p>
<p>Major overhaul of Molecule:</p>
<h3 id="thorough-scala-docs-api-documentation">Thorough Scala docs API documentation</h3>
<p>All relevant public interfaces have been documented in the new <a href="http://www.scalamolecule.org/api/molecule">Scala docs</a>. Shortcuts to Scala docs sub packages and documents are also directly available via &ldquo;API docs&rdquo; in the menu on the <a href="http://www.scalamolecule.org">Molecule website</a>.</p>
<p>To aid constructing molecules in your code, all attributes defined now also have Scala docs automatically defined by the <a href="https://github.com/scalamolecule">sbt-molecule plugin</a> upon compilation.</p>
<h3 id="input-molecules-correctly-implemented">Input molecules correctly implemented</h3>
<p>Input molecules are now semantically correctly implemented and thoroughly tested (<a href="https://github.com/scalamolecule/molecule/blob/master/molecule-tests/src/test/scala/molecule/tests/core/input1">1 input</a>, <a href="https://github.com/scalamolecule/molecule/blob/master/molecule-tests/src/test/scala/molecule/tests/core/input2">2 inputs</a>, <a href="https://github.com/scalamolecule/molecule/blob/master/molecule-tests/src/test/scala/molecule/tests/core/input3">3 inputs</a>).</p>
<h3 id="interfaces-updated-and-streamlined">Interfaces updated and streamlined</h3>
<p>The standard getters return Lists of tuples of type-casted tuples.</p>
<ul>
<li><code>get</code></li>
<li><code>getAsOf(t)</code></li>
<li><code>getSince(t)</code></li>
<li><code>getHistory</code></li>
<li><code>getWith(txData)</code></li>
</ul>
<p>If large data sets are expected, an Iterable of tuples of lazily type-cased tuples can be retrieved instead. Data is type-casted on each call to <code>next</code> on the iterator.</p>
<ul>
<li><code>getIterable</code></li>
<li><code>getIterableAsOf(t)</code></li>
<li><code>getIterableSince(t)</code></li>
<li><code>getIterableHistory</code></li>
<li><code>getIterableWith(txData)</code></li>
</ul>
<p>If typed data is not required we can get the raw untyped java collections of Lists of objects.</p>
<ul>
<li><code>getRaw</code></li>
<li><code>getRawAsOf(t)</code></li>
<li><code>getRawSince(t)</code></li>
<li><code>getRawHistory</code></li>
<li><code>getRawWith(txData)</code></li>
</ul>
<h3 id="breaking-changes">Breaking changes</h3>
<p>The whole directory layout of the Molecule library has been re-arranged and optimized, including many interfaces. So you might have to change some method names if you have used earlier versions of Molecule.</p>
<h2 id="17"><a href="#top">☝︎</a> Native Json output</h2>
<p><em>2017-11-13 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.13.0">v0.13.0</a></em></p>
<p>We can now get data in json format directly from the database by calling <code>getJson</code> on a molecule. So instead of converting tuples of data to json with some 3rd party library we can call <code>getJson</code> and pass the json data string directly to an Angular table for instance.</p>
<p>Internally, Molecule builds the json string in a StringBuffer directly from the raw data coming from Datomic (with regards to types being quoted or not). This should make it the fastest way of supplying json data when needed.</p>
<h3 id="flat-data">Flat data</h3>
<p>Normal &ldquo;flat&rdquo; molecules creates json with a row on each line in the output:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">getJson</span> <span class="o">===</span>
  <span class="s">&#34;&#34;&#34;[
</span><span class="s">    |{&#34;name&#34;: &#34;John&#34;, &#34;age&#34;: 38},
</span><span class="s">    |{&#34;name&#34;: &#34;Lisa&#34;, &#34;age&#34;: 35}
</span><span class="s">    |]&#34;&#34;&#34;</span><span class="o">.</span><span class="n">stripMargin</span>
</code></pre></div><h3 id="composite-data">Composite data</h3>
<p>Composite data has potential field name clashes so each sub part of the composite is rendered as a separate json object tied together in an array for each row:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">m</span><span class="o">(</span><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span> <span class="o">~</span> <span class="nc">Category</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">importance</span><span class="o">).</span><span class="n">getJson</span> <span class="o">===</span>
  <span class="s">&#34;&#34;&#34;[
</span><span class="s">    |[{&#34;name&#34;: &#34;John&#34;, &#34;age&#34;: 38}, {&#34;name&#34;: &#34;Marketing&#34;, &#34;importance&#34;: 6}],
</span><span class="s">    |[{&#34;name&#34;: &#34;Lisa&#34;, &#34;age&#34;: 35}, {&#34;name&#34;: &#34;Management&#34;, &#34;importance&#34;: 7}]
</span><span class="s">    |]&#34;&#34;&#34;</span><span class="o">.</span><span class="n">stripMargin</span>
</code></pre></div><p>Note how a field <code>name</code> appears in each sub object. Since the molecule is defined in client code it is presumed that the semantics of eventual duplicate field names are also handled by client code.</p>
<h3 id="nested-data">Nested data</h3>
<p>Nested date is rendered as a json array with json objects for each nested row:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="o">(</span><span class="nc">Invoice</span><span class="o">.</span><span class="n">no</span><span class="o">.</span><span class="n">customer</span><span class="o">.</span><span class="nc">InvoiceLines</span> <span class="o">*</span> <span class="nc">InvoiceLine</span><span class="o">.</span><span class="n">item</span><span class="o">.</span><span class="n">qty</span><span class="o">.</span><span class="n">amount</span><span class="o">).</span><span class="n">getJson</span> <span class="o">===</span>
  <span class="s">&#34;&#34;&#34;[
</span><span class="s">    |{&#34;no&#34;: 1, &#34;customer&#34;: &#34;Johnson&#34;, &#34;invoiceLines&#34;: [
</span><span class="s">    |   {&#34;item&#34;: &#34;apples&#34;, &#34;qty&#34;: 10, &#34;amount&#34;: 12.0},
</span><span class="s">    |   {&#34;item&#34;: &#34;oranges&#34;, &#34;qty&#34;: 7, &#34;amount&#34;: 3.5}]},
</span><span class="s">    |{&#34;no&#34;: 2, &#34;customer&#34;: &#34;Benson&#34;, &#34;invoiceLines&#34;: [
</span><span class="s">    |   {&#34;item&#34;: &#34;bananas&#34;, &#34;qty&#34;: 3, &#34;amount&#34;: 3.0},
</span><span class="s">    |   {&#34;item&#34;: &#34;oranges&#34;, &#34;qty&#34;: 1, &#34;amount&#34;: 0.5}]}
</span><span class="s">    |]&#34;&#34;&#34;</span><span class="o">.</span><span class="n">stripMargin</span>
</code></pre></div><h2 id="16"><a href="#top">☝︎</a> Optional values in save-molecules</h2>
<p><em>2017-05-28 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.12.0">v0.12.0</a></em></p>
<p>Often, form submissions have some optional field values. Molecule now allow us to <code>save</code> molecules with both mandatory and optional attributes.</p>
<p>We could for instance have <code>aName</code>,  <code>optionalLikes</code> and <code>anAge</code> values from a form submission that we want to save. We can now apply those values directly to a mandatory <code>name</code> attribute, an optional <code>likes$</code> attribute (<code>$</code> appended makes it optional) and a mandatory <code>age</code> attribute of a save-molecule and then save it:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span>
  <span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="n">aName</span><span class="o">)</span>
  <span class="o">.</span><span class="n">likes$</span><span class="o">(</span><span class="n">optionalLikes</span><span class="o">)</span>
  <span class="o">.</span><span class="n">age</span><span class="o">(</span><span class="n">anAge</span><span class="o">)</span>
  <span class="o">.</span><span class="n">save</span>
</code></pre></div><p>We can also, as before, <em>insert</em> the data using an &ldquo;insert-molecule&rdquo; as a template:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">likes$</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">insert</span><span class="o">(</span>
  <span class="n">aName</span><span class="o">,</span> <span class="n">optionalLikes</span><span class="o">,</span> <span class="n">anAge</span>
<span class="o">)</span>
</code></pre></div><p>It can be a matter of taste if you want to <code>save</code> or <code>insert</code> - but now you can choose :-)</p>
<h2 id="15"><a href="#top">☝︎</a> Time API</h2>
<p><em>2017-05-19 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.11.0">v0.11.0</a></em></p>
<p>Datomic has some extremely powerful time functionality that Molecule now makes available in an intuitive way:</p>
<h3 id="ad-hoc-time-queries">Ad-hoc time queries</h3>
<p>Ad-hoc time queries against our database can now be made with the following time-aware getter methods on a molecule:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">getAsOf</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">===</span> <span class="o">...</span> <span class="c1">// Persons as of a point in time `t`
</span><span class="c1"></span>
<span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">getSince</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">===</span> <span class="o">...</span> <span class="c1">// Persons added after a point in time `t`
</span><span class="c1"></span>
<span class="nc">Person</span><span class="o">(</span><span class="n">johnId</span><span class="o">).</span><span class="n">age</span><span class="o">.</span><span class="n">getHistory</span> <span class="o">===</span> <span class="o">...</span> <span class="c1">// Current and previous ages of John in the db
</span></code></pre></div><p><code>t</code> can be a transaction entity id (<code>Long</code>), a transaction number (<code>Long</code>) or a <code>java.util.Date</code>.</p>
<p>If we want to test the outcome of some transaction without affecting the production db we can apply transaction data to the <code>getWith(txData)</code> method:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">getWith</span><span class="o">(</span>
  <span class="c1">// Testing adding some transactional data to the current db
</span><span class="c1"></span>  <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="s">&#34;John&#34;</span><span class="o">).</span><span class="n">age</span><span class="o">(</span><span class="mi">24</span><span class="o">).</span><span class="n">saveTx</span><span class="o">,</span> <span class="c1">// Save transaction data
</span><span class="c1"></span>  <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">insertTx</span><span class="o">(</span>
    <span class="nc">List</span><span class="o">((</span><span class="s">&#34;Lisa&#34;</span><span class="o">,</span> <span class="mi">20</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;Pete&#34;</span><span class="o">,</span> <span class="mi">55</span><span class="o">))</span> <span class="c1">// Insert transaction data
</span><span class="c1"></span>  <span class="o">),</span>
  <span class="nc">Person</span><span class="o">(</span><span class="n">johnId</span><span class="o">).</span><span class="n">age</span><span class="o">(</span><span class="mi">28</span><span class="o">).</span><span class="n">updateTx</span><span class="o">,</span> <span class="c1">// Update transaction data
</span><span class="c1"></span>  <span class="n">someEntityId</span><span class="o">.</span><span class="n">retractTx</span> <span class="c1">// Retraction transaction data
</span><span class="c1"></span><span class="o">)</span> <span class="o">===</span> <span class="o">...</span> <span class="c1">// Persons from db including transactions tested 
</span></code></pre></div><p>By adding the <code>Tx</code> suffix to the standard molecule commands (<code>save</code>, <code>insert</code>, <code>update</code> or <code>retract</code>) we can get the transactional data that those operations would normally transact directly. Here, <code>&lt;command&gt;Tx</code> methods on transaction molecules just return the transaction data so that we can apply it to the <code>getWith(txData)</code> method. This make it convenient for us to ask speculative questions like &ldquo;what would I get if I did those transactions&rdquo;.</p>
<p>For more complex test scenarios we can now use a test database:</p>
<h3 id="test-db">Test db</h3>
<p>All molecules expect an implicit connection object to be in scope. If we then set a temporary test database on such <code>conn</code> object we can subsequentially freely perform tests against this temporary database as though it was a &ldquo;branch&rdquo; (think git).</p>
<p>When the connection/db goes out of scope it is simply garbage collected automatically by the JVM. At any point we can also explicitly go back to continuing using our live production db.</p>
<p>To make a few tests with our filtered db we can now do like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Current state
</span><span class="c1"></span><span class="nc">Person</span><span class="o">(</span><span class="n">johnId</span><span class="o">).</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">head</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="s">&#34;John&#34;</span><span class="o">,</span> <span class="mi">37</span><span class="o">)</span>

<span class="c1">// Create &#34;branch&#34; of our production db as it is right now
</span><span class="c1"></span><span class="n">conn</span><span class="o">.</span><span class="n">testDbAsOfNow</span>  

<span class="c1">// Perform multiple operations on test db
</span><span class="c1"></span><span class="nc">Person</span><span class="o">(</span><span class="n">johnId</span><span class="o">).</span><span class="n">name</span><span class="o">(</span><span class="s">&#34;Johnny&#34;</span><span class="o">).</span><span class="n">update</span>
<span class="nc">Person</span><span class="o">(</span><span class="n">johnId</span><span class="o">).</span><span class="n">age</span><span class="o">(</span><span class="mi">38</span><span class="o">).</span><span class="n">update</span>

<span class="c1">// Verify expected outcome of operations
</span><span class="c1"></span><span class="nc">Person</span><span class="o">(</span><span class="n">johnId</span><span class="o">).</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">head</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="s">&#34;Johnny&#34;</span><span class="o">,</span> <span class="mi">38</span><span class="o">)</span>

<span class="c1">// Then go back to production state
</span><span class="c1"></span><span class="n">conn</span><span class="o">.</span><span class="n">useLiveDb</span>

<span class="c1">// Production state is unchanged!
</span><span class="c1"></span><span class="nc">Person</span><span class="o">(</span><span class="n">johnId</span><span class="o">).</span><span class="n">name</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">head</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="s">&#34;John&#34;</span><span class="o">,</span> <span class="mi">37</span><span class="o">)</span>
</code></pre></div><h3 id="test-db-with-domain-classes">Test db with domain classes</h3>
<p>When molecules are used inside domain classes we want to test the domain operations also without affecting the state of our production database. And also ideally without having to create mockups of our domain objects. This is now possible by setting a temporary test database on the implicit connection object that all molecules expect to be present in their scope - which includes the molecules inside domain classes.</p>
<p>When we test against a temporary database, Molecule internally uses the <code>with</code> function of Datomic to apply transaction data to a &ldquo;branch&rdquo; of the database that is simply garbage collected when it goes out of scope!</p>
<p>To make a few tests on a domain object that have molecule calls internally we can now do like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Some domain object that we want to test
</span><span class="c1"></span><span class="k">val</span> <span class="n">domainObj</span> <span class="k">=</span> <span class="nc">MyDomainClass</span><span class="o">(</span><span class="n">params</span><span class="o">..)</span> <span class="c1">// having molecule transactions inside...
</span><span class="c1"></span><span class="n">domainObj</span><span class="o">.</span><span class="n">myState</span> <span class="o">===</span> <span class="s">&#34;some state&#34;</span>

<span class="c1">// Create &#34;branch&#34; of our production db as it is right now
</span><span class="c1"></span><span class="n">conn</span><span class="o">.</span><span class="n">testDbAsOfNow</span>  

<span class="c1">// Test some domain object operations
</span><span class="c1"></span><span class="n">domainObj</span><span class="o">.</span><span class="n">doThis</span>
<span class="n">domainObj</span><span class="o">.</span><span class="n">doThat</span>

<span class="c1">// Verify expected outcome of operations
</span><span class="c1"></span><span class="n">domainObj</span><span class="o">.</span><span class="n">myState</span> <span class="o">===</span> <span class="s">&#34;some expected changed state&#34;</span>

<span class="c1">// Then go back to production state
</span><span class="c1"></span><span class="n">conn</span><span class="o">.</span><span class="n">useLiveDb</span>

<span class="c1">// Production state is unchanged!
</span><span class="c1"></span><span class="n">domainObj</span><span class="o">.</span><span class="n">myState</span> <span class="o">==</span> <span class="s">&#34;some state&#34;</span>
</code></pre></div><p>Since internal domain methods will in turn call other domain methods that also expects an implicit conn object then the same test db is even propragated recursively inside the chain of domain operations.</p>
<h3 id="multiple-time-views">Multiple time views</h3>
<p>We can apply the above approach with several time views of our database:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">conn</span><span class="o">.</span><span class="n">testDbAsOfNow</span>
<span class="n">conn</span><span class="o">.</span><span class="n">testDbAsOf</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">testDbSince</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
<span class="n">conn</span><span class="o">.</span><span class="n">testWith</span><span class="o">(</span><span class="n">txData</span><span class="o">)</span>
</code></pre></div><p>This make it possible to run arbitrarily complex test scenarios directly against our production data at any point in time without having to do any manual setup or tear-down of mock domain/database objects!</p>
<h2 id="14"><a href="#top">☝︎</a> Entity selection retrieval and manipulation</h2>
<p><em>2016-10-19 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.10.0">v0.10.0</a></em></p>
<p>Molecule now allows retrieving attribute values of selected entities:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nc">List</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">,</span> <span class="n">e3</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">insert</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">eids</span>

<span class="c1">// Use selected entity ids to access attributes of those entities
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">).</span><span class="n">int</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="c1">// Or use a variable with a collection of entity ids
</span><span class="c1"></span><span class="k">val</span> <span class="n">e23</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">e2</span><span class="o">,</span> <span class="n">e3</span><span class="o">)</span>
<span class="nc">Ns</span><span class="o">(</span><span class="n">e23</span><span class="o">).</span><span class="n">int</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div><p>Likewise we can update attribute values of selected entities (group editing):</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">int</span> <span class="n">insert</span> <span class="nc">List</span><span class="o">((</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="n">eids</span>

<span class="c1">// Apply value to attribute of multiple entities
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">).</span><span class="n">int</span><span class="o">(</span><span class="mi">4</span><span class="o">).</span><span class="n">update</span>
<span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">sorted</span> <span class="o">===</span> <span class="nc">List</span><span class="o">((</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;c&#34;</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
</code></pre></div><p>See more examples <a href="https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/attr/EntitySelection.scala">here</a> and <a href="https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/manipulation/UpdateMultipleEntities.scala">here</a>.</p>
<p>Datomic encourages multi-step queries where you find some entities ids with one query and then pass those ids on as input to the following query. Since we don&rsquo;t have the cost of round-trips to a database server, this is a powerful technique that Molecule now supports with ease.</p>
<h2 id="13"><a href="#top">☝︎</a> Bidirectional references</h2>
<p><em>2016-07-24 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.9.0">v0.9.0</a></em></p>
<p>Major upgrade of Molecule introducing <em>Bidirectional</em> references.</p>
<p>Normal Datomic references are unidirectional. If we add a friend reference from Ann to Ben</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="s">&#34;Ann&#34;</span><span class="o">).</span><span class="nc">Friends</span><span class="o">.</span><span class="n">name</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="n">save</span>
</code></pre></div><p>Then we can naturally query to get friends of Ann</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">name_</span><span class="o">(</span><span class="s">&#34;Ann&#34;</span><span class="o">).</span><span class="nc">Friends</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">)</span>
</code></pre></div><p>But what if we want to find friends of Ben? This will give us nothing:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">name_</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="nc">Friends</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">()</span>
</code></pre></div><p>Instead we would have to think backwards to get the back reference</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"> <span class="nc">Person</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nc">Friends</span><span class="o">.</span><span class="n">name_</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;Ann&#34;</span><span class="o">)</span>
</code></pre></div><p>If we want to traverse deeper into a friendship graph we would have to query both forward and backward for each step in the graph which would quickly become a pain. With Molecules new bidirectional references we can uniformly query from both ends:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"> <span class="nc">Person</span><span class="o">.</span><span class="n">name_</span><span class="o">(</span><span class="s">&#34;Ann&#34;</span><span class="o">).</span><span class="nc">Friends</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">)</span>
 <span class="nc">Person</span><span class="o">.</span><span class="n">name_</span><span class="o">(</span><span class="s">&#34;Ben&#34;</span><span class="o">).</span><span class="nc">Friends</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;Ann&#34;</span><span class="o">)</span>
</code></pre></div><p>Please see <a href="http://www.scalamolecule.org/documentation/query/bidirectional%20refs/">Bidirectional refs</a> for more information and the <a href="https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/gremlin/gettingStarted/">Gremlin graph examples</a>.</p>
<ul>
<li>This release also adds support for BigInts and BigDecimals. Only bytes is not supported now due to the limited capabilities this type has in Datomic.</li>
<li>Input molecules can now also include nested data structures.</li>
</ul>
<h2 id="12"><a href="#top">☝︎</a> Composites &amp; Tx meta data</h2>
<p><em>2016-06-13 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.8.0">v0.8.0</a></em></p>
<p><a href="http://www.scalamolecule.org/documentation/query/composites/">Composites</a> and <a href="http://www.scalamolecule.org/documentation/query/txMetaData/">Transaction meta data</a> are two new major functionalities added to Molecule.</p>
<p>Merge up to 22 sub-molecules as a Composite. Composite inserts create entities with data of attributes type-checking against each sub-molecule. Sub-molecules don&rsquo;t need to be related. The created entity is what ties it all together which is a core feature of Datomic that sets it apart from table/join-thinking.</p>
<p>An obvious candidate for composites is cross-cutting data that could be applied to any entity of our domain - like Tags. No need anymore to litter all parts of your domain with refs to Tags. Keep your domain namespaces intrinsic and compose instead!</p>
<p>Even transaction meta data can now be applied:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Insert comma-separated molecules that become one composite molecule
</span><span class="c1"></span><span class="n">insert</span><span class="o">(</span>
  <span class="nc">Article</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">author</span><span class="o">,</span> <span class="nc">Tag</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">weight</span>
<span class="o">)(</span>
  <span class="c1">// 2 entities/&#34;rows&#34; created 
</span><span class="c1"></span>  <span class="o">((</span><span class="s">&#34;Battle of Waterloo&#34;</span><span class="o">,</span> <span class="s">&#34;Ben Bridge&#34;</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;serious&#34;</span><span class="o">,</span> <span class="mi">5</span><span class="o">)),</span>
  <span class="o">((</span><span class="s">&#34;Best jokes ever&#34;</span><span class="o">,</span> <span class="s">&#34;John Cleese&#34;</span><span class="o">),</span> <span class="o">(</span><span class="s">&#34;fun&#34;</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="o">)(</span>
  <span class="c1">// Transaction meta data is saved with the tx entity created
</span><span class="c1"></span>  <span class="nc">MetaData</span><span class="o">.</span><span class="n">submitter_</span><span class="o">(</span><span class="s">&#34;Brenda Johnson&#34;</span><span class="o">).</span><span class="n">usecase_</span><span class="o">(</span><span class="s">&#34;AddReviews&#34;</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><p>And we can then query the composed molecule:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Important articles submitted by Brenda Johnson
</span><span class="c1">// In queries we tie composite molecule parts together with `~`
</span><span class="c1"></span><span class="n">m</span><span class="o">(</span><span class="nc">Article</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">author</span> <span class="o">~</span> <span class="nc">Tag</span><span class="o">.</span><span class="n">weight</span><span class="o">.&gt;=(</span><span class="mi">4</span><span class="o">).</span><span class="n">tx_</span><span class="o">(</span><span class="nc">MetaData</span><span class="o">.</span><span class="n">submitter_</span><span class="o">(</span><span class="s">&#34;Brenda Johnson&#34;</span><span class="o">))).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">((</span><span class="s">&#34;Battle of Waterloo&#34;</span><span class="o">,</span> <span class="s">&#34;Ben Bridge&#34;</span><span class="o">),</span> <span class="mi">5</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><h2 id="11"><a href="#top">☝︎</a> sbt-molecule plugin code generation</h2>
<p><em>2016-06-04 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.7.0">v0.7.0</a></em></p>
<p>Previous fragile build system now standardized to use the new <a href="https://github.com/scalamolecule/sbt-molecule">sbt-molecule plugin</a> to generate and package Molecule boilerplate code.</p>
<p>Several updates to <a href="http://www.scalamolecule.org">scalamolecule.org</a>.</p>
<h2 id="10"><a href="#top">☝︎</a> Various improvements and bug fixes</h2>
<p><em>2016-05-30 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.6.2">v0.6.2</a></em></p>
<ul>
<li>HList support dropped (was very incomplete anyway)</li>
<li><a href="https://github.com/scalamolecule/molecule/commit/70a951c5742ffe3925d777c0dfc284f223414445">Support for inserting more than 22 facts for a single namespace</a></li>
<li><a href="https://github.com/scalamolecule/molecule/commit/2c18c1e0255e0179d07272179ad1140d748abeec">Null references</a> now supported</li>
<li><a href="https://github.com/scalamolecule/molecule/commit/508e93753eb1e8080a24b40af6fb9ab8c229d0aa">Boilerplate in/out separated to avoid too big boilerplate files</a></li>
<li><a href="https://github.com/scalamolecule/molecule/commit/a4680b2ec483ec66ce4128e4cdd9657a9ad09fdb">Negation now takes Seq of values</a></li>
<li>Upgrade to sbt 0.13.11 using a build.sbt file</li>
</ul>
<h2 id="9"><a href="#top">☝︎</a> Keyed attribute maps</h2>
<p><em>2016-04-25 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.6.1">v0.6.1</a></em></p>
<p>Each defined attribute map now adds an additional attribute with a &ldquo;K&rdquo; appended to the attribute name. This &ldquo;Keyed attribute map&rdquo; expects a key and will then return the single value type instead of a Map of key/values:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="c1">// Normal attribute map returning maps of key/values
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">greetings</span><span class="o">(</span><span class="s">&#34;en&#34;</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi there&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hello&#34;</span><span class="o">))</span>
<span class="o">)</span>

<span class="c1">// &#34;Keyed attribute map&#34; returning values directly (matching the key)
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">greetingsK</span><span class="o">(</span><span class="s">&#34;en&#34;</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&#34;Hi there&#34;</span><span class="o">),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&#34;Hi&#34;</span><span class="o">),</span>
  <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">&#34;Hello&#34;</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><p>This makes it more convenient to get to the values directly instead of having to extract them from returned Maps.</p>
<h2 id="8"><a href="#top">☝︎</a> Map Attributes - Multilingual support</h2>
<p><em>2015-12-14 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.5.0">v0.5.0</a></em></p>
<p>Molecule now supports an easy way to handle multilingual values; say, names of greetings in different languages for various entities - all with one &ldquo;Map Attribute&rdquo; like <code>greetings</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">greetings</span> <span class="n">insert</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi there&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;fr&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Bonjour&#34;</span><span class="o">,</span> <span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hello&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;da&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hej&#34;</span><span class="o">))</span>
<span class="o">)</span>
</code></pre></div><p>Other types are supported too. So we could for instance have timezones as Double values for different countries etc.</p>
<p>Each key is prepended to its value and saved as a cardinality many value (&ldquo;en@Hi there&rdquo;) in Datomic. When we then retrieve the values, Molecule automatically splits the values into typed key/value pairs in a map so that we can conveniently continue to work with them in Scala:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">greetings</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi there&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;fr&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Bonjour&#34;</span><span class="o">,</span> <span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hello&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;da&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hej&#34;</span><span class="o">))</span>
<span class="o">)</span>

<span class="c1">// English values only (find all values having &#34;en&#34; as key)
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">greetings</span><span class="o">(</span><span class="s">&#34;en&#34;</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi there&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hello&#34;</span><span class="o">))</span>
<span class="o">)</span>

<span class="c1">// English values containing the substring &#34;Hi&#34;
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">greetings</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi&#34;</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hi there&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Oh, Hi&#34;</span><span class="o">))</span>
<span class="o">)</span>

<span class="c1">// All values containing the substring &#34;He&#34;
</span><span class="c1"></span><span class="nc">Ns</span><span class="o">.</span><span class="n">int</span><span class="o">.</span><span class="n">greetings</span><span class="o">(</span><span class="s">&#34;_&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;He&#34;</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;en&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hello&#34;</span><span class="o">)),</span>
  <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&#34;da&#34;</span> <span class="o">-&gt;</span> <span class="s">&#34;Hej&#34;</span><span class="o">))</span>
<span class="o">)</span>
</code></pre></div><h2 id="7"><a href="#top">☝︎</a> Nested adjacent references</h2>
<p><em>2015-11-14 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.4.3">v0.4.3</a></em></p>
<p>If we insert a nested data structure like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">m</span><span class="o">(</span><span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="nc">Refs1</span> <span class="o">*</span> <span class="o">(</span><span class="nc">Ref1</span><span class="o">.</span><span class="n">int1</span><span class="o">.</span><span class="nc">Refs2</span> <span class="o">*</span> <span class="nc">Ref2</span><span class="o">.</span><span class="n">int2</span><span class="o">))</span> <span class="n">insert</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span>
    <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="mi">11</span><span class="o">)))),</span>
  <span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span>
    <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="mi">21</span><span class="o">,</span> <span class="mi">22</span><span class="o">)),</span>
    <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="mi">31</span><span class="o">)))))</span>
</code></pre></div><p>we can now query for each <code>Ns.str</code> paired with all its nested <code>Ref2.int2</code>&rsquo;s:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">m</span><span class="o">(</span><span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="nc">Refs1</span> <span class="o">*</span> <span class="nc">Ref1</span><span class="o">.</span><span class="nc">Refs2</span><span class="o">.</span><span class="n">int2</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="mi">11</span><span class="o">)),</span>
  <span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="mi">22</span><span class="o">,</span> <span class="mi">21</span><span class="o">,</span> <span class="mi">31</span><span class="o">)))</span>
</code></pre></div><p>Resolution is recursive, so Molecule handles arbitrarily deep nested data structures.</p>
<h2 id="6"><a href="#top">☝︎</a> Back references in nested inserts/gets</h2>
<p><em>2015-11-13 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.4.2">v0.4.2</a></em></p>
<p>Now we can insert/get related values from multiple related namespaces in one go:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="n">m</span><span class="o">(</span><span class="n">lit_Book</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="nc">Author</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nc">_Book</span><span class="o">.</span><span class="nc">Reviewers</span> <span class="o">*</span> <span class="n">gen_Person</span><span class="o">.</span><span class="n">name</span><span class="o">)</span> <span class="n">insert</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="s">&#34;book&#34;</span><span class="o">,</span> <span class="s">&#34;John&#34;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;Marc&#34;</span><span class="o">))</span>
<span class="o">)</span>
<span class="n">m</span><span class="o">(</span><span class="n">lit_Book</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="nc">Author</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="nc">_Book</span><span class="o">.</span><span class="nc">Reviewers</span> <span class="o">*</span> <span class="n">gen_Person</span><span class="o">.</span><span class="n">name</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="s">&#34;book&#34;</span><span class="o">,</span> <span class="s">&#34;John&#34;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="s">&#34;Marc&#34;</span><span class="o">))</span>
<span class="o">)</span>
</code></pre></div><p>From the <code>Book</code> namespace we reference first the <code>Author</code> namespace and then go back to the <code>Book</code> namespace again with the <code>_Book</code> back reference so that we can then reference the <code>Reviewers</code> namespace. Like multiple connected &ldquo;arms&rdquo; of a complex molecule.</p>
<h2 id="5"><a href="#top">☝︎</a> Differentiating between optional values in insert/get</h2>
<p><em>2015-10-28 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.4.1">v0.4.1</a></em></p>
<p>Single optional values should be retrievable. But when inserting we want to avoid creating orphan referenced entities with no asserted attribute values. Example from <a href="https://github.com/scalamolecule/molecule/blob/8e5c0437c245201f5e174cb407ae74cdbc654257/coretest/src/test/scala/molecule/Relations.scala#L196-L236">Relations</a> test:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="s">&#34;No mandatory attributes after card-one ref&#34;</span> <span class="n">in</span> <span class="k">new</span> <span class="nc">CoreSetup</span> <span class="o">{</span>
  <span class="n">m</span><span class="o">(</span><span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="nc">Ref1</span><span class="o">.</span><span class="n">int1</span><span class="o">)</span> <span class="n">insert</span> <span class="nc">List</span><span class="o">(</span>
    <span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span>
    <span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>

  <span class="c1">// Ok to ask for an optional referenced value
</span><span class="c1"></span>  <span class="n">m</span><span class="o">(</span><span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="nc">Ref1</span><span class="o">.</span><span class="n">int1$</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">==&gt;</span> <span class="nc">List</span><span class="o">(</span>
    <span class="o">(</span><span class="s">&#34;a&#34;</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">)),</span>
    <span class="o">(</span><span class="s">&#34;b&#34;</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span>

  <span class="c1">// But in insert molecules we don&#39;t want to create referenced orphan entities
</span><span class="c1"></span>  <span class="o">(</span><span class="n">m</span><span class="o">(</span><span class="nc">Ns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="nc">Ref1</span><span class="o">.</span><span class="n">int1$</span><span class="o">).</span><span class="n">insert</span> <span class="n">must</span> <span class="n">throwA</span><span class="o">[</span><span class="kt">RuntimeException</span><span class="o">]).</span><span class="n">message</span> <span class="o">===</span> <span class="s">&#34;Got the exception&#34;</span> <span class="o">+</span>
    <span class="s">&#34;java.lang.RuntimeException: &#34;</span> <span class="o">+</span>
    <span class="s">&#34;[output.Molecule:modelCheck (4)] Namespace `Ref1` in insert molecule&#34;</span> <span class="o">+</span> 
    <span class="s">&#34;has no mandatory attributes. Please add at least one.&#34;</span>
<span class="o">}</span>
</code></pre></div><h2 id="4"><a href="#top">☝︎</a> Optional values (like Null)</h2>
<p><em>2015-10-25 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.4.0">v0.4.0</a></em></p>
<p>Molecule now supports optional values:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">names</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">.</span><span class="n">firstName</span><span class="o">.</span><span class="n">middleName$</span><span class="o">.</span><span class="n">lastName</span><span class="o">.</span><span class="n">get</span> <span class="n">map</span> <span class="o">{</span> 
  <span class="k">case</span> <span class="o">(</span><span class="n">firstName</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">middleName</span><span class="o">),</span> <span class="n">lastName</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&#34;</span><span class="si">$firstName</span><span class="s"> </span><span class="si">$middleName</span><span class="s"> </span><span class="si">$lastName</span><span class="s">&#34;</span> 
  <span class="k">case</span> <span class="o">(</span><span class="n">firstName</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="n">lastName</span><span class="o">)</span>             <span class="k">=&gt;</span> <span class="s">s&#34;</span><span class="si">$firstName</span><span class="s"> </span><span class="si">$lastName</span><span class="s">&#34;</span> 
<span class="o">}</span>
</code></pre></div><p>Also when inserting varying data sets, this comes in handy, like for instance if middle names are sometimes present and sometimes not:</p>
<div class="highlight"><pre class="chroma"><code class="language-scala" data-lang="scala"><span class="nc">Person</span><span class="o">.</span><span class="n">firstName</span><span class="o">.</span><span class="n">middleName$</span><span class="o">.</span><span class="n">lastName</span> <span class="n">insert</span> <span class="nc">List</span><span class="o">(</span>
  <span class="o">(</span><span class="s">&#34;John&#34;</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="s">&#34;Doe&#34;</span><span class="o">),</span>
  <span class="o">(</span><span class="s">&#34;Lisa&#34;</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&#34;van&#34;</span><span class="o">),</span> <span class="s">&#34;Hauen&#34;</span><span class="o">)</span>
<span class="o">)</span>
</code></pre></div><p>See more examples of even deeply nested optional values in the <a href="https://github.com/scalamolecule/molecule/blob/80765bfbae17657cd0fa0fa099a6ba22f41a179f/coretest/src/test/scala/molecule/OptionalValues.scala">OptionalValues</a> tests.</p>
<h2 id="3"><a href="#top">☝︎</a> Nested data structures</h2>
<p><em>2015-10-04 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.3.0">v0.3.0</a></em></p>
<p><a href="https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/dayOfDatomic/ProductsAndOrders.scala">Products and Orders</a> shows how Molecule can now retrieve nested data structures at up to 10 levels deep (more can be implemented if necessary). This means that you don&rsquo;t need to manually organize the flat output from Datomic into hierarchical data structures yourself when you query for one-many or many-many data. Molecule does it for you.</p>
<h2 id="2"><a href="#top">☝︎</a> Implemented Day-Of-Datomic and MBrainz</h2>
<p><em>2014-12-25 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.2.0">v0.2.0</a></em></p>
<ul>
<li>Nested molecules</li>
<li>Transitive molecules</li>
<li>Simplifying API</li>
</ul>
<h2 id="1"><a href="#top">☝︎</a> Initial commit - <a href="../community/seattle/">Seattle tutorial</a></h2>
<p><em>2014-07-02 <a href="https://github.com/scalamolecule/molecule/releases/tag/v0.1.0">v0.1.0</a></em></p>

    </div>

    <div class="col-sm-2" style="padding-left:24px;padding-right: 0px;position:sticky;top:115px">
        
<button type="button" id="sidebarCollapse" class="navbar-toggle collapsed" data-toggle="collapse" style="color:#bbb">
  <i class="glyphicon glyphicon-align-left"></i>
</button>

<nav class="bs-docs-sidebar" id="sidebar">
  <ul class="bs-docs-sidenav nav">
    
  </ul>
</nav>
    </div>

</div> 

     
   
 


</div> 

<footer class="bs-docs-footer">

  <div class="container" style="font-size:15px">
    <ul class="bs-docs-footer-links">
      <li style="margin-top: 8px;"><a href="../front/"><img src="https://www.scalamolecule.org/img/logo/MoleculeLogo150.png" alt=""></a></li>
      <li><a href="https://github.com/scalamolecule/molecule">GitHub</a></li>
      <li><a href="https://github.com/scalamolecule/molecule-web">GitHub-web</a></li>
      <li><a href="https://gitter.im/scalamolecule/Lobby">Gitter</a></li>
      <li><a href="https://groups.google.com/forum/#!forum/molecule-dsl">Forum</a></li>
      <li><a href="../about/">About</a></li>
      <li><a href="../credits/">Credits</a></li>
      <li><a href="../changelog">Changelog</a></li>
    </ul>
    <p>Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="license">Apache License 2.0</a></p>
  </div>
</footer>


<script type="text/javascript" src="../js/jquery-1.11.2.min.js"></script>
<script type="text/javascript" src="../js/bootstrap.min.js"></script>


<script type="text/javascript" src="../js/scripts.js"></script>
<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<script src="../js/copy-button.js"></script>
<script src="../js/sidebar-collapser.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-2787756-3', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>
