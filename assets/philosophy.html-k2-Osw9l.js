import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,d as l,a as t,b as o,e as s,w as n,r as p,o as c}from"./app-BSvPAByx.js";const m={};function h(d,e){const a=p("nobr");return c(),r("div",null,[e[3]||(e[3]=l('<h1 id="design-philosophy" tabindex="-1"><a class="header-anchor" href="#design-philosophy"><span>Design Philosophy</span></a></h1><p>Keep it simple</p><ul><li>No macros</li><li>No type classes</li><li>Sparse implicits</li><li>No higher-order type</li><li>Meta Model without type parameters <ul><li>Fully serializable for interconnectivity</li></ul></li></ul><h3 id="let-data-come-to-scala" tabindex="-1"><a class="header-anchor" href="#let-data-come-to-scala"><span>Let Data come to Scala</span></a></h3><p>The common approach by most database libraries is to <em>accommodate to the database</em>. Either by offering to write interpolated raw query strings that the database wants or with a DSL that tries to mimmick the operations of a database like <code>select</code>, <code>filter</code> etc. - in other words <em>letting Scala come to Data</em>.</p>',5)),t("p",null,[e[1]||(e[1]=o("Molecule takes the opposite approach of letting you write vanilla Scala with the words of your domain in the most simple and intuitive way as if you were coding the data structures of your domain with your domain classes. Molecule then transparently translate this code (molecules) to the language of each database wihout you having to limit your mental model of your domain with database implementation details. ",-1)),s(a,null,{default:n(()=>[...e[0]||(e[0]=[t("em",null,"Let Data come to Scala",-1)])]),_:1}),e[2]||(e[2]=o(".",-1))])])}const g=i(m,[["render",h]]),f=JSON.parse('{"path":"/database/developer/philosophy.html","title":"Design Philosophy","lang":"en-US","frontmatter":{"description":"Design Philosophy Keep it simple No macros No type classes Sparse implicits No higher-order type Meta Model without type parameters Fully serializable for interconnectivity Let ...","toc":{"levels":[2,3]},"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Design Philosophy\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-29T22:23:29.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://www.scalamolecule.org/intro/database/developer/philosophy.html"}],["meta",{"property":"og:site_name","content":"Scala Molecule"}],["meta",{"property":"og:title","content":"Design Philosophy"}],["meta",{"property":"og:description","content":"Design Philosophy Keep it simple No macros No type classes Sparse implicits No higher-order type Meta Model without type parameters Fully serializable for interconnectivity Let ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-09-29T22:23:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-29T22:23:29.000Z"}]]},"git":{"createdTime":1759184609000,"updatedTime":1759184609000,"contributors":[{"name":"marcgrue","username":"marcgrue","email":"marcgrue@gmail.com","commits":1,"url":"https://github.com/marcgrue"}]},"filePathRelative":"database/developer/philosophy.md","autoDesc":true}');export{g as comp,f as data};
