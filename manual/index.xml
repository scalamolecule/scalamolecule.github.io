<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Manuals on Molecule</title>
    <link>http://scalamolecule.github.io/manual/</link>
    <description>Recent content in Manuals on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Fri, 02 Jan 2015 22:06:44 CET</lastBuildDate>
    <atom:link href="http://scalamolecule.github.io/manual/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Manual</title>
      <link>http://scalamolecule.github.io/manual/overview/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.github.io/manual/overview/</guid>
      <description>

&lt;h1 id=&#34;molecule-manual:68f80267fa3a50980dbb745a782b8dca&#34;&gt;Molecule manual&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Introduction&lt;/li&gt;
&lt;li&gt;Setup&lt;/li&gt;
&lt;li&gt;Model&lt;/li&gt;
&lt;li&gt;Schema

&lt;ul&gt;
&lt;li&gt;Definition&lt;/li&gt;
&lt;li&gt;Types&lt;/li&gt;
&lt;li&gt;Options&lt;/li&gt;
&lt;li&gt;Enum values&lt;/li&gt;
&lt;li&gt;Modelling trategies&lt;/li&gt;
&lt;li&gt;Queries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Indexes&lt;/li&gt;
&lt;li&gt;Optimization&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reference?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FAQ&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Troubleshooting&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Overview&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Datomic&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Seattle&lt;/li&gt;
&lt;li&gt;Whirlwind of Datomic&lt;/li&gt;
&lt;li&gt;Day of Datomic&lt;/li&gt;
&lt;li&gt;MBrainz&lt;/li&gt;
&lt;li&gt;nuBank&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Web&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entity ids&lt;/li&gt;
&lt;li&gt;Authorization&lt;/li&gt;
&lt;li&gt;REST?&lt;/li&gt;
&lt;li&gt;Pagination&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Graph&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Traversal&lt;/li&gt;
&lt;li&gt;Hyperedges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Relationships&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Aggregates&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursive queries (practical uses)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Schema queries (practical uses)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Attributes</title>
      <link>http://scalamolecule.github.io/manual/basics/attributes/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.github.io/manual/basics/attributes/</guid>
      <description>

&lt;h1 id=&#34;attributes:199f4b06fef5a61f833f209ac24fd4c2&#34;&gt;Attributes&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Basics</title>
      <link>http://scalamolecule.github.io/manual/basics/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.github.io/manual/basics/</guid>
      <description>

&lt;h1 id=&#34;basics:adb90e22eee79282d53440b555325fbd&#34;&gt;Basics&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Quick start&lt;/li&gt;
&lt;li&gt;Getting started

&lt;ul&gt;
&lt;li&gt;Introduction&lt;/li&gt;
&lt;li&gt;Installation&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Installation&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;safe:adb90e22eee79282d53440b555325fbd&#34;&gt;Safe&lt;/h3&gt;

&lt;p&gt;Our query asks for entities having values defined for all three attributes. If some entity doesn&amp;rsquo;t have the &lt;code&gt;street&lt;/code&gt; attribute set it won&amp;rsquo;t be returned. So we can safely assume that our result set contains no null values and we therefore return the raw values (without using Optional for instance).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Database setup</title>
      <link>http://scalamolecule.github.io/manual/database-setup/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.github.io/manual/database-setup/</guid>
      <description>

&lt;h1 id=&#34;database-setup:029b5641f6c81b30970318acf78606be&#34;&gt;Database setup&lt;/h1&gt;

&lt;p&gt;To create a fresh in-memory Datomic database we simply pass an URI string to
&lt;code&gt;Peer.createDatabase&lt;/code&gt; (to be sure that this URI is not already populated we
first delete it):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val uri = &amp;quot;datomic:mem://seattle&amp;quot;
Peer.deleteDatabase(uri)
Peer.createDatabase(uri)
implicit val conn = Peer.connect(uri)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We save the returned Datomic Connection as an implicit value so that our
molecules can later issue queries against it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Modelling</title>
      <link>http://scalamolecule.github.io/manual/modelling/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.github.io/manual/modelling/</guid>
      <description>

&lt;h1 id=&#34;modelling:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Modelling&lt;/h1&gt;

&lt;p&gt;A Datomic &lt;code&gt;schema&lt;/code&gt; defines the set of &lt;code&gt;attributes&lt;/code&gt; you can assign to &lt;code&gt;entities&lt;/code&gt;.
We organize &lt;code&gt;attributes&lt;/code&gt; in &lt;code&gt;namespaces&lt;/code&gt; to group related qualities:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.github.io/img/DatomicElements1.png&#34; alt=&#34;Schema&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This makes it easier to overview our domain data structures.&lt;/p&gt;

&lt;h4 id=&#34;schema-table:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Schema != Table&lt;/h4&gt;

&lt;p&gt;If coming from an sql background one might at first think of a namespace as
a table having columns (attributes). But this is not the case. An
entity in Datomic can associate values of attributes &lt;em&gt;from any namespace&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.github.io/img/DatomicElements2.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This gives us great freedom to model our domain with more &amp;ldquo;loose&amp;rdquo; namespaces rather than &amp;ldquo;hardcoded things&amp;rdquo; as table definitions. Later we can compose entities grabbing specific attributes from various namespaces as needed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Schema definition</title>
      <link>http://scalamolecule.github.io/manual/schema-definition/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.github.io/manual/schema-definition/</guid>
      <description>

&lt;h1 id=&#34;defining-a-schema:cd34be2af46d72d5650506b793ee6fb3&#34;&gt;Defining a schema&lt;/h1&gt;

&lt;p&gt;In Molecule you simply define namespaces as Scala vanilla traits having
fields that model each attribute.&lt;/p&gt;

&lt;p&gt;Defining the schema of the
&lt;a href=&#34;http://docs.datomic.com/tutorial.html&#34;&gt;Datomic Seattle tutorial&lt;/a&gt;
for instance looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(3, 8)
trait Community {
  val name         = oneString.fullTextSearch
  val url          = oneString.fullTextSearch
  val category     = manyString.fullTextSearch
  val orgtype      = oneEnum(&#39;community, &#39;commercial, &#39;nonprofit, &#39;personal)
  val `type`       = oneEnum(&#39;email_list, &#39;twitter, &#39;facebook_page, &#39;blog, &#39;website, &#39;wiki, &#39;myspace, &#39;ning)
  val neighborhood = one[Neighborhood]
}

trait Neighborhood {
  val name     = oneString.fullTextSearch.uniqueIdentity
  val district = one[District]
}

trait District {
  val name   = oneString.fullTextSearch.uniqueIdentity
  val region = oneEnum(&#39;n, &#39;ne, &#39;e, &#39;se, &#39;s, &#39;sw, &#39;w, &#39;nw)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;in-out-arities:cd34be2af46d72d5650506b793ee6fb3&#34;&gt;In/Out arities&lt;/h3&gt;

&lt;p&gt;We annotate the first namespace in the schema with &lt;code&gt;@InOut(x, y)&lt;/code&gt;. This is to tell Molecule
how many inputs and outputs we expect molecules to be able to accept.&lt;/p&gt;

&lt;p&gt;An input molecule like &lt;code&gt;Community.name(?).url(?)&lt;/code&gt; for instance awaits 2 inputs. For now the
maximum is 3. Given that input values can be expressions like &lt;code&gt;name(&amp;quot;John&amp;quot; or &amp;quot;Lisa&amp;quot;)&lt;/code&gt; it seems
unlikely that we will need to receive input for much more than 3 attributes at a time.&lt;/p&gt;

&lt;p&gt;Outputs are the number of attributes we can build a molecule of. &lt;code&gt;Community.name.url.Neighborhood.name&lt;/code&gt;
for instance has 3 attributes (in 2 namespaces). We need to be able to return tuples of values from
molecules so we can&amp;rsquo;t exceed Scala&amp;rsquo;s arity limit of 22 for tuples.&lt;/p&gt;

&lt;h3 id=&#34;attribute-types:cd34be2af46d72d5650506b793ee6fb3&#34;&gt;Attribute types&lt;/h3&gt;

&lt;p&gt;In the Seattle schema we defined 3 namespaces with different kinds of attributes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oneString&lt;/code&gt;, &lt;code&gt;manyString&lt;/code&gt; etc defines cardinality and type of an attribute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oneEnum&lt;/code&gt;/&lt;code&gt;manyEnum&lt;/code&gt; defines enumerated values&lt;/li&gt;
&lt;li&gt;&lt;code&gt;one[&amp;lt;ReferencedNamespace&amp;gt;]&lt;/code&gt; defines a reference to another namespace&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;attribute-options:cd34be2af46d72d5650506b793ee6fb3&#34;&gt;Attribute options&lt;/h3&gt;

&lt;p&gt;Each attribute can also have some extra options:&lt;/p&gt;

&lt;p&gt;
&lt;table border=&#34;1&#34; cellpadding=&#34;5&#34; cellspacing=&#34;0&#34; style=&#34;background-color:#f5f5f5;&#34;&gt;
  &lt;tr&gt;
    &lt;th align=&#34;left&#34; valign=&#34;top&#34; scope=&#34;col&#34;&gt;Option&lt;/th&gt;
    &lt;th valign=&#34;top&#34; scope=&#34;col&#34;&gt;&lt;strong&gt;Indexes&lt;/strong&gt;&lt;/th&gt;
    &lt;th scope=&#34;col&#34;&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;doc&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Attribute description.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueValue&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a different entity id will fail.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueIdentity&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity and &amp;quot;upsert&amp;quot; is enabled.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a temporary entity id will cause all attributes associated with that temporary id to be merged with the entity already in the database.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;indexed&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generated index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;fullTextSearch&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generate eventually consistent fulltext search index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;isComponent&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Specifies that an attribute whose type is :db.type/ref refers to a subcomponent of the entity to which the attribute is applied.&lt;br&gt;
    &lt;em&gt;When you retract an entity with :db.fn/retractEntity, all subcomponents are also retracted. When you touch an entity, all its subcomponent entities are touched recursively.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;noHistory&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Whether past values of an attribute should not be retained.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/p&gt;

&lt;p&gt;Datomic indexes the values of all attributes having an option except for the &lt;code&gt;doc&lt;/code&gt; and &lt;code&gt;noHistory&lt;/code&gt; options.&lt;/p&gt;

&lt;p&gt;As you saw, we added &lt;code&gt;fulltextSearch&lt;/code&gt; and &lt;code&gt;uniqueIdentity&lt;/code&gt; to some of the attributes in the Seattle definition above. Molecule&amp;rsquo;s schema definition DSL let&amp;rsquo;s you only choose allowed options for any attribute type.&lt;/p&gt;

&lt;h2 id=&#34;transacting-a-schema:cd34be2af46d72d5650506b793ee6fb3&#34;&gt;Transacting a schema&lt;/h2&gt;

&lt;p&gt;Having defined our domain in namespaces of attributes we then run &lt;code&gt;sbt compile&lt;/code&gt;.
This makes Molecule automatically transform our definitions to transactional
data in a format that Datomic needs in a schema file. Our two first attributes
&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;url&lt;/code&gt; for instance transforms to the following list of maps of key/values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object SeattleSchema extends Schema {

  lazy val tx = Util.list(

    // Community ----------------------------------------------------------

    Util.map(&amp;quot;:db/id&amp;quot;                , Peer.tempid(&amp;quot;:db.part/db&amp;quot;),
             &amp;quot;:db/ident&amp;quot;             , &amp;quot;:community/name&amp;quot;,
             &amp;quot;:db/valueType&amp;quot;         , &amp;quot;:db.type/string&amp;quot;,
             &amp;quot;:db/cardinality&amp;quot;       , &amp;quot;:db.cardinality/one&amp;quot;,
             &amp;quot;:db/fulltext&amp;quot;          , true.asInstanceOf[Object],
             &amp;quot;:db.install/_attribute&amp;quot;, &amp;quot;:db.part/db&amp;quot;),

    Util.map(&amp;quot;:db/id&amp;quot;                , Peer.tempid(&amp;quot;:db.part/db&amp;quot;),
             &amp;quot;:db/ident&amp;quot;             , &amp;quot;:community/url&amp;quot;,
             &amp;quot;:db/valueType&amp;quot;         , &amp;quot;:db.type/string&amp;quot;,
             &amp;quot;:db/cardinality&amp;quot;       , &amp;quot;:db.cardinality/one&amp;quot;,
             &amp;quot;:db/fulltext&amp;quot;          , true.asInstanceOf[Object],
             &amp;quot;:db.install/_attribute&amp;quot;, &amp;quot;:db.part/db&amp;quot;),
           
 // etc...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how each attribute name is prefixed with the namespace name (&amp;rdquo;:community/name&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Now we can easily transact the schema by simply writing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;conn.transact(SeattleSchema.tx).get()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Populate database</title>
      <link>http://scalamolecule.github.io/manual/populate-database/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.github.io/manual/populate-database/</guid>
      <description>

&lt;h1 id=&#34;populate-database:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Populate database&lt;/h1&gt;

&lt;p&gt;We have &lt;a href=&#34;https://github.com/scalamolecule/wiki/Setup-a-Datomic-database&#34;&gt;setup the database&lt;/a&gt; and now we want to populate it with data.&lt;/p&gt;

&lt;p&gt;If we recall the Seattle domain then we have some attributes organized in 3
related namespaces:&lt;/p&gt;

&lt;p&gt;[[images/DatomicElements3.png]]&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Community.type&lt;/code&gt;, &lt;code&gt;Community.orgtype&lt;/code&gt; and &lt;code&gt;District.region&lt;/code&gt; all have fixed
enumerated values to choose from. And &lt;code&gt;Community.category&lt;/code&gt; is the only
many-cardinality attribute allowed to have multiple values.&lt;/p&gt;

&lt;h3 id=&#34;data-molecule:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Data molecule&lt;/h3&gt;

&lt;p&gt;When we ran &lt;code&gt;sbt compile&lt;/code&gt;, Molecule also created some boilerplate code
that allow us to insert a new Seattle Community with its related Neighborhood
and District simply like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.insert
  .name(&amp;quot;AAA&amp;quot;)
  .url(&amp;quot;myUrl&amp;quot;)
  .`type`(&amp;quot;twitter&amp;quot;)
  .orgtype(&amp;quot;personal&amp;quot;)
  .category(&amp;quot;my&amp;quot;, &amp;quot;favorites&amp;quot;) // many cardinality allows multiple values
  .Neighborhood.name(&amp;quot;myNeighborhood&amp;quot;)
  .District.name(&amp;quot;myDistrict&amp;quot;).region(&amp;quot;nw&amp;quot;).save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can insert data by building a molecule where we apply a value to each
attribute and then simply save it. Molecule makes sure
that each attribute only accepts values of the expected type (in this
case all attributes expect Strings).&lt;/p&gt;

&lt;p&gt;Note also how we easily insert data across several namespaces in one go!&lt;/p&gt;

&lt;h3 id=&#34;template-molecule-data:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Template molecule + data&lt;/h3&gt;

&lt;p&gt;Normally we would insert bigger data sets that we have exported from
somewhere else. For this scenario we define a molecule where each
attribute match a value at a certain position of our rows of data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.url.`type`.orgtype.category
    .Neighborhood.name.District.name.region insert List(
  (&amp;quot;community1&amp;quot;, &amp;quot;url1&amp;quot;, &amp;quot;twitter&amp;quot;, &amp;quot;community&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName1&amp;quot;, &amp;quot;DistName1&amp;quot;, &amp;quot;e&amp;quot;),
  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;myspace&amp;quot;, &amp;quot;nonprofit&amp;quot;, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), 
    &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;nw&amp;quot;),
  (&amp;quot;community3&amp;quot;, &amp;quot;url3&amp;quot;, &amp;quot;website&amp;quot;, &amp;quot;personal&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName3&amp;quot;, &amp;quot;DistName3&amp;quot;, &amp;quot;w&amp;quot;),
  // etc..
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;missing-values-null-values:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Missing values (&amp;ldquo;Null values&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;We might have some &amp;ldquo;rows&amp;rdquo; (tuples) of imported data with a missing attribute
value. If for instance some row has no &lt;code&gt;orgtype&lt;/code&gt; value in the data set, we can
just use a &lt;code&gt;null&lt;/code&gt; placeholder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community4&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;blog&amp;quot;, null, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName4&amp;quot;, &amp;quot;DistName4&amp;quot;, &amp;quot;ne&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In an sql table we would &amp;ldquo;insert a null value&amp;rdquo; for such column. But with
Molecule/Datomic we just simply don&amp;rsquo;t assert any &lt;code&gt;orgtype&lt;/code&gt; value for that
entity at all! In other words: there is no &lt;code&gt;orgtype&lt;/code&gt; fact to be saved.&lt;/p&gt;

&lt;h3 id=&#34;type-safety:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Type safety&lt;/h3&gt;

&lt;p&gt;In this example we have only inserted text strings. But all input is type
checked against the selected attributes of the molecule which makes the
insert operation type safe. We even infer the expected type so that our
IDE will bark if it finds for instance an Integer somewhere in our input data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;type2&amp;quot;, 42, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;DistReg2&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A data set having the value &lt;code&gt;42&lt;/code&gt; as a value for the &lt;code&gt;orgtype&lt;/code&gt; attribute
won&amp;rsquo;t compile and our IDE will warn us of an invalid data set.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>