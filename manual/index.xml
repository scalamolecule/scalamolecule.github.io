<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Manuals on Molecule</title>
    <link>http://scalamolecule.org/manual/</link>
    <description>Recent content in Manuals on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Fri, 02 Jan 2015 22:06:44 CET</lastBuildDate>
    <atom:link href="http://scalamolecule.org/manual/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Manual</title>
      <link>http://scalamolecule.org/manual/overview/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/overview/</guid>
      <description>

&lt;h1 id=&#34;molecule-manual:68f80267fa3a50980dbb745a782b8dca&#34;&gt;Molecule manual&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Introduction&lt;/li&gt;
&lt;li&gt;Setup&lt;/li&gt;
&lt;li&gt;Model&lt;/li&gt;
&lt;li&gt;Schema

&lt;ul&gt;
&lt;li&gt;Definition&lt;/li&gt;
&lt;li&gt;Types&lt;/li&gt;
&lt;li&gt;Options&lt;/li&gt;
&lt;li&gt;Enum values&lt;/li&gt;
&lt;li&gt;Modelling trategies&lt;/li&gt;
&lt;li&gt;Queries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Indexes&lt;/li&gt;
&lt;li&gt;Optimization&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reference?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FAQ&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Troubleshooting&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Overview&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Datomic&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Seattle&lt;/li&gt;
&lt;li&gt;Whirlwind of Datomic&lt;/li&gt;
&lt;li&gt;Day of Datomic&lt;/li&gt;
&lt;li&gt;MBrainz&lt;/li&gt;
&lt;li&gt;nuBank&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Web&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entity ids&lt;/li&gt;
&lt;li&gt;Authorization&lt;/li&gt;
&lt;li&gt;REST?&lt;/li&gt;
&lt;li&gt;Pagination&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Graph&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Traversal&lt;/li&gt;
&lt;li&gt;Hyperedges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Relationships&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Aggregates&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursive queries (practical uses)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Schema queries (practical uses)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Builder</title>
      <link>http://scalamolecule.org/manual/attribute/builder/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/attribute/builder/</guid>
      <description>

&lt;h1 id=&#34;attribute-builder-pattern:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Attribute builder pattern&lt;/h1&gt;

&lt;p&gt;When we have defined a schema, Molecule generates the necessary boilerplate code so that we can build &amp;ldquo;molecular data structures&amp;rdquo; by building sequences of Attributes separated with dots (the &amp;ldquo;builder pattern&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;We could for instance build a molecule representing the data structure of Persons with name, age and gender Attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fundamental building blocks are Namespaces like &lt;code&gt;Person&lt;/code&gt; and Attributes like &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;gender&lt;/code&gt;. Namespaces are simply prefixes to Attribute names to avoid name clashes and to group our Attributes in meaningful ways according to our domain.&lt;/p&gt;

&lt;p&gt;As you see we start our molecule from some Namespace and then build on Attribute by Attribute.&lt;/p&gt;

&lt;h3 id=&#34;all-attributes-looked-for:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;All Attributes looked for&lt;/h3&gt;

&lt;p&gt;When we use a molecule to query the Datomic database we ask for entities having all our Attributes associated with them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that this is different from selecting rows from a sql table where you can also get null values back!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If for instance we have entities representing Persons in our data set that haven&amp;rsquo;t got any age Attribute associated with them then this query will &lt;em&gt;not&lt;/em&gt; return those entities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically we look for &lt;strong&gt;matches&lt;/strong&gt; to our molecule data structure.&lt;/p&gt;

&lt;h3 id=&#34;underscore-omits-values:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Underscore omits values&lt;/h3&gt;

&lt;p&gt;Sometimes we want to grap entities that we &lt;em&gt;know&lt;/em&gt; have certain attributes, but without returning those values. If for instance we wanted to find all names of Persons that have an age attribute set but we don&amp;rsquo;t need to return those age values, then we can add an underscore &lt;code&gt;_&lt;/code&gt; after the &lt;code&gt;age&lt;/code&gt; Attribute so that it becomes &lt;code&gt;age_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val names = Person.name.age_.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will return names of person entities having both a name and age Attribute set. Note how the age values are no longer returned from the type signatures:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)] = Person.name.age.get
val names  : List[String]        = Person.name.age_.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way we can switch on and off individual attributes from the result set without affecting the data structures we look for.&lt;/p&gt;

&lt;h3 id=&#34;tuples-or-hlists-returned:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Tuples or HLists returned&lt;/h3&gt;

&lt;p&gt;Molecule returns all result sets as either tuples of values (with &lt;code&gt;get&lt;/code&gt;) or Shapeless HLists (with &lt;code&gt;hl&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)]         = Person.name.age.get
val persons: List[String :: Int :: HNil] = Person.name.age.hl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;molecule-max-size:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Molecule max size&lt;/h3&gt;

&lt;p&gt;The size of molecules are limited to Scala&amp;rsquo;s limit size of 22 for tuples. Since molecules only look for attributes having a value it seems unlikely that we need to surpass this upper limit except in very special cases.&lt;/p&gt;

&lt;p&gt;Once the entities matching our qriteria are found we can use those entities to find additional optional attribute values.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Types</title>
      <link>http://scalamolecule.org/manual/attribute/types/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/attribute/types/</guid>
      <description>

&lt;h1 id=&#34;attribute-types:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Attribute types&lt;/h1&gt;

&lt;p&gt;Molecule Attributes can have the following types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one     Cardinality many
---------------     ----------------
String              Set[String]
Int                 Set[Int]   
Long                Set[Long]    
Float               Set[Float]     
Double              Set[Double]      
Boolean             N/A       
Date                Set[Date]    
UUID                Set[UUID]    
URI                 Set[URI]   
enum: String        enums: Set[String]              
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attribute are defined in your schema.&lt;/p&gt;

&lt;h3 id=&#34;types-inferred:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Types inferred&lt;/h3&gt;

&lt;p&gt;Types are inferred so that you can determine the result signature of a molecule&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)] = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cardinality-one-many:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Cardinality one/many&lt;/h3&gt;

&lt;p&gt;Attributes defined as cardinality-many will return sets of values. A Person could for instance have a &lt;code&gt;hobbies&lt;/code&gt; cardinality-many Attribute defined and thus return sets of hobby values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val engaged: List[(String, Set[String])] = Person.name.hobbies.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enums:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Enums&lt;/h3&gt;

&lt;p&gt;Enum values are predefined values that an Attribute can have. They are defined in your schema. Cardinality one enums can have one enum value and cardinality many can have a set of unique enum values for each entity.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Attributes</title>
      <link>http://scalamolecule.org/manual/attribute/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/attribute/</guid>
      <description>

&lt;h1 id=&#34;molecule-attributes:651c8385d47938834a1f2253cde93eb1&#34;&gt;Molecule Attributes&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/attribute/builder&#34;&gt;Build molecules&lt;/a&gt; with the builder pattern&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender  // require values
Person.name.age_.gender // require but omit values
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/attribute/types&#34;&gt;Infer types&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val name   : String      = Person.name.get.one
val age    : Int         = Person.age.get.one
val hobbies: Set[String] = Person.hobbies.get.one // cardinality-many
val gender : String      = Person.gender.get.one  // enum values
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/attribute/values&#34;&gt;Apply values&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(42)               // equal value
Person.age.&amp;lt;(42)             // range values
Person.age.!=(42)            // negated values
Person.name.contains(&amp;quot;John&amp;quot;) // fulltext search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/attribute/logical-or&#34;&gt;Apply logical-OR&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name(&amp;quot;John&amp;quot; or &amp;quot;Jonas&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/attribute/parameterize&#34;&gt;Parameterize&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val person      = Person.name(?).age(?)
val john        = person(&amp;quot;John&amp;quot; and 42) // logical-AND
val johnOrJonas = person((&amp;quot;John&amp;quot; and 42) or (&amp;quot;Jonas&amp;quot; and 38))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Values</title>
      <link>http://scalamolecule.org/manual/attribute/values/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/attribute/values/</guid>
      <description>

&lt;h1 id=&#34;applying-attribute-values:9c08d56b101cc26c9feeba7c0313bf79&#34;&gt;Applying Attribute values&lt;/h1&gt;

&lt;p&gt;We can apply values to Attributes in order to filter the data structures we are looking for. We could for instance look for names of female persons:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.gender.apply(&amp;quot;female&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or simply&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.gender(&amp;quot;female&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;omit-applied-value:9c08d56b101cc26c9feeba7c0313bf79&#34;&gt;Omit applied value&lt;/h3&gt;

&lt;p&gt;Instead of returning the gender value &amp;ldquo;female&amp;rdquo; for all entities returned we could add an underscore to only return the names of female persones:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val females: List[String] = Person.name.gender_(&amp;quot;female&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inferred-types:9c08d56b101cc26c9feeba7c0313bf79&#34;&gt;Inferred types&lt;/h3&gt;

&lt;p&gt;Only applied values matching the Attribute type can compile. And we can even infer the type in our IDE so that we will get warned if we try to apply a non-matchig type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// types match
Person.name(&amp;quot;John&amp;quot;).age(42)

// won&#39;t compile
// IDE will bark: 42(Int) is not of type String
Person.name(42)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Logical-OR</title>
      <link>http://scalamolecule.org/manual/attribute/logical-or/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/attribute/logical-or/</guid>
      <description>

&lt;h1 id=&#34;logical-or:55f1a6165be7a28dff30748e23c3dd18&#34;&gt;Logical-OR&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age_.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;tuples/hlist - limit of 22&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Parameterize</title>
      <link>http://scalamolecule.org/manual/attribute/parameterize/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/attribute/parameterize/</guid>
      <description>

&lt;h1 id=&#34;parameterize-attributes:913d405893862d6b41d1b084193fb4f6&#34;&gt;Parameterize Attributes&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age_.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;tuples/hlist - limit of 22&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Database setup</title>
      <link>http://scalamolecule.org/manual/database-setup/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/database-setup/</guid>
      <description>

&lt;h1 id=&#34;database-setup:029b5641f6c81b30970318acf78606be&#34;&gt;Database setup&lt;/h1&gt;

&lt;p&gt;To create a fresh in-memory Datomic database we simply pass an URI string to
&lt;code&gt;Peer.createDatabase&lt;/code&gt; (to be sure that this URI is not already populated we
first delete it):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val uri = &amp;quot;datomic:mem://seattle&amp;quot;
Peer.deleteDatabase(uri)
Peer.createDatabase(uri)
implicit val conn = Peer.connect(uri)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We save the returned Datomic Connection as an implicit value so that our
molecules can later issue queries against it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Modelling</title>
      <link>http://scalamolecule.org/manual/modelling/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/modelling/</guid>
      <description>

&lt;h1 id=&#34;modelling:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Modelling&lt;/h1&gt;

&lt;p&gt;A Datomic &lt;code&gt;schema&lt;/code&gt; defines the set of &lt;code&gt;attributes&lt;/code&gt; you can assign to &lt;code&gt;entities&lt;/code&gt;.
We organize &lt;code&gt;attributes&lt;/code&gt; in &lt;code&gt;namespaces&lt;/code&gt; to group related qualities:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/DatomicElements1.png&#34; alt=&#34;Schema&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This makes it easier to overview our domain data structures.&lt;/p&gt;

&lt;h4 id=&#34;schema-table:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Schema != Table&lt;/h4&gt;

&lt;p&gt;If coming from an sql background one might at first think of a namespace as
a table having columns (attributes). But this is not the case. An
entity in Datomic can associate values of attributes &lt;em&gt;from any namespace&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/DatomicElements2.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This gives us great freedom to model our domain with more &amp;ldquo;loose&amp;rdquo; namespaces rather than &amp;ldquo;hardcoded things&amp;rdquo; as table definitions. Later we can compose entities grabbing specific attributes from various namespaces as needed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Schema</title>
      <link>http://scalamolecule.org/manual/schema/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/</guid>
      <description>

&lt;h1 id=&#34;molecule-schema:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Molecule schema&lt;/h1&gt;

&lt;p&gt;A Molecule Schema defines what attributes you&amp;rsquo;ll have available to build molecules.&lt;/p&gt;

&lt;p&gt;Preparing your domain to use Molecule in 3 steps:&lt;/p&gt;

&lt;h3 id=&#34;1-define-schema:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;1. Define Schema&lt;/h3&gt;

&lt;p&gt;A schema defines what attributes you&amp;rsquo;ll have available to build molecules.&lt;/p&gt;

&lt;p&gt;Attributes having something in common are defined as fields in a namespace trait and we list all namespace traits in a Definition trait.&lt;/p&gt;

&lt;p&gt;Shortened example from the &lt;a href=&#34;http://docs.datomic.com/tutorial.html&#34;&gt;Datomic Seattle tutorial&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(3, 8)
trait SeattleDefinition {

  trait Community {
    val name         = oneString.fullTextSearch
    val url          = oneString
    val category     = manyString.fullTextSearch
    val orgtype      = oneEnum(&#39;community, &#39;commercial, &#39;nonprofit)
    val `type`       = oneEnum(&#39;email_list, &#39;twitter, &#39;facebook_page)
    val neighborhood = one[Neighborhood]
  }

  trait Neighborhood {
    val name     = oneString.fullTextSearch.uniqueIdentity
    val district = one[District]
  }

  trait District {
    val name   = oneString.fullTextSearch.uniqueIdentity
    val region = oneEnum(&#39;n, &#39;ne, &#39;e, &#39;se, &#39;s, &#39;sw, &#39;w, &#39;nw)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have a &lt;code&gt;Community&lt;/code&gt;, &lt;code&gt;Neighborhood&lt;/code&gt; and &lt;code&gt;District&lt;/code&gt; namespace each defining some attributes of various types.&lt;/p&gt;

&lt;p&gt;Model your own domain structures with similar schemas and save each definition in a file in a &amp;ldquo;schema&amp;rdquo; folder anywhere within your project.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-tell-sbt:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;2. Tell sbt&lt;/h3&gt;

&lt;p&gt;Tell sbt where to find your &amp;ldquo;schema&amp;rdquo; folders containing definition files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;settings = commonSettings ++ Seq(
  definitionDirectories(
    &amp;quot;examples/src/main/scala/molecule/examples/dayOfDatomic&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/seattle&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/mbrainz&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-compile-generate-boilerplate-code:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;3. Compile (generate boilerplate code)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sbt compile&lt;/code&gt; your project, wait for your domain-customized boilerplate code to be generated - and you&amp;rsquo;re ready to make intuitive molecule queries!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Definition</title>
      <link>http://scalamolecule.org/manual/schema/definition/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/definition/</guid>
      <description>

&lt;h1 id=&#34;define-molecule-schema:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Define Molecule Schema&lt;/h1&gt;

&lt;p&gt;Molecule provides an easy way to model your domain in a Molecule Schema.&lt;/p&gt;

&lt;p&gt;A simple dsl lets you define attributes of your domain by type, cardinality and options/values with as little ceremony as possible.&lt;/p&gt;

&lt;h3 id=&#34;attribute-types:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Attribute types&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(3, 8)
trait SeattleDefinition {

  trait Community {
    val name         = oneString.fullTextSearch
    val url          = oneString
    val category     = manyString.fullTextSearch
    val orgtype      = oneEnum(&#39;community, &#39;commercial, &#39;nonprofit)
    val `type`       = oneEnum(&#39;email_list, &#39;twitter, &#39;facebook_page)
    val neighborhood = one[Neighborhood]
  }

  trait Neighborhood {
    val name     = oneString.fullTextSearch.uniqueIdentity
    val district = one[District]
  }

  trait District {
    val name   = oneString.fullTextSearch.uniqueIdentity
    val region = oneEnum(&#39;n, &#39;ne, &#39;e, &#39;se, &#39;s, &#39;sw, &#39;w, &#39;nw)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the Seattle schema we define 3 namespaces with different kinds of attributes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oneString&lt;/code&gt;, &lt;code&gt;manyString&lt;/code&gt; etc defines cardinality and type of an attribute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oneEnum&lt;/code&gt;/&lt;code&gt;manyEnum&lt;/code&gt; defines enumerated values&lt;/li&gt;
&lt;li&gt;&lt;code&gt;one[&amp;lt;ReferencedNamespace&amp;gt;]&lt;/code&gt; defines a reference to another namespace&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;attribute-options:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Attribute options&lt;/h3&gt;

&lt;p&gt;Each attribute can also have some extra options:&lt;/p&gt;

&lt;p&gt;
&lt;table border=&#34;1&#34; cellpadding=&#34;5&#34; cellspacing=&#34;0&#34; style=&#34;background-color:#f5f5f5;&#34;&gt;
  &lt;tr&gt;
    &lt;th align=&#34;left&#34; valign=&#34;top&#34; scope=&#34;col&#34;&gt;Option&lt;/th&gt;
    &lt;th valign=&#34;top&#34; scope=&#34;col&#34;&gt;&lt;strong&gt;Indexes&lt;/strong&gt;&lt;/th&gt;
    &lt;th scope=&#34;col&#34;&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;doc&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Attribute description.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueValue&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a different entity id will fail.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueIdentity&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity and &amp;quot;upsert&amp;quot; is enabled.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a temporary entity id will cause all attributes associated with that temporary id to be merged with the entity already in the database.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;indexed&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generated index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;fullTextSearch&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generate eventually consistent fulltext search index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;isComponent&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Specifies that an attribute whose type is :db.type/ref refers to a subcomponent of the entity to which the attribute is applied.&lt;br&gt;
    &lt;em&gt;When you retract an entity with :db.fn/retractEntity, all subcomponents are also retracted. When you touch an entity, all its subcomponent entities are touched recursively.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;noHistory&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Whether past values of an attribute should not be retained.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/p&gt;

&lt;p&gt;Datomic indexes the values of all attributes having an option except for the &lt;code&gt;doc&lt;/code&gt; and &lt;code&gt;noHistory&lt;/code&gt; options.&lt;/p&gt;

&lt;p&gt;As you saw, we added &lt;code&gt;fulltextSearch&lt;/code&gt; and &lt;code&gt;uniqueIdentity&lt;/code&gt; to some of the attributes in the Seattle definition above. Molecule&amp;rsquo;s schema definition DSL let&amp;rsquo;s you only choose allowed options for any attribute type.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Files</title>
      <link>http://scalamolecule.org/manual/schema/files/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/files/</guid>
      <description>

&lt;h1 id=&#34;molecule-files:fdd0f32a8956014c694267605f409cb7&#34;&gt;Molecule files&lt;/h1&gt;

&lt;p&gt;Your Molecule schema definition file should be in a folder named &amp;ldquo;schema&amp;rdquo; anywhere within your source code:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/definition-file.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;telling-sbt:fdd0f32a8956014c694267605f409cb7&#34;&gt;Telling sbt&lt;/h3&gt;

&lt;p&gt;In the project build file we then tell sbt where such &amp;ldquo;schema&amp;rdquo; folders reside:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;settings = commonSettings ++ Seq(
  definitionDirectories(
    &amp;quot;examples/src/main/scala/molecule/examples/dayOfDatomic&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/mbrainz&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/seattle&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add several locations with the &lt;code&gt;definitionDirectories&lt;/code&gt; method which will tell sbt where to look for our schema definition files.&lt;/p&gt;

&lt;h3 id=&#34;files-generated:fdd0f32a8956014c694267605f409cb7&#34;&gt;Files generated&lt;/h3&gt;

&lt;p&gt;Running &lt;code&gt;sbt compile&lt;/code&gt; in your project root will then generate some source code files in the &lt;code&gt;src_managed&lt;/code&gt; directory (inside the target directory):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/generated-files.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;boilerplate-dsl-files:fdd0f32a8956014c694267605f409cb7&#34;&gt;Boilerplate dsl files&lt;/h3&gt;

&lt;p&gt;Molecule creates a &lt;code&gt;dsl&lt;/code&gt; folder having a subfolder - or &amp;ldquo;definition directory&amp;rdquo; - for each schema definition file (could be more than one).&lt;/p&gt;

&lt;p&gt;Within each definition directory we&amp;rsquo;ll find a file generated for each namespace defined (&lt;code&gt;Community.scala&lt;/code&gt; etc).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/boilerplate&#34;&gt;More on the boilerplate dsl files&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;schema-file:fdd0f32a8956014c694267605f409cb7&#34;&gt;Schema file&lt;/h3&gt;

&lt;p&gt;Molecule places the generated Datomic schema file &lt;code&gt;SeattleSchema&lt;/code&gt; in the same package as &lt;code&gt;SeattleDefinition&lt;/code&gt; so that they&amp;rsquo;ll turn up beside each other in our IDE package view:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/project-files.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/datomic&#34;&gt;More on the Datomic schema&amp;hellip;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boilerplate</title>
      <link>http://scalamolecule.org/manual/schema/boilerplate/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/boilerplate/</guid>
      <description>

&lt;h1 id=&#34;boilerplate-code:36a3cc328100a137a125b621a816413d&#34;&gt;Boilerplate code&lt;/h1&gt;

&lt;p&gt;SBT will call ask the &lt;code&gt;DslBoilerplate&lt;/code&gt; file in our project folder to use our schema definition files as templates to generate a series of domain-specific boilerplate traits for us.&lt;/p&gt;

&lt;p&gt;With these generated we can then build intuitive molecules like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.Neighborhood.name.District.region
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;namespace-traits:36a3cc328100a137a125b621a816413d&#34;&gt;Namespace traits&lt;/h3&gt;

&lt;p&gt;Each namespace is defined as a trait for each arity of our molecule. We start all molecules from a Namespace object like &lt;code&gt;Community&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// (simplified...)
object Community extends Community_0

trait Community_0  {
  val name          : /* types... */ = ???
  val url           : /* types... */ = ???
  val category      : /* types... */ = ???
  
  def Neighborhood  : /* types... */ = ???
}

trait Community_1  {
  val name          : /* types... */ = ???
  val url           : /* types... */ = ???
  val category      : /* types... */ = ???
  
  def Neighborhood  : /* types... */ = ???
}

// etc...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;increasing-arity:36a3cc328100a137a125b621a816413d&#34;&gt;Increasing arity&amp;hellip;&lt;/h3&gt;

&lt;p&gt;When we build &lt;code&gt;Community.name&lt;/code&gt;, the &lt;code&gt;name&lt;/code&gt; field of &lt;code&gt;Community_0&lt;/code&gt; points on to &lt;code&gt;Community_1&lt;/code&gt; since the arity of our molecule is now 1. We expect &lt;code&gt;Community.name&lt;/code&gt; to return values for 1 attribute.&lt;/p&gt;

&lt;p&gt;All fields are assigned the &lt;code&gt;???&lt;/code&gt; &amp;ldquo;unimplemented method&amp;rdquo; which will be implemented with a Scala macro when we compile our project during development (not the &lt;code&gt;sbt compile&lt;/code&gt; we do initially).&lt;/p&gt;

&lt;h3 id=&#34;in-out-arities:36a3cc328100a137a125b621a816413d&#34;&gt;In/Out arities&lt;/h3&gt;

&lt;p&gt;We annotate schema definition traits with &lt;code&gt;@InOut(x, y)&lt;/code&gt; to tell Molecule the arity of inputs and outputs we expect molecules to be able to accept.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(3, 8) // &amp;lt;-- In-arity: 3, Out-arity: 8
trait SeattleDefinition {
  // namespaces...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate up to a &lt;code&gt;Community_8&lt;/code&gt; but no further since we don&amp;rsquo;t expect in this case to build molecules with more than 8 attributes.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no reason to create more boilerplate classes than necessary. We can always adjust the number up or down and recompile with &lt;code&gt;sbt compile&lt;/code&gt; to re-generate the domain classes if our schema/requirements change.&lt;/p&gt;

&lt;h3 id=&#34;input-output-molecules:36a3cc328100a137a125b621a816413d&#34;&gt;Input/Output molecules&lt;/h3&gt;

&lt;p&gt;An input molecule like &lt;code&gt;Community.name(?).url(?)&lt;/code&gt; for instance awaits 2 inputs. For now the
maximum is 3. Given that input values can be expressions like &lt;code&gt;name(&amp;quot;John&amp;quot; or &amp;quot;Lisa&amp;quot;)&lt;/code&gt; it seems
unlikely that we will need to receive input for much more than 3 attributes at a time.&lt;/p&gt;

&lt;p&gt;Outputs are the number of attributes we can build a molecule of. &lt;code&gt;Community.name.url.Neighborhood.name&lt;/code&gt;
for instance has 3 attributes (in 2 namespaces). We need to be able to return tuples of values from
molecules so we can&amp;rsquo;t exceed Scala&amp;rsquo;s arity limit of 22 for tuples.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Datomic</title>
      <link>http://scalamolecule.org/manual/schema/datomic-schema/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/datomic-schema/</guid>
      <description>

&lt;h1 id=&#34;datomic-schema:8e92211a4ec532acc58a1fee7ac4346e&#34;&gt;Datomic schema&lt;/h1&gt;

&lt;p&gt;A Molecule schema definition of attributes &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;url&lt;/code&gt; like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;trait SeattleDefinition {
  trait Community {
    val name         = oneString.fullTextSearch
    val url          = oneString
    // etc...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will generate a corresponding Datomic schema definition with the following list of maps of key/values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object SeattleSchema extends Schema {

  lazy val tx = Util.list(

    // Community ------------------------------------------------

    Util.map(&amp;quot;:db/id&amp;quot;                , Peer.tempid(&amp;quot;:db.part/db&amp;quot;),
             &amp;quot;:db/ident&amp;quot;             , &amp;quot;:community/name&amp;quot;,
             &amp;quot;:db/valueType&amp;quot;         , &amp;quot;:db.type/string&amp;quot;,
             &amp;quot;:db/cardinality&amp;quot;       , &amp;quot;:db.cardinality/one&amp;quot;,
             &amp;quot;:db/fulltext&amp;quot;          , true.asInstanceOf[Object],
             &amp;quot;:db.install/_attribute&amp;quot;, &amp;quot;:db.part/db&amp;quot;),

    Util.map(&amp;quot;:db/id&amp;quot;                , Peer.tempid(&amp;quot;:db.part/db&amp;quot;),
             &amp;quot;:db/ident&amp;quot;             , &amp;quot;:community/url&amp;quot;,
             &amp;quot;:db/valueType&amp;quot;         , &amp;quot;:db.type/string&amp;quot;,
             &amp;quot;:db/cardinality&amp;quot;       , &amp;quot;:db.cardinality/one&amp;quot;,
             &amp;quot;:db/fulltext&amp;quot;          , true.asInstanceOf[Object],
             &amp;quot;:db.install/_attribute&amp;quot;, &amp;quot;:db.part/db&amp;quot;),
           
    // etc...
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how each attribute name is prefixed with the namespace name (&amp;rdquo;:community/name&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Our definition is transformed to a transactional data format that we can directly feed into Datomic to create a Datomic schema:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;conn.transact(SeattleSchema.tx).get()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Populate database</title>
      <link>http://scalamolecule.org/manual/populate-database/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/populate-database/</guid>
      <description>

&lt;h1 id=&#34;populate-database:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Populate database&lt;/h1&gt;

&lt;p&gt;We have &lt;a href=&#34;https://github.com/scalamolecule/wiki/Setup-a-Datomic-database&#34;&gt;setup the database&lt;/a&gt; and now we want to populate it with data.&lt;/p&gt;

&lt;p&gt;If we recall the Seattle domain then we have some attributes organized in 3
related namespaces:&lt;/p&gt;

&lt;p&gt;[[images/DatomicElements3.png]]&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Community.type&lt;/code&gt;, &lt;code&gt;Community.orgtype&lt;/code&gt; and &lt;code&gt;District.region&lt;/code&gt; all have fixed
enumerated values to choose from. And &lt;code&gt;Community.category&lt;/code&gt; is the only
many-cardinality attribute allowed to have multiple values.&lt;/p&gt;

&lt;h3 id=&#34;data-molecule:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Data molecule&lt;/h3&gt;

&lt;p&gt;When we ran &lt;code&gt;sbt compile&lt;/code&gt;, Molecule also created some boilerplate code
that allow us to insert a new Seattle Community with its related Neighborhood
and District simply like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.insert
  .name(&amp;quot;AAA&amp;quot;)
  .url(&amp;quot;myUrl&amp;quot;)
  .`type`(&amp;quot;twitter&amp;quot;)
  .orgtype(&amp;quot;personal&amp;quot;)
  .category(&amp;quot;my&amp;quot;, &amp;quot;favorites&amp;quot;) // many cardinality allows multiple values
  .Neighborhood.name(&amp;quot;myNeighborhood&amp;quot;)
  .District.name(&amp;quot;myDistrict&amp;quot;).region(&amp;quot;nw&amp;quot;).save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can insert data by building a molecule where we apply a value to each
attribute and then simply save it. Molecule makes sure
that each attribute only accepts values of the expected type (in this
case all attributes expect Strings).&lt;/p&gt;

&lt;p&gt;Note also how we easily insert data across several namespaces in one go!&lt;/p&gt;

&lt;h3 id=&#34;template-molecule-data:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Template molecule + data&lt;/h3&gt;

&lt;p&gt;Normally we would insert bigger data sets that we have exported from
somewhere else. For this scenario we define a molecule where each
attribute match a value at a certain position of our rows of data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.url.`type`.orgtype.category
    .Neighborhood.name.District.name.region insert List(
  (&amp;quot;community1&amp;quot;, &amp;quot;url1&amp;quot;, &amp;quot;twitter&amp;quot;, &amp;quot;community&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName1&amp;quot;, &amp;quot;DistName1&amp;quot;, &amp;quot;e&amp;quot;),
  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;myspace&amp;quot;, &amp;quot;nonprofit&amp;quot;, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), 
    &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;nw&amp;quot;),
  (&amp;quot;community3&amp;quot;, &amp;quot;url3&amp;quot;, &amp;quot;website&amp;quot;, &amp;quot;personal&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName3&amp;quot;, &amp;quot;DistName3&amp;quot;, &amp;quot;w&amp;quot;),
  // etc..
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;missing-values-null-values:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Missing values (&amp;ldquo;Null values&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;We might have some &amp;ldquo;rows&amp;rdquo; (tuples) of imported data with a missing attribute
value. If for instance some row has no &lt;code&gt;orgtype&lt;/code&gt; value in the data set, we can
just use a &lt;code&gt;null&lt;/code&gt; placeholder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community4&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;blog&amp;quot;, null, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName4&amp;quot;, &amp;quot;DistName4&amp;quot;, &amp;quot;ne&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In an sql table we would &amp;ldquo;insert a null value&amp;rdquo; for such column. But with
Molecule/Datomic we just simply don&amp;rsquo;t assert any &lt;code&gt;orgtype&lt;/code&gt; value for that
entity at all! In other words: there is no &lt;code&gt;orgtype&lt;/code&gt; fact to be saved.&lt;/p&gt;

&lt;h3 id=&#34;type-safety:e9f2a6d6fbcde0decfe7c5afb620a7be&#34;&gt;Type safety&lt;/h3&gt;

&lt;p&gt;In this example we have only inserted text strings. But all input is type
checked against the selected attributes of the molecule which makes the
insert operation type safe. We even infer the expected type so that our
IDE will bark if it finds for instance an Integer somewhere in our input data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;type2&amp;quot;, 42, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;DistReg2&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A data set having the value &lt;code&gt;42&lt;/code&gt; as a value for the &lt;code&gt;orgtype&lt;/code&gt; attribute
won&amp;rsquo;t compile and our IDE will warn us of an invalid data set.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>