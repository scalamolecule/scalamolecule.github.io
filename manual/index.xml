<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Manuals on Molecule</title>
    <link>http://scalamolecule.org/manual/</link>
    <description>Recent content in Manuals on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Fri, 02 Jan 2015 22:06:44 CET</lastBuildDate>
    <atom:link href="http://scalamolecule.org/manual/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Manual</title>
      <link>http://scalamolecule.org/manual/overview/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/overview/</guid>
      <description>

&lt;h1 id=&#34;molecule-manual:68f80267fa3a50980dbb745a782b8dca&#34;&gt;Molecule manual&lt;/h1&gt;

&lt;p&gt;This is a light-weight manual for Molecule.&lt;/p&gt;

&lt;p&gt;For more in-depth examples see
&lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/coretest/src/test/scala/molecule&#34;&gt;core tests&lt;/a&gt;
or
&lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/examples/src/test/scala/molecule/examples&#34;&gt;examples&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema&#34;&gt;Schema&lt;/a&gt; - Overview of schema creation

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/files&#34;&gt;Files&lt;/a&gt; - Schema file organization&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/definition&#34;&gt;Definition&lt;/a&gt; - Schema definition types and options&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/modelling&#34;&gt;Modelling&lt;/a&gt; - Some modelling advice&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/boilerplate&#34;&gt;Boilerplate&lt;/a&gt; - Boilerplate generated from schema&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/datomic-schema&#34;&gt;Datomic&lt;/a&gt; - Datomic schema transaction data generated&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/setup&#34;&gt;Setup&lt;/a&gt; - Before your first molecule&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/insert&#34;&gt;Insert&lt;/a&gt; - Data-molecule, Insert-molecule, Insert-molecule as template&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/update&#34;&gt;Update/retract&lt;/a&gt; - Updates/retraction/re-assertions explained&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query&#34;&gt;Query&lt;/a&gt; - Overview of basic query tools

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/builder&#34;&gt;Builder&lt;/a&gt; - Explict and tacet attribute values&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/types&#34;&gt;Types&lt;/a&gt; - Inferred types from all molecules&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/expressions&#34;&gt;Expressions&lt;/a&gt; - Equality, OR, Negation, Comparison, Fulltext search&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/aggregates&#34;&gt;Aggregates&lt;/a&gt; - Min, max, count, countDistinct, sum, avg, median, variance, stddev, random, sample&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/parameterize&#34;&gt;Parameterize&lt;/a&gt; - Cached Input-molecules for optimized queries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On our wish list (in no particular order):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Indexes&lt;/li&gt;
&lt;li&gt;Optimization&lt;/li&gt;
&lt;li&gt;Relationships&lt;/li&gt;
&lt;li&gt;FAQ&lt;/li&gt;
&lt;li&gt;Troubleshooting&lt;/li&gt;
&lt;li&gt;Graph

&lt;ul&gt;
&lt;li&gt;Traversal&lt;/li&gt;
&lt;li&gt;Hyperedges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Recursive queries&lt;/li&gt;
&lt;li&gt;Schema queries&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Builder</title>
      <link>http://scalamolecule.org/manual/query/builder/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/builder/</guid>
      <description>

&lt;h1 id=&#34;attribute-builder-pattern:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Attribute builder pattern&lt;/h1&gt;

&lt;p&gt;When we have defined a schema, Molecule generates the necessary boilerplate code so that we can build &amp;ldquo;molecular data structures&amp;rdquo; by building sequences of Attributes separated with dots (the &amp;ldquo;builder pattern&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;We could for instance build a molecule representing the data structure of Persons with name, age and gender Attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fundamental building blocks are Namespaces like &lt;code&gt;Person&lt;/code&gt; and Attributes like &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;gender&lt;/code&gt;. Namespaces are simply prefixes to Attribute names to avoid name clashes and to group our Attributes in meaningful ways according to our domain.&lt;/p&gt;

&lt;p&gt;As you see we start our molecule from some Namespace and then build on Attribute by Attribute.&lt;/p&gt;

&lt;h3 id=&#34;all-attributes-looked-for:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;All Attributes looked for&lt;/h3&gt;

&lt;p&gt;When we use a molecule to query the Datomic database we ask for entities having all our Attributes associated with them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that this is different from selecting rows from a sql table where you can also get null values back!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If for instance we have entities representing Persons in our data set that haven&amp;rsquo;t got any age Attribute associated with them then this query will &lt;em&gt;not&lt;/em&gt; return those entities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically we look for &lt;strong&gt;matches&lt;/strong&gt; to our molecule data structure.&lt;/p&gt;

&lt;h3 id=&#34;underscore-omits-values:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Underscore omits values&lt;/h3&gt;

&lt;p&gt;Sometimes we want to grap entities that we &lt;em&gt;know&lt;/em&gt; have certain attributes, but without returning those values. If for instance we wanted to find all names of Persons that have an age attribute set but we don&amp;rsquo;t need to return those age values, then we can add an underscore &lt;code&gt;_&lt;/code&gt; after the &lt;code&gt;age&lt;/code&gt; Attribute so that it becomes &lt;code&gt;age_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val names = Person.name.age_.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will return names of person entities having both a name and age Attribute set. Note how the age values are no longer returned from the type signatures:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)] = Person.name.age.get
val names  : List[String]        = Person.name.age_.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way we can switch on and off individual attributes from the result set without affecting the data structures we look for.&lt;/p&gt;

&lt;h3 id=&#34;tuples-or-hlists-returned:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Tuples or HLists returned&lt;/h3&gt;

&lt;p&gt;Molecule returns all result sets as either tuples of values (with &lt;code&gt;get&lt;/code&gt;) or Shapeless HLists (with &lt;code&gt;hl&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)]         = Person.name.age.get
val persons: List[String :: Int :: HNil] = Person.name.age.hl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;molecule-max-size:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Molecule max size&lt;/h3&gt;

&lt;p&gt;The size of molecules are limited to Scala&amp;rsquo;s limit size of 22 for tuples. Since molecules only look for attributes having a value it seems unlikely that we need to surpass this upper limit except in very special cases.&lt;/p&gt;

&lt;p&gt;Once the entities matching our qriteria are found we can use those entities to find additional optional attribute values.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Files</title>
      <link>http://scalamolecule.org/manual/schema/files/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/files/</guid>
      <description>

&lt;h1 id=&#34;molecule-files:fdd0f32a8956014c694267605f409cb7&#34;&gt;Molecule files&lt;/h1&gt;

&lt;p&gt;Your Molecule schema definition file should be in a folder named &amp;ldquo;schema&amp;rdquo; anywhere within your source code:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/definition-file.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;telling-sbt:fdd0f32a8956014c694267605f409cb7&#34;&gt;Telling sbt&lt;/h3&gt;

&lt;p&gt;In the project build file we then tell sbt where such &amp;ldquo;schema&amp;rdquo; folders reside:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;settings = commonSettings ++ Seq(
  definitionDirectories(
    &amp;quot;examples/src/main/scala/molecule/examples/dayOfDatomic&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/mbrainz&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/seattle&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add several locations with the &lt;code&gt;definitionDirectories&lt;/code&gt; method which will tell sbt where to look for our schema definition files.&lt;/p&gt;

&lt;h3 id=&#34;files-generated:fdd0f32a8956014c694267605f409cb7&#34;&gt;Files generated&lt;/h3&gt;

&lt;p&gt;Running &lt;code&gt;sbt compile&lt;/code&gt; in your project root will then generate some source code files in the &lt;code&gt;src_managed&lt;/code&gt; directory (inside the target directory):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/generated-files.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;boilerplate-dsl-files:fdd0f32a8956014c694267605f409cb7&#34;&gt;Boilerplate dsl files&lt;/h3&gt;

&lt;p&gt;Molecule creates a &lt;code&gt;dsl&lt;/code&gt; folder having a subfolder - or &amp;ldquo;definition directory&amp;rdquo; - for each schema definition file (could be more than one).&lt;/p&gt;

&lt;p&gt;Within each definition directory we&amp;rsquo;ll find a file generated for each namespace defined (&lt;code&gt;Community.scala&lt;/code&gt; etc).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/boilerplate&#34;&gt;More on the boilerplate dsl files&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;schema-file:fdd0f32a8956014c694267605f409cb7&#34;&gt;Schema file&lt;/h3&gt;

&lt;p&gt;Molecule places the generated Datomic schema file &lt;code&gt;SeattleSchema&lt;/code&gt; in the same package as &lt;code&gt;SeattleDefinition&lt;/code&gt; so that they&amp;rsquo;ll turn up beside each other in our IDE package view:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/project-files.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/datomic&#34;&gt;More on the Datomic schema&amp;hellip;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Schema</title>
      <link>http://scalamolecule.org/manual/schema/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/</guid>
      <description>

&lt;h1 id=&#34;molecule-schema:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Molecule schema&lt;/h1&gt;

&lt;p&gt;A Molecule Schema defines what attributes you&amp;rsquo;ll have available to build molecules.&lt;/p&gt;

&lt;p&gt;Prepare your domain in 3 steps to use Molecule:&lt;/p&gt;

&lt;h3 id=&#34;1-define-schema:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;1. Define Schema&lt;/h3&gt;

&lt;p&gt;A schema defines what attributes you&amp;rsquo;ll have available to build molecules.&lt;/p&gt;

&lt;p&gt;Attributes having something in common are defined as fields in a namespace trait and we list all namespace traits in a Definition trait.&lt;/p&gt;

&lt;p&gt;Shortened example from the &lt;a href=&#34;http://docs.datomic.com/tutorial.html&#34;&gt;Datomic Seattle tutorial&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(3, 8)
trait SeattleDefinition {

  trait Community {
    val name         = oneString.fullTextSearch
    val url          = oneString
    val category     = manyString.fullTextSearch
    val orgtype      = oneEnum(&#39;community, &#39;commercial, &#39;nonprofit)
    val `type`       = oneEnum(&#39;email_list, &#39;twitter, &#39;facebook_page)
    val neighborhood = one[Neighborhood]
  }

  trait Neighborhood {
    val name     = oneString.fullTextSearch.uniqueIdentity
    val district = one[District]
  }

  trait District {
    val name   = oneString.fullTextSearch.uniqueIdentity
    val region = oneEnum(&#39;n, &#39;ne, &#39;e, &#39;se, &#39;s, &#39;sw, &#39;w, &#39;nw)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have a &lt;code&gt;Community&lt;/code&gt;, &lt;code&gt;Neighborhood&lt;/code&gt; and &lt;code&gt;District&lt;/code&gt; namespace each defining some attributes of various types.&lt;/p&gt;

&lt;p&gt;Model your own domain structures with similar schemas and save each definition in a file in a &amp;ldquo;schema&amp;rdquo; folder anywhere within your project.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-tell-sbt:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;2. Tell sbt&lt;/h3&gt;

&lt;p&gt;Tell sbt where to find your &amp;ldquo;schema&amp;rdquo; folders containing definition files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;settings = commonSettings ++ Seq(
  definitionDirectories(
    &amp;quot;examples/src/main/scala/molecule/examples/dayOfDatomic&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/seattle&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/mbrainz&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-compile-generate-boilerplate-code:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;3. Compile (generate boilerplate code)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sbt compile&lt;/code&gt; your project, wait for your domain-customized boilerplate code to be generated - and you&amp;rsquo;re ready to make intuitive molecule queries!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Definition</title>
      <link>http://scalamolecule.org/manual/schema/definition/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/definition/</guid>
      <description>

&lt;h1 id=&#34;define-molecule-schema:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Define Molecule Schema&lt;/h1&gt;

&lt;p&gt;Molecule provides an easy way to model your domain in a Molecule Schema.&lt;/p&gt;

&lt;p&gt;A simple dsl lets you define attributes of your domain by type, cardinality and options/values with as little ceremony as possible.&lt;/p&gt;

&lt;h3 id=&#34;schema-definition:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Schema definition&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(3, 8)
trait SeattleDefinition {

  trait Community {
    val name         = oneString.fullTextSearch
    val url          = oneString
    val category     = manyString.fullTextSearch
    val orgtype      = oneEnum(&#39;community, &#39;commercial, &#39;nonprofit)
    val `type`       = oneEnum(&#39;email_list, &#39;twitter, &#39;facebook_page)
    val neighborhood = one[Neighborhood]
  }

  trait Neighborhood {
    val name     = oneString.fullTextSearch.uniqueIdentity
    val district = one[District]
  }

  trait District {
    val name   = oneString.fullTextSearch.uniqueIdentity
    val region = oneEnum(&#39;n, &#39;ne, &#39;e, &#39;se, &#39;s, &#39;sw, &#39;w, &#39;nw)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the Seattle schema we define 3 namespaces with different kinds of attributes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oneString&lt;/code&gt;, &lt;code&gt;manyString&lt;/code&gt; etc defines cardinality and type of an attribute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oneEnum&lt;/code&gt;/&lt;code&gt;manyEnum&lt;/code&gt; defines enumerated values&lt;/li&gt;
&lt;li&gt;&lt;code&gt;one[&amp;lt;ReferencedNamespace&amp;gt;]&lt;/code&gt; defines a reference to another namespace&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;attribute-types:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Attribute types&lt;/h3&gt;

&lt;p&gt;We have the following types available:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one     Cardinality many
---------------     ----------------
oneString           manyString
oneInt              manyInt   
oneLong             manyLong    
oneFloat            manyFloat     
oneDouble           manyDouble      
oneBoolean          manyBoolean      
oneDate             manyDate    
oneUUID             manyUUID    
oneURI              manyURI   
oneEnum             manyEnum              
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Datomic also has types &lt;code&gt;BigInt&lt;/code&gt; and &lt;code&gt;Bytes&lt;/code&gt; and those could later be implemented in Molecule if there&amp;rsquo;s a need for those types.&lt;/p&gt;

&lt;p&gt;Cardinality-one attributes can have one value per entity.&lt;/p&gt;

&lt;p&gt;Cardinality-many attributes can have a &lt;em&gt;Set of unique values&lt;/em&gt; per entity. Often we choose instead to model many-values as a many-reference to some other namespace where we can define more.&lt;/p&gt;

&lt;h3 id=&#34;reference-types:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Reference types&lt;/h3&gt;

&lt;p&gt;References are also treated like attributes. It&amp;rsquo;s basically a reference to one or many entities. We define such relationship by supplying the referenced namespace as the type parameter to the &lt;code&gt;one&lt;/code&gt;/&lt;code&gt;many&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one         Cardinality many
---------------         ----------------
one[&amp;lt;Ref-namespace&amp;gt;]    many[&amp;lt;Ref-namespace&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above we saw a reference from Community to Neighborhood defined as &lt;code&gt;one[Neighborhood]&lt;/code&gt;. We would for instance likely define an Order/Order Line relationship in an Order namespace as &lt;code&gt;many[OrderLine]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;attribute-options:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Attribute options&lt;/h3&gt;

&lt;p&gt;Each attribute can also have some extra options:&lt;/p&gt;

&lt;p&gt;
&lt;table border=&#34;1&#34; cellpadding=&#34;5&#34; cellspacing=&#34;0&#34; style=&#34;background-color:#f5f5f5;&#34;&gt;
  &lt;tr&gt;
    &lt;th align=&#34;left&#34; valign=&#34;top&#34; scope=&#34;col&#34;&gt;Option&lt;/th&gt;
    &lt;th valign=&#34;top&#34; scope=&#34;col&#34;&gt;&lt;strong&gt;Indexes&lt;/strong&gt;&lt;/th&gt;
    &lt;th scope=&#34;col&#34;&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;doc&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Attribute description.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueValue&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a different entity id will fail.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueIdentity&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity and &amp;quot;upsert&amp;quot; is enabled.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a temporary entity id will cause all attributes associated with that temporary id to be merged with the entity already in the database.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;indexed&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generated index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;fullTextSearch&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generate eventually consistent fulltext search index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;isComponent&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Specifies that an attribute whose type is :db.type/ref refers to a subcomponent of the entity to which the attribute is applied.&lt;br&gt;
    &lt;em&gt;When you retract an entity with :db.fn/retractEntity, all subcomponents are also retracted. When you touch an entity, all its subcomponent entities are touched recursively.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;noHistory&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Whether past values of an attribute should not be retained.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/p&gt;

&lt;p&gt;Datomic indexes the values of all attributes having an option except for the &lt;code&gt;doc&lt;/code&gt; and &lt;code&gt;noHistory&lt;/code&gt; options.&lt;/p&gt;

&lt;p&gt;As you saw, we added &lt;code&gt;fulltextSearch&lt;/code&gt; and &lt;code&gt;uniqueIdentity&lt;/code&gt; to some of the attributes in the Seattle definition above. Molecule&amp;rsquo;s schema definition DSL let&amp;rsquo;s you only choose allowed options for any attribute type.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setup</title>
      <link>http://scalamolecule.org/manual/setup/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/setup/</guid>
      <description>

&lt;h1 id=&#34;database-setup:2cc0b07f42930e4520820be1fe66f913&#34;&gt;Database setup&lt;/h1&gt;

&lt;p&gt;To create a fresh in-memory Datomic database we simply pass an URI string to
&lt;code&gt;Peer.createDatabase&lt;/code&gt; (to be sure that this URI is not already populated we
first delete it):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val uri = &amp;quot;datomic:mem://seattle&amp;quot;
Peer.deleteDatabase(uri)
Peer.createDatabase(uri)
implicit val conn = Peer.connect(uri)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We save the returned Datomic Connection as an implicit value so that our
molecules can later issue queries against it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Types</title>
      <link>http://scalamolecule.org/manual/query/types/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/types/</guid>
      <description>

&lt;h1 id=&#34;attribute-types:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Attribute types&lt;/h1&gt;

&lt;p&gt;Molecule Attributes can have the following types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one     Cardinality many
---------------     ----------------
String              Set[String]
Int                 Set[Int]   
Long                Set[Long]    
Float               Set[Float]     
Double              Set[Double]      
Boolean             Set[Boolean]      
Date                Set[Date]    
UUID                Set[UUID]    
URI                 Set[URI]   
enum: String        enums: Set[String]              
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attribute are defined in your &lt;a href=&#34;http://scalamolecule.org/manual/schema/definition/&#34;&gt;schema&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;types-inferred:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Types inferred&lt;/h3&gt;

&lt;p&gt;Types are inferred so that you can determine the result signature of a molecule&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)] = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cardinality-one-many:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Cardinality one/many&lt;/h3&gt;

&lt;p&gt;Attributes defined as cardinality-many will return sets of values. A Person could for instance have a &lt;code&gt;hobbies&lt;/code&gt; cardinality-many Attribute defined and thus return sets of hobby values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val engaged: List[(String, Set[String])] = Person.name.hobbies.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enums:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Enums&lt;/h3&gt;

&lt;p&gt;Enum values are predefined values that an Attribute can have. They are defined in your schema. Cardinality one enums can have one enum value and cardinality many can have a set of unique enum values for each entity.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Expressions</title>
      <link>http://scalamolecule.org/manual/query/expressions/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/expressions/</guid>
      <description>

&lt;h1 id=&#34;expressions:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Expressions&lt;/h1&gt;

&lt;h3 id=&#34;equality:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Equality&lt;/h3&gt;

&lt;p&gt;We can apply values to Attributes in order to filter the data structures we are looking for. We could for instance look for names of female persons:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.apply(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or simply&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;or-logic:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;OR-logic&lt;/h3&gt;

&lt;p&gt;We can apply OR-logic to find a selection of alternatives&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(40 or 41 or 42)
// .. same as
Person.age(40, 41, 42)
// .. same as
Person.age(List(40, 41, 42))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;negation:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Negation&lt;/h3&gt;

&lt;p&gt;We can exclude a certain attribute value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.!=(42)
// or
Person.age.not(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With negations we can again apply multiple values as alternatives&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.!=(40 or 41 or 42)
Person.age.!=(40, 41, 42)
Person.age.!=(List(40, 41, 42))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;comparison:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Comparison&lt;/h3&gt;

&lt;p&gt;We can filer attribute values that satisfy comparison expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.&amp;lt;(42)
Person.age.&amp;gt;(42)
Person.age.&amp;lt;=(42)
Person.age.&amp;gt;=(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparison of all types are performed with java&amp;rsquo;s &lt;code&gt;compareTo&lt;/code&gt; method. Text strings can for instance also be sorted by a letter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.&amp;lt;(&amp;quot;C&amp;quot;).get(3) === List(
  &amp;quot;ArtsWest&amp;quot;, &amp;quot;All About South Park&amp;quot;, &amp;quot;Ballard Neighbor Connection&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fulltext-search:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Fulltext search&lt;/h3&gt;

&lt;p&gt;If we add the &lt;code&gt;fullTextSearch&lt;/code&gt; option to a String attribute definition Datomic will index the text strings saved so that we can do fulltext searches accross all values. We could for instance search for Community names containing the word &amp;ldquo;Town&amp;rdquo; in their name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.contains(&amp;quot;Town&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that only full words are considered, so &amp;ldquo;Tow&amp;rdquo; won&amp;rsquo;t match. Also the following common words are not considered:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;a&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;are&amp;quot;, &amp;quot;as&amp;quot;, &amp;quot;at&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;but&amp;quot;, &amp;quot;by&amp;quot;,
&amp;quot;for&amp;quot;, &amp;quot;if&amp;quot;, &amp;quot;in&amp;quot;, &amp;quot;into&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;it&amp;quot;,
&amp;quot;no&amp;quot;, &amp;quot;not&amp;quot;, &amp;quot;of&amp;quot;, &amp;quot;on&amp;quot;, &amp;quot;or&amp;quot;, &amp;quot;such&amp;quot;,
&amp;quot;that&amp;quot;, &amp;quot;the&amp;quot;, &amp;quot;their&amp;quot;, &amp;quot;then&amp;quot;, &amp;quot;there&amp;quot;, &amp;quot;these&amp;quot;,
&amp;quot;they&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;to&amp;quot;, &amp;quot;was&amp;quot;, &amp;quot;will&amp;quot;, &amp;quot;with&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;we-can-use-variables-too:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;We can use variables too&lt;/h3&gt;

&lt;p&gt;Even though Molecule introspects molecule constructions at compile time we can still use (runtime) variables for our expressions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val youngAge = 25
val goodAge = 42
Person.age(goodAge)
Person.age.&amp;gt;(goodAge)
Person.age.&amp;lt;=(goodAge)
Person.age.&amp;gt;=(goodAge)
Person.age.!=(goodAge)
Person.age.!=(youngAge or goodAge)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Technically, Molecule saves the TermName of the variable for later resolution at runtime so that we can freely use variables in our expressions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val ages = List(youngAge, goodAge)
Person.age(goodAge)
Person.age.&amp;gt;(goodAge)
Person.age.&amp;lt;=(goodAge)
Person.age.&amp;gt;=(goodAge)
Person.age.!=(goodAge)
Person.age.!=(youngAge or goodAge)
// etc...
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Insert</title>
      <link>http://scalamolecule.org/manual/insert/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/insert/</guid>
      <description>

&lt;h1 id=&#34;insert-data:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Insert data&lt;/h1&gt;

&lt;p&gt;We basically have 3 ways of entering data with Molecule:&lt;/p&gt;

&lt;h3 id=&#34;1-data-molecule:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;1. Data-molecule&lt;/h3&gt;

&lt;p&gt;We can insert data by populating a molecule with data by applying a value to each
attribute and then simply &lt;code&gt;add&lt;/code&gt; it. Molecule makes sure
that each attribute only accepts values of the expected type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.insert
  .name(&amp;quot;AAA&amp;quot;)
  .url(&amp;quot;myUrl&amp;quot;)
  .`type`(&amp;quot;twitter&amp;quot;)
  .orgtype(&amp;quot;personal&amp;quot;)
  .category(&amp;quot;my&amp;quot;, &amp;quot;favorites&amp;quot;) // many cardinality allows multiple values
  .Neighborhood.name(&amp;quot;myNeighborhood&amp;quot;)
  .District.name(&amp;quot;myDistrict&amp;quot;).region(&amp;quot;nw&amp;quot;).add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note also how we easily insert data across several namespaces in one go!&lt;/p&gt;

&lt;h3 id=&#34;2-insert-molecule:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;2. Insert-molecule&lt;/h3&gt;

&lt;p&gt;Normally we would insert bigger data sets that we have exported from
somewhere else. For this scenario we define a molecule where each
attribute defines what type of data we can receive in a list of data tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.url.`type`.orgtype.category
    .Neighborhood.name.District.name.region insert List(
  (&amp;quot;community1&amp;quot;, &amp;quot;url1&amp;quot;, &amp;quot;twitter&amp;quot;, &amp;quot;community&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName1&amp;quot;, &amp;quot;DistName1&amp;quot;, &amp;quot;e&amp;quot;),
  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;myspace&amp;quot;, &amp;quot;nonprofit&amp;quot;, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), 
    &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;nw&amp;quot;),
  (&amp;quot;community3&amp;quot;, &amp;quot;url3&amp;quot;, &amp;quot;website&amp;quot;, &amp;quot;personal&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName3&amp;quot;, &amp;quot;DistName3&amp;quot;, &amp;quot;w&amp;quot;),
  // etc..
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how we insert data accross namespaces here too.&lt;/p&gt;

&lt;h3 id=&#34;3-insert-molecule-as-template:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;3. Insert-molecule as template&lt;/h3&gt;

&lt;p&gt;We can assign an Insert-molecule to a variable in order to re-use it as a temple to insert data with various inputs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Define Insert-molecule
val insertPerson = Person.firstName.lastName.age.insert

// Re-use Insert-molecule by aplying different (type-inferred) data sets
insertPerson(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;, 33)
insertPerson(&amp;quot;Lisa&amp;quot;, &amp;quot;Tux&amp;quot;, 27)
// etc...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes it easy to insert similar data sets.&lt;/p&gt;

&lt;h3 id=&#34;missing-values-null-values:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Missing values (&amp;ldquo;Null values&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;We might have some &amp;ldquo;rows&amp;rdquo; (tuples) of imported data with a missing attribute
value. If for instance some row has no &lt;code&gt;orgtype&lt;/code&gt; value in the data set, we can
just use a &lt;code&gt;null&lt;/code&gt; placeholder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community4&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;blog&amp;quot;, null.asInstanceOf[String], Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName4&amp;quot;, &amp;quot;DistName4&amp;quot;, &amp;quot;ne&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(we need to type-cast it for the implicits to resolve correctly)&lt;/p&gt;

&lt;h4 id=&#34;difference-to-sql:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Difference to SQL&lt;/h4&gt;

&lt;p&gt;In an sql table we would have inserted a null value for such column. But with
Molecule/Datomic we just simply &lt;em&gt;don&amp;rsquo;t assert&lt;/em&gt; any &lt;code&gt;orgtype&lt;/code&gt; value for that
entity at all! In other words: there is no &lt;code&gt;orgtype&lt;/code&gt; fact to be saved.&lt;/p&gt;

&lt;h3 id=&#34;type-safety:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Type safety&lt;/h3&gt;

&lt;p&gt;In this example we have only inserted text strings. But all input is type
checked against the selected attributes of the molecule which makes the
insert operation type safe.&lt;/p&gt;

&lt;p&gt;We even infer the expected type so that our
IDE will bark if it finds for instance an Integer somewhere in our input data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;type2&amp;quot;, 42, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;DistReg2&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A data set having the value &lt;code&gt;42&lt;/code&gt; as a value for the &lt;code&gt;orgtype&lt;/code&gt; attribute
woudn&amp;rsquo;t compile and our IDE will infer that and warn us of an invalid data set.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Aggregates</title>
      <link>http://scalamolecule.org/manual/query/aggregates/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/aggregates/</guid>
      <description>

&lt;h1 id=&#34;aggregates:de7f9909aae9c5ac545867cc473806f6&#34;&gt;Aggregates&lt;/h1&gt;

&lt;p&gt;Datomic offers some built-in aggregate functions to aggregate attribute values.&lt;/p&gt;

&lt;h3 id=&#34;aggregates-returning-a-single-value:de7f9909aae9c5ac545867cc473806f6&#34;&gt;Aggregates returning a single value&lt;/h3&gt;

&lt;h4 id=&#34;min-max:de7f9909aae9c5ac545867cc473806f6&#34;&gt;min/max&lt;/h4&gt;

&lt;p&gt;In Molecule you simply apply the aggregate function name as a keyword to your attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(min) // lowest age
Person.age(max) // highest age
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Supports all types.&lt;/p&gt;

&lt;h4 id=&#34;count:de7f9909aae9c5ac545867cc473806f6&#34;&gt;count&lt;/h4&gt;

&lt;p&gt;Not to be confused with &lt;code&gt;sum&lt;/code&gt; in that &lt;code&gt;count&lt;/code&gt; counts the entities having attribute with some value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(count) // count of all persons with an age (not the sum of ages)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;countdistinct:de7f9909aae9c5ac545867cc473806f6&#34;&gt;countDistinct&lt;/h4&gt;

&lt;p&gt;Not to be confused with &lt;code&gt;sum&lt;/code&gt; in that &lt;code&gt;count&lt;/code&gt; counts the entities having attribute with some value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(countDistinct)  // count of unique ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sum:de7f9909aae9c5ac545867cc473806f6&#34;&gt;sum&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(sum) // sum of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;avg:de7f9909aae9c5ac545867cc473806f6&#34;&gt;avg&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(avg) // average of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;median:de7f9909aae9c5ac545867cc473806f6&#34;&gt;median&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(median) // median of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;variance:de7f9909aae9c5ac545867cc473806f6&#34;&gt;variance&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(variance) // variance of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;stddev:de7f9909aae9c5ac545867cc473806f6&#34;&gt;stddev&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(stddev) // standard deviation of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;aggregates-returning-collections-of-values:de7f9909aae9c5ac545867cc473806f6&#34;&gt;Aggregates returning collections of values&lt;/h3&gt;

&lt;h4 id=&#34;distinct:de7f9909aae9c5ac545867cc473806f6&#34;&gt;distinct&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(distinct) // distinct ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;min-n:de7f9909aae9c5ac545867cc473806f6&#34;&gt;min(n)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(min(3)) // 3 lowest ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;max-n:de7f9909aae9c5ac545867cc473806f6&#34;&gt;max(n)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(max(3)) // 3 highest ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;rand-n:de7f9909aae9c5ac545867cc473806f6&#34;&gt;rand(n)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(max(3)) // 3 random persons (with potential for duplicates!)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sample-n:de7f9909aae9c5ac545867cc473806f6&#34;&gt;sample(n)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(max(3)) // 3 sample persons (without duplicates!)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Update/retract</title>
      <link>http://scalamolecule.org/manual/update/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/update/</guid>
      <description>

&lt;h1 id=&#34;update-retract-data:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Update/retract data&lt;/h1&gt;

&lt;h3 id=&#34;update:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Update&lt;/h3&gt;

&lt;p&gt;An &amp;ldquo;update&amp;rdquo; is a two-step process in Datomic:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Retract old fact&lt;/li&gt;
&lt;li&gt;Assert new fact&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Datomic doesn&amp;rsquo;t overwrite data. &amp;ldquo;Retract&amp;rdquo; is a statement that says &amp;ldquo;this data is no longer current&amp;rdquo; which means that it won&amp;rsquo;t turn up when you query for it &lt;em&gt;as of now&lt;/em&gt;. If you query for it &lt;em&gt;as of before&lt;/em&gt; you will see it!&lt;/p&gt;

&lt;p&gt;Being able to see how data develops over time is a brillant core feature of Datomic. We don&amp;rsquo;t need to administrate cumbersome historial changes manually. It&amp;rsquo;s all built in to Datomic.&lt;/p&gt;

&lt;h3 id=&#34;entities-are-updated:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Entities are updated&lt;/h3&gt;

&lt;p&gt;We need an entity id to update data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Grap entity id of the Belltown community
val belltownId = Community.e.name_(&amp;quot;belltown&amp;quot;).one

// Update name of the Belltown entity
Community(belltownId).name(&amp;quot;Belltown 2&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule uses the belltown id to&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;find the current &lt;code&gt;name&lt;/code&gt; value (&amp;ldquo;Belltown&amp;rdquo;) and retract that value&lt;/li&gt;
&lt;li&gt;assert the new &lt;code&gt;name&lt;/code&gt; value &amp;ldquo;Belltown 2&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;cardinality-many-values:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Cardinality-many values&lt;/h3&gt;

&lt;h4 id=&#34;updating:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Updating&lt;/h4&gt;

&lt;p&gt;Cardinality-many attributes have sets of values so we need to specify which of those values we want to update:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Cardinality-many attribute value updated
Community(belltownId).category(&amp;quot;news&amp;quot; -&amp;gt; &amp;quot;Cool news&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we tell that the &amp;ldquo;news&amp;rdquo; value should change to &amp;ldquo;Cool news&amp;rdquo;. As before the old value is retracted and the new value asserted so that we can go back in time and see what the values were before our update.&lt;/p&gt;

&lt;p&gt;We can update several values in one go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category(
  &amp;quot;Cool news&amp;quot; -&amp;gt; &amp;quot;Super cool news&amp;quot;,
  &amp;quot;events&amp;quot; -&amp;gt; &amp;quot;Super cool events&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;adding:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Adding&lt;/h4&gt;

&lt;p&gt;To add a value to the set of values a cardinality-many attriute can have we &lt;code&gt;add&lt;/code&gt; the value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category.add(&amp;quot;extra category&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;removing:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Removing&lt;/h4&gt;

&lt;p&gt;We can remove a specific value from a set of values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category.remove(&amp;quot;extra category&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;retract-attribute-value-s:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Retract attribute value(s)&lt;/h3&gt;

&lt;p&gt;Applying nothing (empty parenthesises) finds and retract all values of an attribute&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).name().category().update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that all values of a cardinality many attribute are retracted this way.&lt;/p&gt;

&lt;h3 id=&#34;retract-whole-entities:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Retract whole entities&lt;/h3&gt;

&lt;p&gt;To delete a whole entity with all its attribute values we call &lt;code&gt;retract&lt;/code&gt; on an entity id&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;belltownId.retract
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simple as that.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parameterize</title>
      <link>http://scalamolecule.org/manual/query/parameterize/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/parameterize/</guid>
      <description>

&lt;h1 id=&#34;parameterized-input-molecules:913d405893862d6b41d1b084193fb4f6&#34;&gt;Parameterized Input-molecules&lt;/h1&gt;

&lt;p&gt;Basically we can parameterize any molecule. Instead of a value we apply the placeholder &lt;code&gt;?&lt;/code&gt; as a value. This signals to Molecule that we intend to supply a value later as input.&lt;/p&gt;

&lt;p&gt;By assigning parameterized &amp;ldquo;Input-molecules&amp;rdquo; to variables we can re-use those variables to query for similar data structures where only some data part varies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// 1 input parameter
val person = Person.name(?)

val john = person(&amp;quot;John&amp;quot;).one
val lisa = person(&amp;quot;Lisa&amp;quot;).one
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course more complex molecules would benefit even more from this approach.&lt;/p&gt;

&lt;h3 id=&#34;datomic-cache-and-optimization:913d405893862d6b41d1b084193fb4f6&#34;&gt;Datomic cache and optimization&lt;/h3&gt;

&lt;p&gt;Datomic will cache and optimize the queries from such Input-molecules. This gives us an additional reason to use them.&lt;/p&gt;

&lt;h3 id=&#34;parameterized-expressions:913d405893862d6b41d1b084193fb4f6&#34;&gt;Parameterized expressions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val personName = Person.name.())?
val johnOrLisas = personName(&amp;quot;John&amp;quot; or &amp;quot;Lisa&amp;quot;).get // OR
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;multiple-parameters:913d405893862d6b41d1b084193fb4f6&#34;&gt;Multiple parameters&lt;/h3&gt;

&lt;p&gt;Molecules can have up to 3 &lt;code&gt;?&lt;/code&gt; placeholder parameters. Since we can apply expressions and logic to them it seems likely that this will satisfy the majority of all parameterized queires.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val person      = Person.name(?).age(?)
val john        = person(&amp;quot;John&amp;quot; and 42).one // AND
val johnOrJonas = person((&amp;quot;John&amp;quot; and 42) or (&amp;quot;Jonas&amp;quot; and 38)).get // AND/OR
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mix-parameterized-and-static-expressions:913d405893862d6b41d1b084193fb4f6&#34;&gt;Mix parameterized and static expressions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val americansYoungerThan = Person.name.age.&amp;lt;(?).Country.name(&amp;quot;USA&amp;quot;)
val americanKids = americansYoungerThan(13).get
val americanBabies = americansYoungerThan(1).get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more examples, please see the &lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/seattle/SeattleTests.scala#L141&#34;&gt;Seattle examples&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Query</title>
      <link>http://scalamolecule.org/manual/query/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/</guid>
      <description>

&lt;h1 id=&#34;molecule-queries:f7a7255cb61c59dcad3a015980d2faca&#34;&gt;Molecule Queries&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/builder&#34;&gt;Build molecules&lt;/a&gt; with the builder pattern&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender  // require values
Person.name.age_.gender // require but omit values (&amp;quot;tacet values&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/types&#34;&gt;Types&lt;/a&gt; - all types inferred by IDE&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val name   : String      = Person.name.one
val age    : Int         = Person.age.one
val hobbies: Set[String] = Person.hobbies.one // cardinality-many
val gender : String      = Person.gender.one  // enum values
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/expressions&#34;&gt;Expressions&lt;/a&gt; - filter attribute values with expressions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(42)               // equal value
Person.age.!=(42)            // negate values
Person.age.&amp;lt;(42)             // compare values
Person.age.&amp;gt;(42)             // compare values
Person.age.&amp;lt;=(42)            // compare values
Person.age.&amp;gt;=(42)            // compare values
Person.name.contains(&amp;quot;John&amp;quot;) // fulltext search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/aggregates&#34;&gt;Aggregates&lt;/a&gt; - aggregate attribute values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(min) 
Person.age(max) 
// rand, sample, count, countDistinct, sum, avg, median, variance, stddev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/or-logic&#34;&gt;OR-logic&lt;/a&gt; - apply OR logic to collect alternative values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name(&amp;quot;John&amp;quot; or &amp;quot;Jonas&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/parameterize&#34;&gt;Parameterize&lt;/a&gt; - re-use molecules and let Datomic cache queries and optimize performance&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val person = Person.name(?).age(?)

// Re-use `person`
val Johan  = person(&amp;quot;John&amp;quot;, 33).one
val Lisa   = person(&amp;quot;Lisa&amp;quot;, 27).one
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/relationships&#34;&gt;Relationships&lt;/a&gt; - Connect namespaces with relationships&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.City.name.Country.name
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Relationships</title>
      <link>http://scalamolecule.org/manual/query/relationships/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/relationships/</guid>
      <description>

&lt;h1 id=&#34;relationships:c826c531212d0a54ebca2cc2d2da67b7&#34;&gt;Relationships&lt;/h1&gt;

&lt;p&gt;Relationships are modelled in Molecule as &amp;ldquo;references between namespaces&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not that namespaces automatically become entities referencing each other but rather that referenced entities will likely pick attributes from a certain namespace.&lt;/p&gt;

&lt;h3 id=&#34;one-to-one:c826c531212d0a54ebca2cc2d2da67b7&#34;&gt;One-to-One&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;Person&lt;/code&gt; could have a cardinality-one reference to &lt;code&gt;City&lt;/code&gt; having a cardinality-one reference to a &lt;code&gt;Country&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.City.name.Country.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Strictly speaking we have an entity with an asserted &lt;code&gt;:person/name&lt;/code&gt; attribute value with a reference to another entity with an asserted &lt;code&gt;:city/name&lt;/code&gt; attribute value etc. But in practice we simply talk about &amp;ldquo;namespace A has a relationship/reference to namespace B&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A namespace is not like an SQL Table but rather organizes some attributes by a meaningful name - it&amp;rsquo;s, well, a &lt;em&gt;namespace&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;one-to-many:c826c531212d0a54ebca2cc2d2da67b7&#34;&gt;One-to-Many&lt;/h3&gt;

&lt;p&gt;If we have an &lt;code&gt;Order&lt;/code&gt; with multiple &lt;code&gt;OrderLine&lt;/code&gt;s we would instead define a cardinality-many reference to the &lt;code&gt;OrderLine&lt;/code&gt; namespace in our Schema definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val orderLines = many[OrderLine]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would cause Molecule to generate boilerplate code that would allow us to for instance insert multiple products for an order in one go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m(Order.id.LineItems * LineItem.product.price.quantity).insert(
  &amp;quot;order1&amp;quot;, List((chocolateId, 48.00, 1), (whiskyId, 38.00, 2))
)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Modelling</title>
      <link>http://scalamolecule.org/manual/schema/modelling/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/modelling/</guid>
      <description>

&lt;h1 id=&#34;modelling:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Modelling&lt;/h1&gt;

&lt;p&gt;A Datomic &lt;code&gt;schema&lt;/code&gt; defines the set of &lt;code&gt;attributes&lt;/code&gt; you can assign to &lt;code&gt;entities&lt;/code&gt;.
We organize &lt;code&gt;attributes&lt;/code&gt; in &lt;code&gt;namespaces&lt;/code&gt; to group related qualities:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/DatomicElements1.png&#34; alt=&#34;Schema&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This makes it easier to overview our domain data structures.&lt;/p&gt;

&lt;h4 id=&#34;namespace-table:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Namespace != Table&lt;/h4&gt;

&lt;p&gt;If coming from an sql background one might at first think of a namespace as
a table having columns (attributes). But this is not the case. An
entity in Datomic can associate values of attributes &lt;em&gt;from any namespace&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/DatomicElements2.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This gives us great freedom to model our domain with more &amp;ldquo;loose&amp;rdquo; namespaces rather than &amp;ldquo;hardcoded things&amp;rdquo; as table definitions. Later we can compose entities grabbing specific attributes from various namespaces as needed.&lt;/p&gt;

&lt;h3 id=&#34;relating-namespaces:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Relating namespaces&lt;/h3&gt;

&lt;p&gt;If we recall the Seattle domain then we have some attributes organized in 3
related namespaces:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/DatomicElements3.png&#34; alt=&#34;Seattle Model&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Community.type&lt;/code&gt;, &lt;code&gt;Community.orgtype&lt;/code&gt; and &lt;code&gt;District.region&lt;/code&gt; all have fixed
enumerated values to choose from. And &lt;code&gt;Community.category&lt;/code&gt; is the only
many-cardinality attribute allowed to have multiple values.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>