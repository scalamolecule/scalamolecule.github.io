<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Manuals on Molecule</title>
    <link>http://scalamolecule.org/manual/</link>
    <description>Recent content in Manuals on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Fri, 02 Jan 2015 22:06:44 CET</lastBuildDate>
    <atom:link href="http://scalamolecule.org/manual/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Manual</title>
      <link>http://scalamolecule.org/manual/overview/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/overview/</guid>
      <description>

&lt;h1 id=&#34;molecule-manual:68f80267fa3a50980dbb745a782b8dca&#34;&gt;Molecule manual&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Introduction&lt;/li&gt;
&lt;li&gt;Setup&lt;/li&gt;
&lt;li&gt;Model&lt;/li&gt;
&lt;li&gt;Schema

&lt;ul&gt;
&lt;li&gt;Definition&lt;/li&gt;
&lt;li&gt;Types&lt;/li&gt;
&lt;li&gt;Options&lt;/li&gt;
&lt;li&gt;Enum values&lt;/li&gt;
&lt;li&gt;Modelling trategies&lt;/li&gt;
&lt;li&gt;Queries&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Indexes&lt;/li&gt;
&lt;li&gt;Optimization&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reference?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;FAQ&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Troubleshooting&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Overview&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Datomic&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Seattle&lt;/li&gt;
&lt;li&gt;Whirlwind of Datomic&lt;/li&gt;
&lt;li&gt;Day of Datomic&lt;/li&gt;
&lt;li&gt;MBrainz&lt;/li&gt;
&lt;li&gt;nuBank&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Web&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entity ids&lt;/li&gt;
&lt;li&gt;Authorization&lt;/li&gt;
&lt;li&gt;REST?&lt;/li&gt;
&lt;li&gt;Pagination&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Graph&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Traversal&lt;/li&gt;
&lt;li&gt;Hyperedges&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Relationships&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Aggregates&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursive queries (practical uses)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Schema queries (practical uses)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Builder</title>
      <link>http://scalamolecule.org/manual/query/builder/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/builder/</guid>
      <description>

&lt;h1 id=&#34;attribute-builder-pattern:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Attribute builder pattern&lt;/h1&gt;

&lt;p&gt;When we have defined a schema, Molecule generates the necessary boilerplate code so that we can build &amp;ldquo;molecular data structures&amp;rdquo; by building sequences of Attributes separated with dots (the &amp;ldquo;builder pattern&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;We could for instance build a molecule representing the data structure of Persons with name, age and gender Attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fundamental building blocks are Namespaces like &lt;code&gt;Person&lt;/code&gt; and Attributes like &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;gender&lt;/code&gt;. Namespaces are simply prefixes to Attribute names to avoid name clashes and to group our Attributes in meaningful ways according to our domain.&lt;/p&gt;

&lt;p&gt;As you see we start our molecule from some Namespace and then build on Attribute by Attribute.&lt;/p&gt;

&lt;h3 id=&#34;all-attributes-looked-for:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;All Attributes looked for&lt;/h3&gt;

&lt;p&gt;When we use a molecule to query the Datomic database we ask for entities having all our Attributes associated with them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that this is different from selecting rows from a sql table where you can also get null values back!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If for instance we have entities representing Persons in our data set that haven&amp;rsquo;t got any age Attribute associated with them then this query will &lt;em&gt;not&lt;/em&gt; return those entities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically we look for &lt;strong&gt;matches&lt;/strong&gt; to our molecule data structure.&lt;/p&gt;

&lt;h3 id=&#34;underscore-omits-values:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Underscore omits values&lt;/h3&gt;

&lt;p&gt;Sometimes we want to grap entities that we &lt;em&gt;know&lt;/em&gt; have certain attributes, but without returning those values. If for instance we wanted to find all names of Persons that have an age attribute set but we don&amp;rsquo;t need to return those age values, then we can add an underscore &lt;code&gt;_&lt;/code&gt; after the &lt;code&gt;age&lt;/code&gt; Attribute so that it becomes &lt;code&gt;age_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val names = Person.name.age_.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will return names of person entities having both a name and age Attribute set. Note how the age values are no longer returned from the type signatures:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)] = Person.name.age.get
val names  : List[String]        = Person.name.age_.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way we can switch on and off individual attributes from the result set without affecting the data structures we look for.&lt;/p&gt;

&lt;h3 id=&#34;tuples-or-hlists-returned:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Tuples or HLists returned&lt;/h3&gt;

&lt;p&gt;Molecule returns all result sets as either tuples of values (with &lt;code&gt;get&lt;/code&gt;) or Shapeless HLists (with &lt;code&gt;hl&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)]         = Person.name.age.get
val persons: List[String :: Int :: HNil] = Person.name.age.hl
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;molecule-max-size:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Molecule max size&lt;/h3&gt;

&lt;p&gt;The size of molecules are limited to Scala&amp;rsquo;s limit size of 22 for tuples. Since molecules only look for attributes having a value it seems unlikely that we need to surpass this upper limit except in very special cases.&lt;/p&gt;

&lt;p&gt;Once the entities matching our qriteria are found we can use those entities to find additional optional attribute values.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Files</title>
      <link>http://scalamolecule.org/manual/schema/files/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/files/</guid>
      <description>

&lt;h1 id=&#34;molecule-files:fdd0f32a8956014c694267605f409cb7&#34;&gt;Molecule files&lt;/h1&gt;

&lt;p&gt;Your Molecule schema definition file should be in a folder named &amp;ldquo;schema&amp;rdquo; anywhere within your source code:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/definition-file.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;telling-sbt:fdd0f32a8956014c694267605f409cb7&#34;&gt;Telling sbt&lt;/h3&gt;

&lt;p&gt;In the project build file we then tell sbt where such &amp;ldquo;schema&amp;rdquo; folders reside:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;settings = commonSettings ++ Seq(
  definitionDirectories(
    &amp;quot;examples/src/main/scala/molecule/examples/dayOfDatomic&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/mbrainz&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/seattle&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can add several locations with the &lt;code&gt;definitionDirectories&lt;/code&gt; method which will tell sbt where to look for our schema definition files.&lt;/p&gt;

&lt;h3 id=&#34;files-generated:fdd0f32a8956014c694267605f409cb7&#34;&gt;Files generated&lt;/h3&gt;

&lt;p&gt;Running &lt;code&gt;sbt compile&lt;/code&gt; in your project root will then generate some source code files in the &lt;code&gt;src_managed&lt;/code&gt; directory (inside the target directory):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/generated-files.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h3 id=&#34;boilerplate-dsl-files:fdd0f32a8956014c694267605f409cb7&#34;&gt;Boilerplate dsl files&lt;/h3&gt;

&lt;p&gt;Molecule creates a &lt;code&gt;dsl&lt;/code&gt; folder having a subfolder - or &amp;ldquo;definition directory&amp;rdquo; - for each schema definition file (could be more than one).&lt;/p&gt;

&lt;p&gt;Within each definition directory we&amp;rsquo;ll find a file generated for each namespace defined (&lt;code&gt;Community.scala&lt;/code&gt; etc).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/boilerplate&#34;&gt;More on the boilerplate dsl files&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;schema-file:fdd0f32a8956014c694267605f409cb7&#34;&gt;Schema file&lt;/h3&gt;

&lt;p&gt;Molecule places the generated Datomic schema file &lt;code&gt;SeattleSchema&lt;/code&gt; in the same package as &lt;code&gt;SeattleDefinition&lt;/code&gt; so that they&amp;rsquo;ll turn up beside each other in our IDE package view:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/boilerplate/project-files.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/schema/datomic&#34;&gt;More on the Datomic schema&amp;hellip;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Schema</title>
      <link>http://scalamolecule.org/manual/schema/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/</guid>
      <description>

&lt;h1 id=&#34;molecule-schema:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Molecule schema&lt;/h1&gt;

&lt;p&gt;A Molecule Schema defines what attributes you&amp;rsquo;ll have available to build molecules.&lt;/p&gt;

&lt;p&gt;Prepare your domain in 3 steps to use Molecule:&lt;/p&gt;

&lt;h3 id=&#34;1-define-schema:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;1. Define Schema&lt;/h3&gt;

&lt;p&gt;A schema defines what attributes you&amp;rsquo;ll have available to build molecules.&lt;/p&gt;

&lt;p&gt;Attributes having something in common are defined as fields in a namespace trait and we list all namespace traits in a Definition trait.&lt;/p&gt;

&lt;p&gt;Shortened example from the &lt;a href=&#34;http://docs.datomic.com/tutorial.html&#34;&gt;Datomic Seattle tutorial&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(3, 8)
trait SeattleDefinition {

  trait Community {
    val name         = oneString.fullTextSearch
    val url          = oneString
    val category     = manyString.fullTextSearch
    val orgtype      = oneEnum(&#39;community, &#39;commercial, &#39;nonprofit)
    val `type`       = oneEnum(&#39;email_list, &#39;twitter, &#39;facebook_page)
    val neighborhood = one[Neighborhood]
  }

  trait Neighborhood {
    val name     = oneString.fullTextSearch.uniqueIdentity
    val district = one[District]
  }

  trait District {
    val name   = oneString.fullTextSearch.uniqueIdentity
    val region = oneEnum(&#39;n, &#39;ne, &#39;e, &#39;se, &#39;s, &#39;sw, &#39;w, &#39;nw)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have a &lt;code&gt;Community&lt;/code&gt;, &lt;code&gt;Neighborhood&lt;/code&gt; and &lt;code&gt;District&lt;/code&gt; namespace each defining some attributes of various types.&lt;/p&gt;

&lt;p&gt;Model your own domain structures with similar schemas and save each definition in a file in a &amp;ldquo;schema&amp;rdquo; folder anywhere within your project.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-tell-sbt:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;2. Tell sbt&lt;/h3&gt;

&lt;p&gt;Tell sbt where to find your &amp;ldquo;schema&amp;rdquo; folders containing definition files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;settings = commonSettings ++ Seq(
  definitionDirectories(
    &amp;quot;examples/src/main/scala/molecule/examples/dayOfDatomic&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/seattle&amp;quot;,
    &amp;quot;examples/src/main/scala/molecule/examples/mbrainz&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-compile-generate-boilerplate-code:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;3. Compile (generate boilerplate code)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;sbt compile&lt;/code&gt; your project, wait for your domain-customized boilerplate code to be generated - and you&amp;rsquo;re ready to make intuitive molecule queries!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/&#34;&gt;Read more&amp;hellip;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Definition</title>
      <link>http://scalamolecule.org/manual/schema/definition/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/definition/</guid>
      <description>

&lt;h1 id=&#34;define-molecule-schema:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Define Molecule Schema&lt;/h1&gt;

&lt;p&gt;Molecule provides an easy way to model your domain in a Molecule Schema.&lt;/p&gt;

&lt;p&gt;A simple dsl lets you define attributes of your domain by type, cardinality and options/values with as little ceremony as possible.&lt;/p&gt;

&lt;h3 id=&#34;schema-definition:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Schema definition&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(3, 8)
trait SeattleDefinition {

  trait Community {
    val name         = oneString.fullTextSearch
    val url          = oneString
    val category     = manyString.fullTextSearch
    val orgtype      = oneEnum(&#39;community, &#39;commercial, &#39;nonprofit)
    val `type`       = oneEnum(&#39;email_list, &#39;twitter, &#39;facebook_page)
    val neighborhood = one[Neighborhood]
  }

  trait Neighborhood {
    val name     = oneString.fullTextSearch.uniqueIdentity
    val district = one[District]
  }

  trait District {
    val name   = oneString.fullTextSearch.uniqueIdentity
    val region = oneEnum(&#39;n, &#39;ne, &#39;e, &#39;se, &#39;s, &#39;sw, &#39;w, &#39;nw)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the Seattle schema we define 3 namespaces with different kinds of attributes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oneString&lt;/code&gt;, &lt;code&gt;manyString&lt;/code&gt; etc defines cardinality and type of an attribute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oneEnum&lt;/code&gt;/&lt;code&gt;manyEnum&lt;/code&gt; defines enumerated values&lt;/li&gt;
&lt;li&gt;&lt;code&gt;one[&amp;lt;ReferencedNamespace&amp;gt;]&lt;/code&gt; defines a reference to another namespace&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;attribute-types:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Attribute types&lt;/h3&gt;

&lt;p&gt;We have the following types available:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one     Cardinality many
---------------     ----------------
oneString           manyString
oneInt              manyInt   
oneLong             manyLong    
oneFloat            manyFloat     
oneDouble           manyDouble      
oneBoolean          manyBoolean      
oneDate             manyDate    
oneUUID             manyUUID    
oneURI              manyURI   
oneEnum             manyEnum              
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Datomic also has types &lt;code&gt;BigInt&lt;/code&gt; and &lt;code&gt;Bytes&lt;/code&gt; and those could later be implemented in Molecule if there&amp;rsquo;s a need for those types.&lt;/p&gt;

&lt;p&gt;Cardinality-one attributes can have one value per entity.&lt;/p&gt;

&lt;p&gt;Cardinality-many attributes can have a &lt;em&gt;Set of unique values&lt;/em&gt; per entity. Often we choose instead to model many-values as a many-reference to some other namespace where we can define more.&lt;/p&gt;

&lt;h3 id=&#34;reference-types:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Reference types&lt;/h3&gt;

&lt;p&gt;References are also treated like attributes. It&amp;rsquo;s basically a reference to one or many entities. We define such relationship by supplying the referenced namespace as the type parameter to the &lt;code&gt;one&lt;/code&gt;/&lt;code&gt;many&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one         Cardinality many
---------------         ----------------
one[&amp;lt;Ref-namespace&amp;gt;]    many[&amp;lt;Ref-namespace&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above we saw a reference from Community to Neighborhood defined as &lt;code&gt;one[Neighborhood]&lt;/code&gt;. We would for instance likely define an Order/Order Line relationship in an Order namespace as &lt;code&gt;many[OrderLine]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;attribute-options:eb6ae157f5199f108ae8e599fe0e98dc&#34;&gt;Attribute options&lt;/h3&gt;

&lt;p&gt;Each attribute can also have some extra options:&lt;/p&gt;

&lt;p&gt;
&lt;table border=&#34;1&#34; cellpadding=&#34;5&#34; cellspacing=&#34;0&#34; style=&#34;background-color:#f5f5f5;&#34;&gt;
  &lt;tr&gt;
    &lt;th align=&#34;left&#34; valign=&#34;top&#34; scope=&#34;col&#34;&gt;Option&lt;/th&gt;
    &lt;th valign=&#34;top&#34; scope=&#34;col&#34;&gt;&lt;strong&gt;Indexes&lt;/strong&gt;&lt;/th&gt;
    &lt;th scope=&#34;col&#34;&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;doc&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Attribute description.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueValue&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a different entity id will fail.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueIdentity&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity and &amp;quot;upsert&amp;quot; is enabled.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a temporary entity id will cause all attributes associated with that temporary id to be merged with the entity already in the database.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;indexed&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generated index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;fullTextSearch&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generate eventually consistent fulltext search index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;isComponent&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Specifies that an attribute whose type is :db.type/ref refers to a subcomponent of the entity to which the attribute is applied.&lt;br&gt;
    &lt;em&gt;When you retract an entity with :db.fn/retractEntity, all subcomponents are also retracted. When you touch an entity, all its subcomponent entities are touched recursively.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;noHistory&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Whether past values of an attribute should not be retained.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/p&gt;

&lt;p&gt;Datomic indexes the values of all attributes having an option except for the &lt;code&gt;doc&lt;/code&gt; and &lt;code&gt;noHistory&lt;/code&gt; options.&lt;/p&gt;

&lt;p&gt;As you saw, we added &lt;code&gt;fulltextSearch&lt;/code&gt; and &lt;code&gt;uniqueIdentity&lt;/code&gt; to some of the attributes in the Seattle definition above. Molecule&amp;rsquo;s schema definition DSL let&amp;rsquo;s you only choose allowed options for any attribute type.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setup</title>
      <link>http://scalamolecule.org/manual/setup/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/setup/</guid>
      <description>

&lt;h1 id=&#34;database-setup:2cc0b07f42930e4520820be1fe66f913&#34;&gt;Database setup&lt;/h1&gt;

&lt;p&gt;To create a fresh in-memory Datomic database we simply pass an URI string to
&lt;code&gt;Peer.createDatabase&lt;/code&gt; (to be sure that this URI is not already populated we
first delete it):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val uri = &amp;quot;datomic:mem://seattle&amp;quot;
Peer.deleteDatabase(uri)
Peer.createDatabase(uri)
implicit val conn = Peer.connect(uri)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We save the returned Datomic Connection as an implicit value so that our
molecules can later issue queries against it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Types</title>
      <link>http://scalamolecule.org/manual/query/types/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/types/</guid>
      <description>

&lt;h1 id=&#34;attribute-types:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Attribute types&lt;/h1&gt;

&lt;p&gt;Molecule Attributes can have the following types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one     Cardinality many
---------------     ----------------
String              Set[String]
Int                 Set[Int]   
Long                Set[Long]    
Float               Set[Float]     
Double              Set[Double]      
Boolean             Set[Boolean]      
Date                Set[Date]    
UUID                Set[UUID]    
URI                 Set[URI]   
enum: String        enums: Set[String]              
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attribute are defined in your &lt;a href=&#34;http://scalamolecule.org/manual/schema/definition/&#34;&gt;schema&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;types-inferred:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Types inferred&lt;/h3&gt;

&lt;p&gt;Types are inferred so that you can determine the result signature of a molecule&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: List[(String, Int)] = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cardinality-one-many:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Cardinality one/many&lt;/h3&gt;

&lt;p&gt;Attributes defined as cardinality-many will return sets of values. A Person could for instance have a &lt;code&gt;hobbies&lt;/code&gt; cardinality-many Attribute defined and thus return sets of hobby values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val engaged: List[(String, Set[String])] = Person.name.hobbies.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enums:3d59665407ad3f08f6bcaef4686926f7&#34;&gt;Enums&lt;/h3&gt;

&lt;p&gt;Enum values are predefined values that an Attribute can have. They are defined in your schema. Cardinality one enums can have one enum value and cardinality many can have a set of unique enum values for each entity.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Expressions</title>
      <link>http://scalamolecule.org/manual/query/expressions/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/expressions/</guid>
      <description>

&lt;h1 id=&#34;expressions:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Expressions&lt;/h1&gt;

&lt;p&gt;We can apply values to Attributes in order to filter the data structures we are looking for. We could for instance look for names of female persons:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.gender.apply(&amp;quot;female&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or simply&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.gender(&amp;quot;female&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;omit-applied-value:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Omit applied value&lt;/h3&gt;

&lt;p&gt;Instead of returning the gender value &amp;ldquo;female&amp;rdquo; for all entities returned we could add an underscore to only return the names of female persones:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val females: List[String] = Person.name.gender_(&amp;quot;female&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inferred-types:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Inferred types&lt;/h3&gt;

&lt;p&gt;Only applied values matching the Attribute type can compile. And we can even infer the type in our IDE so that we will get warned if we try to apply a non-matchig type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// types match
Person.name(&amp;quot;John&amp;quot;).age(42)

// won&#39;t compile
// IDE will bark: 42(Int) is not of type String
Person.name(42)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Insert</title>
      <link>http://scalamolecule.org/manual/insert/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/insert/</guid>
      <description>

&lt;h1 id=&#34;insert-data:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Insert data&lt;/h1&gt;

&lt;p&gt;We basically have 3 ways of entering data with Molecule:&lt;/p&gt;

&lt;h3 id=&#34;1-data-molecule:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;1. Data-molecule&lt;/h3&gt;

&lt;p&gt;We can insert data by populating a molecule with data by applying a value to each
attribute and then simply &lt;code&gt;add&lt;/code&gt; it. Molecule makes sure
that each attribute only accepts values of the expected type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.insert
  .name(&amp;quot;AAA&amp;quot;)
  .url(&amp;quot;myUrl&amp;quot;)
  .`type`(&amp;quot;twitter&amp;quot;)
  .orgtype(&amp;quot;personal&amp;quot;)
  .category(&amp;quot;my&amp;quot;, &amp;quot;favorites&amp;quot;) // many cardinality allows multiple values
  .Neighborhood.name(&amp;quot;myNeighborhood&amp;quot;)
  .District.name(&amp;quot;myDistrict&amp;quot;).region(&amp;quot;nw&amp;quot;).add
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note also how we easily insert data across several namespaces in one go!&lt;/p&gt;

&lt;h3 id=&#34;2-insert-molecule:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;2. Insert-molecule&lt;/h3&gt;

&lt;p&gt;Normally we would insert bigger data sets that we have exported from
somewhere else. For this scenario we define a molecule where each
attribute defines what type of data we can receive in a list of data tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.url.`type`.orgtype.category
    .Neighborhood.name.District.name.region insert List(
  (&amp;quot;community1&amp;quot;, &amp;quot;url1&amp;quot;, &amp;quot;twitter&amp;quot;, &amp;quot;community&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName1&amp;quot;, &amp;quot;DistName1&amp;quot;, &amp;quot;e&amp;quot;),
  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;myspace&amp;quot;, &amp;quot;nonprofit&amp;quot;, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), 
    &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;nw&amp;quot;),
  (&amp;quot;community3&amp;quot;, &amp;quot;url3&amp;quot;, &amp;quot;website&amp;quot;, &amp;quot;personal&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName3&amp;quot;, &amp;quot;DistName3&amp;quot;, &amp;quot;w&amp;quot;),
  // etc..
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how we insert data accross namespaces here too.&lt;/p&gt;

&lt;h3 id=&#34;3-insert-molecule-as-template:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;3. Insert-molecule as template&lt;/h3&gt;

&lt;p&gt;We can assign an Insert-molecule to a variable in order to re-use it as a temple to insert data with various inputs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Define Insert-molecule
val insertPerson = Person.firstName.lastName.age.insert

// Re-use Insert-molecule by aplying different (type-inferred) data sets
insertPerson(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;, 33)
insertPerson(&amp;quot;Lisa&amp;quot;, &amp;quot;Tux&amp;quot;, 27)
// etc...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes it easy to insert similar data sets.&lt;/p&gt;

&lt;h3 id=&#34;missing-values-null-values:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Missing values (&amp;ldquo;Null values&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;We might have some &amp;ldquo;rows&amp;rdquo; (tuples) of imported data with a missing attribute
value. If for instance some row has no &lt;code&gt;orgtype&lt;/code&gt; value in the data set, we can
just use a &lt;code&gt;null&lt;/code&gt; placeholder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community4&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;blog&amp;quot;, null.asInstanceOf[String], Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName4&amp;quot;, &amp;quot;DistName4&amp;quot;, &amp;quot;ne&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(we need to type-cast it for the implicits to resolve correctly)&lt;/p&gt;

&lt;h4 id=&#34;difference-to-sql:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Difference to SQL&lt;/h4&gt;

&lt;p&gt;In an sql table we would have inserted a null value for such column. But with
Molecule/Datomic we just simply &lt;em&gt;don&amp;rsquo;t assert&lt;/em&gt; any &lt;code&gt;orgtype&lt;/code&gt; value for that
entity at all! In other words: there is no &lt;code&gt;orgtype&lt;/code&gt; fact to be saved.&lt;/p&gt;

&lt;h3 id=&#34;type-safety:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Type safety&lt;/h3&gt;

&lt;p&gt;In this example we have only inserted text strings. But all input is type
checked against the selected attributes of the molecule which makes the
insert operation type safe.&lt;/p&gt;

&lt;p&gt;We even infer the expected type so that our
IDE will bark if it finds for instance an Integer somewhere in our input data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;type2&amp;quot;, 42, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;DistReg2&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A data set having the value &lt;code&gt;42&lt;/code&gt; as a value for the &lt;code&gt;orgtype&lt;/code&gt; attribute
woudn&amp;rsquo;t compile and our IDE will infer that and warn us of an invalid data set.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Aggregates</title>
      <link>http://scalamolecule.org/manual/query/aggregates/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/aggregates/</guid>
      <description>

&lt;h1 id=&#34;aggregates:de7f9909aae9c5ac545867cc473806f6&#34;&gt;Aggregates&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Update/retract</title>
      <link>http://scalamolecule.org/manual/update/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/update/</guid>
      <description>

&lt;h1 id=&#34;update-retract-data:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Update/retract data&lt;/h1&gt;

&lt;h3 id=&#34;update:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Update&lt;/h3&gt;

&lt;p&gt;An &amp;ldquo;update&amp;rdquo; is a two-step process in Datomic:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Retract old fact&lt;/li&gt;
&lt;li&gt;Assert new fact&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Datomic doesn&amp;rsquo;t overwrite data. &amp;ldquo;Retract&amp;rdquo; is a statement that says &amp;ldquo;this data is no longer current&amp;rdquo; which means that it won&amp;rsquo;t turn up when you query for it &lt;em&gt;as of now&lt;/em&gt;. If you query for it &lt;em&gt;as of before&lt;/em&gt; you will see it!&lt;/p&gt;

&lt;p&gt;Being able to see how data develops over time is a brillant core feature of Datomic. We don&amp;rsquo;t need to administrate cumbersome historial changes manually. It&amp;rsquo;s all built in to Datomic.&lt;/p&gt;

&lt;h3 id=&#34;entities-are-updated:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Entities are updated&lt;/h3&gt;

&lt;p&gt;We need an entity id to update data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Grap entity id of the Belltown community
val belltownId = Community.e.name_(&amp;quot;belltown&amp;quot;).one

// Update name of the Belltown entity
Community(belltownId).name(&amp;quot;Belltown 2&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule uses the belltown id to&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;find the current &lt;code&gt;name&lt;/code&gt; value (&amp;ldquo;Belltown&amp;rdquo;) and retract that value&lt;/li&gt;
&lt;li&gt;assert the new &lt;code&gt;name&lt;/code&gt; value &amp;ldquo;Belltown 2&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;cardinality-many-values:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Cardinality-many values&lt;/h3&gt;

&lt;h4 id=&#34;updating:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Updating&lt;/h4&gt;

&lt;p&gt;Cardinality-many attributes have sets of values so we need to specify which of those values we want to update:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Cardinality-many attribute value updated
Community(belltownId).category(&amp;quot;news&amp;quot; -&amp;gt; &amp;quot;Cool news&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we tell that the &amp;ldquo;news&amp;rdquo; value should change to &amp;ldquo;Cool news&amp;rdquo;. As before the old value is retracted and the new value asserted so that we can go back in time and see what the values were before our update.&lt;/p&gt;

&lt;p&gt;We can update several values in one go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category(
  &amp;quot;Cool news&amp;quot; -&amp;gt; &amp;quot;Super cool news&amp;quot;,
  &amp;quot;events&amp;quot; -&amp;gt; &amp;quot;Super cool events&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;adding:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Adding&lt;/h4&gt;

&lt;p&gt;To add a value to the set of values a cardinality-many attriute can have we &lt;code&gt;add&lt;/code&gt; the value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category.add(&amp;quot;extra category&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;removing:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Removing&lt;/h4&gt;

&lt;p&gt;We can remove a specific value from a set of values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category.remove(&amp;quot;extra category&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;retract-attribute-value-s:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Retract attribute value(s)&lt;/h3&gt;

&lt;p&gt;Applying nothing (empty parenthesises) finds and retract all values of an attribute&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).name().category().update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that all values of a cardinality many attribute are retracted this way.&lt;/p&gt;

&lt;h3 id=&#34;retract-whole-entities:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Retract whole entities&lt;/h3&gt;

&lt;p&gt;To delete a whole entity with all its attribute values we call &lt;code&gt;retract&lt;/code&gt; on an entity id&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;belltownId.retract
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simple as that.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OR-logic</title>
      <link>http://scalamolecule.org/manual/query/or-logic/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/or-logic/</guid>
      <description>

&lt;h1 id=&#34;or-logic:04d91c3eed2ce47f783de21cf8c28a71&#34;&gt;OR-logic&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age_.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;tuples/hlist - limit of 22&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Parameterize</title>
      <link>http://scalamolecule.org/manual/query/parameterize/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/parameterize/</guid>
      <description>

&lt;h1 id=&#34;parameterize-attributes:913d405893862d6b41d1b084193fb4f6&#34;&gt;Parameterize Attributes&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// 1 input parameter
val personName  = Person.name(?)
val johnOrLisas = personName(&amp;quot;John&amp;quot; or &amp;quot;Lisa&amp;quot;) // OR

// more input parameters
val person      = Person.name(?).age(?)
val john        = person(&amp;quot;John&amp;quot; and 42) // AND
val johnOrJonas = person((&amp;quot;John&amp;quot; and 42) or (&amp;quot;Jonas&amp;quot; and 38)) // AND/OR
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age_.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;tuples/hlist - limit of 22&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Query</title>
      <link>http://scalamolecule.org/manual/query/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/query/</guid>
      <description>

&lt;h1 id=&#34;molecule-queries:f7a7255cb61c59dcad3a015980d2faca&#34;&gt;Molecule Queries&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/builder&#34;&gt;Build molecules&lt;/a&gt; with the builder pattern&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender  // require values
Person.name.age_.gender // require but omit values (&amp;quot;tacet values&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/types&#34;&gt;Types&lt;/a&gt; - all types inferred by IDE&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val name   : String      = Person.name.one
val age    : Int         = Person.age.one
val hobbies: Set[String] = Person.hobbies.one // cardinality-many
val gender : String      = Person.gender.one  // enum values
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/expressions&#34;&gt;Expressions&lt;/a&gt; - filter attribute values with expressions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(42)               // equal value
Person.age.&amp;lt;(42)             // compare values
Person.age.&amp;gt;(42)             // compare values
Person.age.&amp;lt;=(42)            // compare values
Person.age.&amp;gt;=(42)            // compare values
Person.age.!=(42)            // negate values
Person.name.contains(&amp;quot;John&amp;quot;) // fulltext search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/aggregates&#34;&gt;Aggregates&lt;/a&gt; - aggregate attribute values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(min) 
Person.age(max) 
// ... rand, sample, count, countDistinct
// ... sum, avg, median, variance, stddev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/or-logic&#34;&gt;OR-logic&lt;/a&gt; - apply OR logic to collect alternative values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name(&amp;quot;John&amp;quot; or &amp;quot;Jonas&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://scalamolecule.org/manual/query/parameterize&#34;&gt;Parameterize&lt;/a&gt; - let Datomic cache queries and optimize performance&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val person = Person.name(?).age(?)

// Re-use `person`
val Johan  = person(&amp;quot;John&amp;quot;, 33).one
val Lisa   = person(&amp;quot;Lisa&amp;quot;, 27).one
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Modelling</title>
      <link>http://scalamolecule.org/manual/schema/modelling/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/modelling/</guid>
      <description>

&lt;h1 id=&#34;modelling:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Modelling&lt;/h1&gt;

&lt;p&gt;A Datomic &lt;code&gt;schema&lt;/code&gt; defines the set of &lt;code&gt;attributes&lt;/code&gt; you can assign to &lt;code&gt;entities&lt;/code&gt;.
We organize &lt;code&gt;attributes&lt;/code&gt; in &lt;code&gt;namespaces&lt;/code&gt; to group related qualities:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/DatomicElements1.png&#34; alt=&#34;Schema&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This makes it easier to overview our domain data structures.&lt;/p&gt;

&lt;h4 id=&#34;namespace-table:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Namespace != Table&lt;/h4&gt;

&lt;p&gt;If coming from an sql background one might at first think of a namespace as
a table having columns (attributes). But this is not the case. An
entity in Datomic can associate values of attributes &lt;em&gt;from any namespace&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/DatomicElements2.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;This gives us great freedom to model our domain with more &amp;ldquo;loose&amp;rdquo; namespaces rather than &amp;ldquo;hardcoded things&amp;rdquo; as table definitions. Later we can compose entities grabbing specific attributes from various namespaces as needed.&lt;/p&gt;

&lt;h3 id=&#34;relating-namespaces:1a78f08b347c58aecd18d23e659bda2c&#34;&gt;Relating namespaces&lt;/h3&gt;

&lt;p&gt;If we recall the Seattle domain then we have some attributes organized in 3
related namespaces:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://scalamolecule.org/img/DatomicElements3.png&#34; alt=&#34;Seattle Model&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Community.type&lt;/code&gt;, &lt;code&gt;Community.orgtype&lt;/code&gt; and &lt;code&gt;District.region&lt;/code&gt; all have fixed
enumerated values to choose from. And &lt;code&gt;Community.category&lt;/code&gt; is the only
many-cardinality attribute allowed to have multiple values.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>