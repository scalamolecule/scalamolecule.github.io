<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Manuals on Molecule</title>
    <link>http://localhost:1313/manual/</link>
    <description>Recent content in Manuals on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Fri, 02 Jan 2015 22:06:44 CET</lastBuildDate>
    <atom:link href="http://localhost:1313/manual/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Manual</title>
      <link>http://localhost:1313/manual/overview/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/overview/</guid>
      <description>

&lt;h1 id=&#34;molecule-manual:68f80267fa3a50980dbb745a782b8dca&#34;&gt;Molecule manual&lt;/h1&gt;

&lt;p&gt;This is a light-weight manual for Molecule.&lt;/p&gt;

&lt;p&gt;Please choose a subject in the menu on the right&amp;hellip;&lt;/p&gt;

&lt;p&gt;For more in-depth examples see
&lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/coretest/src/test/scala/molecule&#34;&gt;core tests&lt;/a&gt;
or
&lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/examples/src/test/scala/molecule/examples&#34;&gt;examples&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;suggestions:68f80267fa3a50980dbb745a782b8dca&#34;&gt;Suggestions&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;re welcome to raise &lt;a href=&#34;https://github.com/scalamolecule/molecule-docs/issues&#34;&gt;documentation issues&lt;/a&gt;
and/or &lt;a href=&#34;https://github.com/scalamolecule/molecule/issues&#34;&gt;Molecule code isues&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Builder</title>
      <link>http://localhost:1313/manual/query/builder/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/query/builder/</guid>
      <description>

&lt;h1 id=&#34;attribute-builder-pattern:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Attribute builder pattern&lt;/h1&gt;

&lt;p&gt;(See &lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/attr/Attribute.scala&#34;&gt;attribute tests&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;When we have defined a schema, Molecule generates the necessary boilerplate code so that we can build &amp;ldquo;molecular data
 structures&amp;rdquo; by building sequences of Attributes separated with dots (the &amp;ldquo;builder pattern&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;We could for instance build a molecule representing the data structure of Persons with name, age and gender Attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender // etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fundamental building blocks are Namespaces like &lt;code&gt;Person&lt;/code&gt; and Attributes like &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt; and &lt;code&gt;gender&lt;/code&gt;. Namespaces
 are simply prefixes to Attribute names to avoid name clashes and to group our Attributes in meaningful ways according to our domain.&lt;/p&gt;

&lt;p&gt;As you see we start our molecule from some Namespace and then build on Attribute by Attribute.&lt;/p&gt;

&lt;h2 id=&#34;3-ways-of-getting-data:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;3 ways of getting data&lt;/h2&gt;

&lt;h4 id=&#34;1-mandatory-attributes:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;1. Mandatory Attributes&lt;/h4&gt;

&lt;p&gt;When we use a molecule to query the Datomic database we ask for entities having all our Attributes associated with them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that this is different from selecting rows from a sql table where you can also get null values back!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If for instance we have entities representing Persons in our data set that haven&amp;rsquo;t got any age Attribute associated
with them then this query will &lt;em&gt;not&lt;/em&gt; return those entities:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically we look for &lt;strong&gt;matches&lt;/strong&gt; to our molecule data structure.&lt;/p&gt;

&lt;h4 id=&#34;2-tacet-attributes-with-suffix:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;2. Tacet Attributes with &lt;code&gt;_&lt;/code&gt; suffix&lt;/h4&gt;

&lt;p&gt;Sometimes we want to grap entities that we &lt;em&gt;know&lt;/em&gt; have certain attributes, but without returning those values.
We call the un-returning attributes &amp;ldquo;tacet attributes&amp;rdquo; (music term for &amp;ldquo;silent&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;If for instance we wanted to find all names of Persons that have an age attribute set but we don&amp;rsquo;t need to return those age
 values, then we can add an underscore &lt;code&gt;_&lt;/code&gt; after the &lt;code&gt;age&lt;/code&gt; Attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val names = Person.name.age_.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will return names of person entities having both a name and age Attribute set. Note how the age values are no
longer returned from the type signatures:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: Iterable[(String, Int)] = Person.name.age.get
val names  : Iterable[String]        = Person.name.age_.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This way we can switch on and off individual attributes from the result set without affecting the data structures
we look for.&lt;/p&gt;

&lt;h4 id=&#34;3-optional-attributes-with-suffix-like-null-values:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;3. Optional Attributes with &lt;code&gt;$&lt;/code&gt; suffix (like Null values)&lt;/h4&gt;

&lt;p&gt;If an attribute value is only sometimes set, we can ask for it&amp;rsquo;s optional value by adding a dollar sign &lt;code&gt;$&lt;/code&gt; after the attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val names: Iterable[(String, Option[String], String)] = Person.firstName.middleName$.lastName.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That way we can get all person names with or without middleNames. As you can see from the return type, the middle
name is wrapped in an &lt;code&gt;Option&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;tuples-returned:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Tuples returned&lt;/h3&gt;

&lt;p&gt;Molecule returns all result sets as tuples of values (with &lt;code&gt;get&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: Iterable[(String, Int)] = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;molecule-max-size:8fd4bc5e57a8b030c7141267f15a6e67&#34;&gt;Molecule max size&lt;/h2&gt;

&lt;p&gt;The size of molecules are limited to Scala&amp;rsquo;s arity limit of 22 for tuples. If you need to return more you can
use an additional molecule that takes an entity id and then retrieve further attribute values for that entity.&lt;/p&gt;

&lt;p&gt;If we need to insert/return more than 22 attribute values we can easily do this by using the entity id to
work with further attributes/values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Insert maximum of 22 facts and return the created entity id
val eid = Ns.someId.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.insert(
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22
).eid

// Use entity id to continue adding more values for the same entity
Ns.x.y.z.insert(eid, 23, 24, 25)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise we can retrieve more than 22 values in 2 steps&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val first22values = Ns.someId_(1).b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.get

// Use entity id to continue adding more values
val next3values = Ns.x.y.z.insert(eid, 23, 24, 25)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Getting started</title>
      <link>http://localhost:1313/manual/getting-started/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/getting-started/</guid>
      <description>

&lt;h1 id=&#34;getting-started-with-molecule:b6885e1f85551f51a4707c402f8200a3&#34;&gt;Getting started with Molecule&lt;/h1&gt;

&lt;p&gt;To use Molecule we need to define our database schema in a &lt;a href=&#34;http://localhost:1313/manual/schema&#34;&gt;Schema definition&lt;/a&gt; file and then tell
sbt about it. When compiling our project from the command line, all necessary boilerplate code is
then automatically generated.&lt;/p&gt;

&lt;h2 id=&#34;1-sbt-build-settings:b6885e1f85551f51a4707c402f8200a3&#34;&gt;1. SBT build settings&lt;/h2&gt;

&lt;p&gt;Add the following to your build files:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;project/build.properties&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sbt.version=0.13.13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;project/buildinfo.sbt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;addSbtPlugin(&amp;quot;org.scalamolecule&amp;quot; % &amp;quot;sbt-molecule&amp;quot; % &amp;quot;0.3.3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;build.sbt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;lazy val yourProject = project.in(file(&amp;quot;demo&amp;quot;))
  .enablePlugins(MoleculePlugin)
  .settings(
    resolvers ++= Seq(
      &amp;quot;datomic&amp;quot; at &amp;quot;http://files.datomic.com/maven&amp;quot;,
      &amp;quot;clojars&amp;quot; at &amp;quot;http://clojars.org/repo&amp;quot;,
      Resolver.sonatypeRepo(&amp;quot;releases&amp;quot;)
    ),
    libraryDependencies ++= Seq(
      &amp;quot;org.scalamolecule&amp;quot; %% &amp;quot;molecule&amp;quot; % &amp;quot;0.11.0&amp;quot;,
      &amp;quot;com.datomic&amp;quot; % &amp;quot;datomic-free&amp;quot; % &amp;quot;0.9.5561&amp;quot;
    ),
    moleculeSchemas := Seq(&amp;quot;demo&amp;quot;) // paths to your schema definition files...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule 0.11.0 for Scala 2.12.1 is available at
&lt;a href=&#34;https://oss.sonatype.org/content/repositories/releases/org/scalamolecule/molecule_2.12/&#34;&gt;Sonatype&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;2-paths-to-schema-definition-files:b6885e1f85551f51a4707c402f8200a3&#34;&gt;2. Paths to Schema definition files&lt;/h1&gt;

&lt;p&gt;We use the &lt;code&gt;moleculeSchemas&lt;/code&gt; sbt settings key to tell sbt where we have our Schema definition files.&lt;/p&gt;

&lt;p&gt;A &lt;a href=&#34;http://localhost:1313/manual/schema&#34;&gt;Schema definition&lt;/a&gt; file contains a plain Scala object where you define
partitions/namespaces/attributes of your Datomic database. The MoleculePlugin uses the information
defined there to create all the boilerplate code needed to use Molecule in your code.&lt;/p&gt;

&lt;p&gt;You can have a single or several Schema definition files in a project. Each definition file defines a single database.
This is useful if you for instance want to experiment with various database designs during development.&lt;/p&gt;

&lt;p&gt;Schema definiton files should reside in directories named &lt;code&gt;schema&lt;/code&gt; anywhere in your source code.&lt;/p&gt;

&lt;p&gt;Use the &lt;code&gt;moleculeSchemas&lt;/code&gt; sbt settings key to list the directories in your project source
code that contains your &lt;code&gt;schema&lt;/code&gt; directories.&lt;/p&gt;

&lt;p&gt;Say you have a project &lt;code&gt;demo&lt;/code&gt; and a single Schema definition file &lt;code&gt;YourDomainDefinition.scala&lt;/code&gt;
defining your database:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/img/dirs1.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Then you simply add &lt;code&gt;moleculeSchemas := Seq(&amp;quot;demo&amp;quot;)&lt;/code&gt; as we saw above.&lt;/p&gt;

&lt;p&gt;In the main Molecule project&amp;rsquo;s examples module we have several Schema definition files:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/img/dirs2.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;And we then list the paths to those like this in our &lt;code&gt;build.sbt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;moleculeSchemas := Seq(
  &amp;quot;molecule/examples/dayOfDatomic&amp;quot;,
  &amp;quot;molecule/examples/graph&amp;quot;,
  &amp;quot;molecule/examples/mbrainz&amp;quot;,
  &amp;quot;molecule/examples/seattle&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-compile:b6885e1f85551f51a4707c402f8200a3&#34;&gt;3. Compile&lt;/h2&gt;

&lt;p&gt;Now that you have created a schema definition file and told sbt about where to find it, you can compile
your project from the terminal&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; cd yourProjectRoot
&amp;gt; sbt compile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The MoleculePlugin will now automatically as part of the compilation process do 5 things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Generate Molecule boilerplate dsl source code files (in the &lt;code&gt;src_managed&lt;/code&gt; directory in target)&lt;/li&gt;
&lt;li&gt;Generate a schema file with the necessary code to transact the Datomic schema&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Compile the generated code&lt;/li&gt;
&lt;li&gt;Package both the source code and compiled classes into two &lt;code&gt;jar&lt;/code&gt;s and place them in the &lt;code&gt;lib&lt;/code&gt; directory of your module&lt;/li&gt;
&lt;li&gt;Remove the generated source code and compiled classes&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The MoleculePlugin create the &lt;code&gt;jars&lt;/code&gt; so that you can use the boilerplate code without having to recompile any
generated boilerplate code each time you recompile your project. In our demo example two jars are created:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/img/jars.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;4-use-molecule:b6885e1f85551f51a4707c402f8200a3&#34;&gt;4. Use Molecule&lt;/h2&gt;

&lt;p&gt;The MoleculePlugin has now created all the necessary boilerplate code so that we can start using Molecule. We can
create a fresh in-memory Datomic database by supplying the generated Schema transaction code in &lt;code&gt;YourDomainSchema&lt;/code&gt;
(from the example above):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import molecule._
implicit val conn = recreateDbFrom(demo.schema.YourDomainSchema)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the implicit Datomic connection available we can start making molecules:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import demo.dsl.yourDomain._

// Insert data
Person.name(&amp;quot;John&amp;quot;).age(26).gender(&amp;quot;male&amp;quot;).save

// Retrieve data
val (person, age, gender) = Person.name.age.gender.get.head
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;read-more:b6885e1f85551f51a4707c402f8200a3&#34;&gt;Read more&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/manual/schema&#34;&gt;Schema definition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/manual/schema/transaction&#34;&gt;Create Datomic database&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Mapped attributes</title>
      <link>http://localhost:1313/manual/query/mapped/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/query/mapped/</guid>
      <description>

&lt;h1 id=&#34;mapped-attributes:a97bd84cbba6263d9bc50859a818a594&#34;&gt;Mapped Attributes&lt;/h1&gt;

&lt;p&gt;(See &lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/coretest/src/test/scala/molecule/attrMap&#34;&gt;mapped tests&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Mapped values can be saved with mapped attributes in Molecule. It&amp;rsquo;s a special Molecule construct that makes
it easy to save for instance multi-lingual data without having to create language-variations of each attribute.
But they can also be used for any other key-value indexed data.&lt;/p&gt;

&lt;p&gt;Say you want to save famous Persons names in multiple languages. Then you could use a mapString:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// In definition file
val name = mapString
 
// Insert mapped data
Person.id.name.insert(
  1, 
  Map(
    &amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;,
    &amp;quot;de&amp;quot; -&amp;gt; &amp;quot;Dmitri Schostakowitsch&amp;quot;,
    &amp;quot;fr&amp;quot; -&amp;gt; &amp;quot;Dmitri Chostakovitch&amp;quot;,
    &amp;quot;es&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakóvich&amp;quot;
  )
)

// Retrieve mapped data
Person.id.name.one === (1, 
  Map(
    &amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;,
    &amp;quot;de&amp;quot; -&amp;gt; &amp;quot;Dmitri Schostakowitsch&amp;quot;,
    &amp;quot;fr&amp;quot; -&amp;gt; &amp;quot;Dmitri Chostakovitch&amp;quot;,
    &amp;quot;es&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakóvich&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule concatenates the key and value of each pair to one of several values of an underlying cardinality-many attribute. When
data is then retrieved Molecule splits the concatenated string into a typed pair. This all happens automatically and let&amp;rsquo;s us focus
 on their use in our code.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a broad range of ways we can query mapped attributes and you can see a lot of examples of their use in
the &lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/coretest/src/test/scala/molecule/attrMap&#34;&gt;&lt;code&gt;attrMap&lt;/code&gt; test cases&lt;/a&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Schema</title>
      <link>http://localhost:1313/manual/schema/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/schema/</guid>
      <description>

&lt;h1 id=&#34;schema:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Schema&lt;/h1&gt;

&lt;p&gt;A &lt;a href=&#34;http://docs.datomic.com/schema.html&#34;&gt;Datomic &lt;code&gt;schema&lt;/code&gt;&lt;/a&gt; defines the set of possible &lt;code&gt;attributes&lt;/code&gt; that we can use.&lt;/p&gt;

&lt;h2 id=&#34;schema-definition-file:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Schema definition file&lt;/h2&gt;

&lt;p&gt;Molecule provides an intuitive and type-safe dsl to model your schema in a Schema definition file.
After each change you make in this file you need to &lt;code&gt;sbt compile&lt;/code&gt; to use your updated schema with
your molecules.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at the schema definition of the Seattle example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;package yourpackage
import molecule.schema.definition._  // import schema definition DSL

@InOut(3, 8)
object SeattleDefinition {

  trait Community {
    val name         = oneString.fullTextSearch
    val url          = oneString
    val category     = manyString.fullTextSearch
    val orgtype      = oneEnum(&#39;community, &#39;commercial, &#39;nonprofit, &#39;personal)
    val `type`       = oneEnum(&#39;email_list, &#39;twitter, &#39;facebook_page) // + more...
    val neighborhood = one[Neighborhood]
  }

  trait Neighborhood {
    val name     = oneString
    val district = one[District]
  }

  trait District {
    val name   = oneString
    val region = oneEnum(&#39;n, &#39;ne, &#39;e, &#39;se, &#39;s, &#39;sw, &#39;w, &#39;nw)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The outer object &lt;code&gt;SeattleDefinition&lt;/code&gt; encapsulates our schema definition. All such objects have to have a
named ending in &amp;ldquo;Definition&amp;rdquo; in order for the MoleculePlugin to be able to find it.&lt;/p&gt;

&lt;h3 id=&#34;molecule-arity:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Molecule arity&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;@InOut(3, 8)&lt;/code&gt; arity annotation instructs Molecule to generate boilerplate code with the ability to create
molecules with up to 8 attributes including up to 3 &lt;a href=&#34;http://localhost:1313/manual/query/parameterize&#34;&gt;input attributes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When developing your schema you might just set the first arity annotation variable for input attributes to &lt;code&gt;0&lt;/code&gt; and
then later when your schema is stabilizing add the ability to make input molecules by setting it to 1, 2 or 3 (the maximum).
Using parameterized input attributes can be a performance
optimization since using input values in Datalog queries allow Datomic to cache the query.&lt;/p&gt;

&lt;p&gt;The second arity annotation parameter basically tells how long molecules you can build (this doesn&amp;rsquo;t affect
 how many attributes you can &lt;em&gt;define&lt;/em&gt; in each namespace). Generally you want to keep this number as low as possible
 not to generate more boilerplate code than necessary. The maximum arity is 22, the same as for tuples.&lt;/p&gt;

&lt;p&gt;If you at some point need to make molecules with more than 22 attributes
  you can insert/query in two steps as described &lt;a href=&#34;http://localhost:1313/manual/query/builder&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;namespaces:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Namespaces&lt;/h3&gt;

&lt;p&gt;Attribute names in Datomic are namespaced keywords with the lexical form &lt;code&gt;&amp;lt;namespace&amp;gt;/&amp;lt;name&amp;gt;&lt;/code&gt;. Molecule lets you
define the &lt;code&gt;&amp;lt;namespace&amp;gt;&lt;/code&gt; part with the name of the trait, like &lt;code&gt;Community&lt;/code&gt; in the Seattle
example above. In this way Molecule can construct the full name of the &lt;code&gt;community/category&lt;/code&gt; attribute etc.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/img/DatomicElements1.png&#34; alt=&#34;Schema&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;We might as well have defined a list of attributes manually adding a namespace
part to each attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val communityName
val communityUrl
//...

val neighborhoodName
// etc...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;namespace-table:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Namespace != Table&lt;/h4&gt;

&lt;p&gt;If coming from an sql background one might at first think of a namespace as
a table having columns (attributes). But this is not the case. An
entity in Datomic can associate values of attributes &lt;em&gt;from any namespace&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/img/DatomicElements2.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;So, when we build a molecule&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val toughCommunities = Community.name.Neighborhood.name(&amp;quot;Tough&amp;quot;).get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we &lt;em&gt;shouldn&amp;rsquo;t&lt;/em&gt; think of it like a&lt;/p&gt;

&lt;p&gt;&amp;ldquo;&lt;code&gt;Community&lt;/code&gt; table with &lt;code&gt;name&lt;/code&gt; field with a join to &lt;code&gt;Neighborhood&lt;/code&gt; table with a &lt;code&gt;name&lt;/code&gt; field set to &amp;ldquo;Tough&amp;rdquo; (wrong!)&lt;/p&gt;

&lt;p&gt;but rather think it as&lt;/p&gt;

&lt;p&gt;&amp;ldquo;&lt;strong&gt;&lt;em&gt;entities&lt;/em&gt;&lt;/strong&gt; with a &lt;code&gt;communityName&lt;/code&gt; attribute and a reference to an entity having a &lt;code&gt;neighborhoodName&lt;/code&gt; value equalling
&amp;ldquo;Tough&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;partitions:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Partitions&lt;/h3&gt;

&lt;p&gt;Namespaces can also be organized in partitions.&lt;/p&gt;

&lt;p&gt;From the &lt;a href=&#34;http://docs.datomic.com/schema.html&#34;&gt;Datomic schema&lt;/a&gt; reference:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;All entities created in a database reside within a partition. Partitions group data together, providing locality of reference
when executing queries across a collection of entities. In general, you want to group entities based on how you&amp;rsquo;ll use them.
Entities you&amp;rsquo;ll often query across - like the community-related entities in our sample data - should be in the same partition
to increase query performance. Different logical groups of entities should be in different partitions. Partitions are discussed
in more detail in the Indexes topic.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In Molecule we can organize namespaces in partitions with objects:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;@InOut(0, 4)
object PartitionTestDefinition {

  object gen {
    trait Person {
      val name   = oneString
      val gender = oneEnum(&#39;male, &#39;female)
    }
    // ..more namespaces in the `gen` partition
  }

  object lit {
    trait Book {
      val title  = oneString
      val author = one[gen.Person]
      // To avoid attr/partition name clashes we can prepend the definition object name
      // (in case we would have needed an attribute named `gen` for instance)
      val editor = one[PartitionTestDefinition.gen.Person]
      val cat    = oneEnum(&#39;good, &#39;bad)
    }
    // ..more namespaces in the `lit` partition
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have a &lt;code&gt;gen&lt;/code&gt; (general) partition and a &lt;code&gt;lit&lt;/code&gt; (litterature) partition. Each partition can contain as many
namespaces as you want. This can be a way also to structure large domains conceptually. The partition name is
prepended to the namespaces it contains.&lt;/p&gt;

&lt;p&gt;When we build molecules the partition name is prepended to the namespace like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;lit_Book.title.cat.Author.name.gender.get === ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;Author&lt;/code&gt; is already defined as a related namespace we don&amp;rsquo;t need to prepend the partition name there.&lt;/p&gt;

&lt;p&gt;When we insert a &lt;code&gt;Person&lt;/code&gt; the created entity will automatically be saved in the &lt;code&gt;gen&lt;/code&gt; partition (or whatever we call it).&lt;/p&gt;

&lt;h2 id=&#34;attribute-types:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Attribute types&lt;/h2&gt;

&lt;p&gt;In the Seattle example we see the attributes being defined with the following types that should be
 pretty self-explanatory:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;oneString&lt;/code&gt;, &lt;code&gt;manyString&lt;/code&gt; etc defines cardinality and type of an attribute&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oneEnum&lt;/code&gt;/&lt;code&gt;manyEnum&lt;/code&gt; defines enumerated values (pre-defined words)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;one[&amp;lt;ReferencedNamespace&amp;gt;]&lt;/code&gt; defines a reference to another namespace&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can define the following types of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one              Cardinality many                 Mapped cardinality many
-------------------          -------------------------        --------------------------------
oneString     : String       manyString    : Set[String]      mapString     : Map[String, String]
oneInt        : Int          manyInt       : Set[Int]         mapInt        : Map[String, Int]
oneLong       : Long         manyLong      : Set[Long]        mapLong       : Map[String, Long]
oneFloat      : Float        manyFloat     : Set[Float]       mapFloat      : Map[String, Float]
oneDouble     : Double       manyDouble    : Set[Double]      mapDouble     : Map[String, Double]
oneBigInt     : BigInt       manyBigInt    : Set[BigInt]      mapBigInt     : Map[String, BigInt]
oneBigDecimal : BigDecimal   manyBigDecimal: Set[BigDecimal]  mapBigDecimal : Map[String, BigDecimal]
oneBoolean    : Boolean      manyBoolean   : Set[Boolean]     mapBoolean    : Map[String, Boolean]
oneDate       : Date         manyDate      : Set[Date]        mapDate       : Map[String, Date]
oneUUID       : UUID         manyUUID      : Set[UUID]        mapUUID       : Map[String, UUID]
oneURI        : URI          manyURI       : Set[URI]         mapURI        : Map[String, URI]
oneEnum       : String       manyEnum      : Set[String]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cardinality-one attributes can have one value per entity.&lt;/p&gt;

&lt;p&gt;Cardinality-many attributes can have a &lt;em&gt;Set of unique values&lt;/em&gt; per entity. Often we choose instead to model many-values as a
many-reference to another entity that could have more than one attribute.&lt;/p&gt;

&lt;p&gt;Mapped cardinality many attributes are a special Molecule variation based on cardinality-many attributes. Read more &lt;a href=&#34;http://localhost:1313/manual/query/mapped&#34;&gt;here&lt;/a&gt;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;reference-types:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Reference types&lt;/h3&gt;

&lt;p&gt;References are also treated like attributes. It&amp;rsquo;s basically a reference to one or many entities.
We define such relationship by supplying the referenced namespace as the type parameter to &lt;code&gt;one&lt;/code&gt;/&lt;code&gt;many&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cardinality one         Cardinality many
---------------         ----------------
one[&amp;lt;Ref-namespace&amp;gt;]    many[&amp;lt;Ref-namespace&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above we saw a reference from Community to Neighborhood defined as &lt;code&gt;one[Neighborhood]&lt;/code&gt;. We would for instance
likely define an Order/OrderLine relationship in an Order namespace as &lt;code&gt;many[OrderLine]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;attribute-options:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Attribute options&lt;/h2&gt;

&lt;p&gt;Each attribute can also have some extra options:&lt;/p&gt;

&lt;p&gt;
&lt;table border=&#34;1&#34; cellpadding=&#34;5&#34; cellspacing=&#34;0&#34; style=&#34;background-color:#f5f5f5;&#34;&gt;
  &lt;tr&gt;
    &lt;th align=&#34;left&#34; valign=&#34;top&#34; scope=&#34;col&#34;&gt;Option&lt;/th&gt;
    &lt;th valign=&#34;top&#34; scope=&#34;col&#34;&gt;&lt;strong&gt;Indexes&lt;/strong&gt;&lt;/th&gt;
    &lt;th scope=&#34;col&#34;&gt;Description&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;doc&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Attribute description.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueValue&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a different entity id will fail.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr valign=&#34;top&#34;&gt;
    &lt;td valign=&#34;top&#34;&gt;uniqueIdentity&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Attribute value is unique to each entity and &amp;quot;upsert&amp;quot; is enabled.&lt;br&gt;
      &lt;em&gt;Attempts to insert a duplicate value for a temporary entity id will cause all attributes associated with that temporary 
      id to be merged with the entity already in the database.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;indexed&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generated index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;fullTextSearch&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Generate eventually consistent fulltext search index for this attribute.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;isComponent&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;✔︎&lt;/td&gt;
    &lt;td&gt;Specifies that an attribute whose type is :db.type/ref refers to a subcomponent of the entity to which the attribute is applied.&lt;br&gt;
    &lt;em&gt;When you retract an entity with :db.fn/retractEntity, all subcomponents are also retracted. When you touch an entity, all its 
    subcomponent entities are touched recursively.&lt;/em&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td valign=&#34;top&#34;&gt;noHistory&lt;/td&gt;
    &lt;td align=&#34;center&#34; valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
    &lt;td&gt;Whether past values of an attribute should not be retained.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;/p&gt;

&lt;p&gt;Datomic indexes the values of all attributes having an option except for the &lt;code&gt;doc&lt;/code&gt; and &lt;code&gt;noHistory&lt;/code&gt; options.&lt;/p&gt;

&lt;p&gt;As you saw, we added &lt;code&gt;fulltextSearch&lt;/code&gt; to some of the attributes in the Seattle definition above. Molecule&amp;rsquo;s schema
definition DSL let&amp;rsquo;s you only choose allowed options for any attribute type.&lt;/p&gt;

&lt;h3 id=&#34;next:e608d9ac6a0d5e2b6db229b78a3e65b4&#34;&gt;Next&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/manual/schema/transaction&#34;&gt;Create database&lt;/a&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Expressions</title>
      <link>http://localhost:1313/manual/query/expressions/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/query/expressions/</guid>
      <description>

&lt;h1 id=&#34;expressions:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Expressions&lt;/h1&gt;

&lt;p&gt;(See &lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/coretest/src/test/scala/molecule/expression&#34;&gt;expression tests&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&#34;equality:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Equality&lt;/h3&gt;

&lt;p&gt;We can apply values to Attributes in order to filter the data structures we are looking for. We could for instance look for names of female persons:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.apply(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or simply&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;or-logic:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;OR-logic&lt;/h3&gt;

&lt;p&gt;We can apply OR-logic to find a selection of alternatives&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(40 or 41 or 42)
// .. same as
Person.age(40, 41, 42)
// .. same as
Person.age(List(40, 41, 42))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;negation:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Negation&lt;/h3&gt;

&lt;p&gt;We can exclude a certain attribute value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.!=(42)
// or
Person.age.not(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With negations we can again apply multiple values as alternatives&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.!=(40 or 41 or 42)
Person.age.!=(40, 41, 42)
Person.age.!=(List(40, 41, 42))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;comparison:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Comparison&lt;/h3&gt;

&lt;p&gt;We can filer attribute values that satisfy comparison expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.&amp;lt;(42)
Person.age.&amp;gt;(42)
Person.age.&amp;lt;=(42)
Person.age.&amp;gt;=(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comparison of all types are performed with java&amp;rsquo;s &lt;code&gt;compareTo&lt;/code&gt; method. Text strings can for instance also be sorted by a letter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.&amp;lt;(&amp;quot;C&amp;quot;).get(3) === List(
  &amp;quot;ArtsWest&amp;quot;, &amp;quot;All About South Park&amp;quot;, &amp;quot;Ballard Neighbor Connection&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fulltext-search:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;Fulltext search&lt;/h3&gt;

&lt;p&gt;If we add the &lt;code&gt;fullTextSearch&lt;/code&gt; option to a String attribute definition Datomic will index the text strings saved so that we can do fulltext searches accross all values. We could for instance search for Community names containing the word &amp;ldquo;Town&amp;rdquo; in their name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.contains(&amp;quot;Town&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that only full words are considered, so &amp;ldquo;Tow&amp;rdquo; won&amp;rsquo;t match. Also the following common words are not considered:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;a&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;are&amp;quot;, &amp;quot;as&amp;quot;, &amp;quot;at&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;but&amp;quot;, &amp;quot;by&amp;quot;,
&amp;quot;for&amp;quot;, &amp;quot;if&amp;quot;, &amp;quot;in&amp;quot;, &amp;quot;into&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;it&amp;quot;,
&amp;quot;no&amp;quot;, &amp;quot;not&amp;quot;, &amp;quot;of&amp;quot;, &amp;quot;on&amp;quot;, &amp;quot;or&amp;quot;, &amp;quot;such&amp;quot;,
&amp;quot;that&amp;quot;, &amp;quot;the&amp;quot;, &amp;quot;their&amp;quot;, &amp;quot;then&amp;quot;, &amp;quot;there&amp;quot;, &amp;quot;these&amp;quot;,
&amp;quot;they&amp;quot;, &amp;quot;this&amp;quot;, &amp;quot;to&amp;quot;, &amp;quot;was&amp;quot;, &amp;quot;will&amp;quot;, &amp;quot;with&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;we-can-use-variables-too:ccf7e9e64ce1a51aa79e6eb1314d9467&#34;&gt;We can use variables too&lt;/h3&gt;

&lt;p&gt;Even though Molecule introspects molecule constructions at compile time we can still use (runtime) variables for our expressions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val youngAge = 25
val goodAge = 42
Person.age(goodAge)
Person.age.&amp;gt;(goodAge)
Person.age.&amp;lt;=(goodAge)
Person.age.&amp;gt;=(goodAge)
Person.age.!=(goodAge)
Person.age.!=(youngAge or goodAge)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Technically, Molecule saves the TermName of the variable for later resolution at runtime so that we can freely use variables in our expressions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val ages = List(youngAge, goodAge)
Person.age(goodAge)
Person.age.&amp;gt;(goodAge)
Person.age.&amp;lt;=(goodAge)
Person.age.&amp;gt;=(goodAge)
Person.age.!=(goodAge)
Person.age.!=(youngAge or goodAge)
// etc...
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Transaction</title>
      <link>http://localhost:1313/manual/schema/transaction/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/schema/transaction/</guid>
      <description>

&lt;h1 id=&#34;schema-transaction:2e47673b0e2fecf4f97d6b00d496cdc9&#34;&gt;Schema transaction&lt;/h1&gt;

&lt;p&gt;To create our Datomic database we need to transact some schema transaction data.&lt;/p&gt;

&lt;h2 id=&#34;schema-transaction-data:2e47673b0e2fecf4f97d6b00d496cdc9&#34;&gt;Schema transaction data&lt;/h2&gt;

&lt;p&gt;Molecule transforms our &lt;a href=&#34;http://localhost:1313/manual/schema&#34;&gt;Schema definition file&lt;/a&gt; to
basically a &lt;code&gt;java.util.List&lt;/code&gt; containing a &lt;code&gt;java.util.Map&lt;/code&gt; of schema transaction data for each attribute defined.
Our &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;url&lt;/code&gt; attributes for instance requires the following map of information to be transacted in Datomic:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object SeattleSchema extends Transaction {
  
  lazy val partitions = Util.list()

  lazy val namespaces = Util.list(
    
    // Community --------------------------------------------------------

    Util.map(&amp;quot;:db/ident&amp;quot;             , &amp;quot;:community/name&amp;quot;,
             &amp;quot;:db/valueType&amp;quot;         , &amp;quot;:db.type/string&amp;quot;,
             &amp;quot;:db/cardinality&amp;quot;       , &amp;quot;:db.cardinality/one&amp;quot;,
             &amp;quot;:db/fulltext&amp;quot;          , true.asInstanceOf[Object],
             &amp;quot;:db/index&amp;quot;             , true.asInstanceOf[Object],
             &amp;quot;:db/id&amp;quot;                , Peer.tempid(&amp;quot;:db.part/db&amp;quot;),
             &amp;quot;:db.install/_attribute&amp;quot;, &amp;quot;:db.part/db&amp;quot;),

    Util.map(&amp;quot;:db/ident&amp;quot;             , &amp;quot;:community/url&amp;quot;,
             &amp;quot;:db/valueType&amp;quot;         , &amp;quot;:db.type/string&amp;quot;,
             &amp;quot;:db/cardinality&amp;quot;       , &amp;quot;:db.cardinality/one&amp;quot;,
             &amp;quot;:db/index&amp;quot;             , true.asInstanceOf[Object],
             &amp;quot;:db/id&amp;quot;                , Peer.tempid(&amp;quot;:db.part/db&amp;quot;),
             &amp;quot;:db.install/_attribute&amp;quot;, &amp;quot;:db.part/db&amp;quot;),
             
    // etc...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you see, the &lt;code&gt;Community&lt;/code&gt; namespace information is present in the value of the first pair in the map for
the &lt;code&gt;name&lt;/code&gt; attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;&amp;quot;:db/ident&amp;quot;, &amp;quot;:community/name&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest of the lines are pretty self-describing except from the last two that create and save the
internal id of the attribute in Datomic. &lt;a href=&#34;http://docs.datomic.com/schema.html&#34;&gt;Datomic schemas&lt;/a&gt; are
literally a set of datoms that have been transacted as any other data!&lt;/p&gt;

&lt;h3 id=&#34;partition-transaction-data:2e47673b0e2fecf4f97d6b00d496cdc9&#34;&gt;Partition transaction data&lt;/h3&gt;

&lt;p&gt;Partition transaction data looks almost like attribute transaction data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;lazy val partitions = Util.list(

Util.map(&amp;quot;:db/ident&amp;quot;             , &amp;quot;:gen&amp;quot;,
         &amp;quot;:db/id&amp;quot;                , Peer.tempid(&amp;quot;:db.part/db&amp;quot;),
         &amp;quot;:db.install/_partition&amp;quot;, &amp;quot;:db.part/db&amp;quot;),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; except that the information is now installed internally in Datomic as partition data instead of as attribute data.&lt;/p&gt;

&lt;p&gt;Partition examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/main/scala/molecule/part/schema/PartitionTestDefinition.scala&#34;&gt;partitioned schema definition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/part/Partition.scala&#34;&gt;partition tests&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;transact-create-datomic-database:2e47673b0e2fecf4f97d6b00d496cdc9&#34;&gt;Transact/create Datomic database&lt;/h2&gt;

&lt;p&gt;Now we can simply pass the generated raw transaction data to Datomic in order to create our partitions/schema:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;import datomic._
import molecule.DatomicFacade._

// Setup database
val uri = &amp;quot;datomic:mem://seattle&amp;quot;
Peer.deleteDatabase(uri)
Peer.createDatabase(uri)
implicit val conn = Peer.connect(uri)

// Transact partitions/schema
conn.transact(SeattleSchema.partitions) // Optional
conn.transact(SeattleSchema.namespaces)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(To be sure that we start off with a fresh in-memory database, we first delete any existing database for our URI).&lt;/p&gt;

&lt;p&gt;Alternatively we can do all the above with &lt;code&gt;recreateDbFrom&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;implicit val conn = recreateDbFrom(SeattleSchema)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After saving the Datomic in an implicit val we can start issuing Molecule queries.
molecules for the loaded domain.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Aggregates</title>
      <link>http://localhost:1313/manual/query/aggregates/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/query/aggregates/</guid>
      <description>

&lt;h1 id=&#34;aggregates:de7f9909aae9c5ac545867cc473806f6&#34;&gt;Aggregates&lt;/h1&gt;

&lt;p&gt;(See &lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/dayOfDatomic/Aggregates.scala&#34;&gt;aggregates tests&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Datomic offers some built-in aggregate functions to aggregate attribute values.&lt;/p&gt;

&lt;h3 id=&#34;aggregates-returning-a-single-value:de7f9909aae9c5ac545867cc473806f6&#34;&gt;Aggregates returning a single value&lt;/h3&gt;

&lt;h4 id=&#34;min-max:de7f9909aae9c5ac545867cc473806f6&#34;&gt;min/max&lt;/h4&gt;

&lt;p&gt;In Molecule you simply apply the aggregate function name as a keyword to your attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(min) // lowest age
Person.age(max) // highest age
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Supports all types.&lt;/p&gt;

&lt;h4 id=&#34;count:de7f9909aae9c5ac545867cc473806f6&#34;&gt;count&lt;/h4&gt;

&lt;p&gt;Not to be confused with &lt;code&gt;sum&lt;/code&gt; in that &lt;code&gt;count&lt;/code&gt; counts the entities having attribute with some value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(count) // count of all persons with an age (not the sum of ages)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;countdistinct:de7f9909aae9c5ac545867cc473806f6&#34;&gt;countDistinct&lt;/h4&gt;

&lt;p&gt;Not to be confused with &lt;code&gt;sum&lt;/code&gt; in that &lt;code&gt;count&lt;/code&gt; counts the entities having attribute with some value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(countDistinct)  // count of unique ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sum:de7f9909aae9c5ac545867cc473806f6&#34;&gt;sum&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(sum) // sum of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;avg:de7f9909aae9c5ac545867cc473806f6&#34;&gt;avg&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(avg) // average of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;median:de7f9909aae9c5ac545867cc473806f6&#34;&gt;median&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(median) // median of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;variance:de7f9909aae9c5ac545867cc473806f6&#34;&gt;variance&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(variance) // variance of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;stddev:de7f9909aae9c5ac545867cc473806f6&#34;&gt;stddev&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(stddev) // standard deviation of all ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;aggregates-returning-collections-of-values:de7f9909aae9c5ac545867cc473806f6&#34;&gt;Aggregates returning collections of values&lt;/h3&gt;

&lt;h4 id=&#34;distinct:de7f9909aae9c5ac545867cc473806f6&#34;&gt;distinct&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(distinct) // distinct ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;min-n:de7f9909aae9c5ac545867cc473806f6&#34;&gt;min(n)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(min(3)) // 3 lowest ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;max-n:de7f9909aae9c5ac545867cc473806f6&#34;&gt;max(n)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(max(3)) // 3 highest ages
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;rand-n:de7f9909aae9c5ac545867cc473806f6&#34;&gt;rand(n)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(rand(3)) // 3 random persons (with potential for duplicates!)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sample-n:de7f9909aae9c5ac545867cc473806f6&#34;&gt;sample(n)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(sample(3)) // 3 sample persons (without duplicates!)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Insert</title>
      <link>http://localhost:1313/manual/insert/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/insert/</guid>
      <description>

&lt;h1 id=&#34;insert-data:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Insert data&lt;/h1&gt;

&lt;p&gt;We basically have 3 ways of entering data with Molecule:&lt;/p&gt;

&lt;h3 id=&#34;1-data-molecule:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;1. Data-molecule&lt;/h3&gt;

&lt;p&gt;We can insert data by populating a molecule with data by applying a value to each
attribute and then simply &lt;code&gt;save&lt;/code&gt; it. Molecule makes sure
that each attribute only accepts values of the expected type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.insert
  .name(&amp;quot;AAA&amp;quot;)
  .url(&amp;quot;myUrl&amp;quot;)
  .`type`(&amp;quot;twitter&amp;quot;)
  .orgtype(&amp;quot;personal&amp;quot;)
  .category(&amp;quot;my&amp;quot;, &amp;quot;favorites&amp;quot;) // many cardinality allows multiple values
  .Neighborhood.name(&amp;quot;myNeighborhood&amp;quot;)
  .District.name(&amp;quot;myDistrict&amp;quot;).region(&amp;quot;nw&amp;quot;).save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note also how we easily insert data across several namespaces in one go!&lt;/p&gt;

&lt;h3 id=&#34;2-insert-molecule:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;2. Insert-molecule&lt;/h3&gt;

&lt;p&gt;Normally we would insert bigger data sets that we have exported from
somewhere else. For this scenario we define a molecule where each
attribute defines what type of data we can receive in a list of data tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.url.`type`.orgtype.category
    .Neighborhood.name.District.name.region insert List(
  (&amp;quot;community1&amp;quot;, &amp;quot;url1&amp;quot;, &amp;quot;twitter&amp;quot;, &amp;quot;community&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName1&amp;quot;, &amp;quot;DistName1&amp;quot;, &amp;quot;e&amp;quot;),
  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;myspace&amp;quot;, &amp;quot;nonprofit&amp;quot;, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), 
    &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;nw&amp;quot;),
  (&amp;quot;community3&amp;quot;, &amp;quot;url3&amp;quot;, &amp;quot;website&amp;quot;, &amp;quot;personal&amp;quot;, Set(&amp;quot;cat1&amp;quot;, &amp;quot;cat2&amp;quot;), 
    &amp;quot;NbhName3&amp;quot;, &amp;quot;DistName3&amp;quot;, &amp;quot;w&amp;quot;),
  // etc..
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how we insert data accross namespaces here too.&lt;/p&gt;

&lt;h3 id=&#34;3-insert-molecule-as-template:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;3. Insert-molecule as template&lt;/h3&gt;

&lt;p&gt;We can assign an Insert-molecule to a variable in order to re-use it as a temple to insert data with various inputs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Define Insert-molecule
val insertPerson = Person.firstName.lastName.age.insert

// Re-use Insert-molecule by aplying different (type-inferred) data sets
insertPerson(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;, 33)
insertPerson(&amp;quot;Lisa&amp;quot;, &amp;quot;Tux&amp;quot;, 27)
// etc...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes it easy to insert similar data sets.&lt;/p&gt;

&lt;h3 id=&#34;optional-values-null-values:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Optional values (&amp;ldquo;Null values&amp;rdquo;)&lt;/h3&gt;

&lt;p&gt;We might have some &amp;ldquo;rows&amp;rdquo; (tuples) of imported data with an optional attribute
value. If for instance some row has no &lt;code&gt;orgtype&lt;/code&gt; value in the data set, we can
just use &lt;code&gt;None&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community4&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;blog&amp;quot;, None, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName4&amp;quot;, &amp;quot;DistName4&amp;quot;, &amp;quot;ne&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(we need to type-cast it for the implicits to resolve correctly)&lt;/p&gt;

&lt;h4 id=&#34;difference-to-sql:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Difference to SQL&lt;/h4&gt;

&lt;p&gt;In an sql table we would have inserted a null value for such column. But with
Molecule/Datomic we just simply &lt;em&gt;don&amp;rsquo;t assert&lt;/em&gt; any &lt;code&gt;orgtype&lt;/code&gt; value for that
entity at all! In other words: there is no &lt;code&gt;orgtype&lt;/code&gt; fact to be saved.&lt;/p&gt;

&lt;h3 id=&#34;type-safety:5d2f56cd52c8a21b161ac814c57bbeef&#34;&gt;Type safety&lt;/h3&gt;

&lt;p&gt;In this example we have only inserted text strings. But all input is type
checked against the selected attributes of the molecule which makes the
insert operation type safe.&lt;/p&gt;

&lt;p&gt;We even infer the expected type so that our
IDE will bark if it finds for instance an Integer somewhere in our input data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;  (&amp;quot;community2&amp;quot;, &amp;quot;url2&amp;quot;, &amp;quot;type2&amp;quot;, 42, Set(&amp;quot;cat3&amp;quot;, &amp;quot;cat1&amp;quot;), &amp;quot;NbhName2&amp;quot;, &amp;quot;DistName2&amp;quot;, &amp;quot;DistReg2&amp;quot;), // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A data set having the value &lt;code&gt;42&lt;/code&gt; as a value for the &lt;code&gt;orgtype&lt;/code&gt; attribute
woudn&amp;rsquo;t compile and our IDE will infer that and warn us of an invalid data set.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parameterize</title>
      <link>http://localhost:1313/manual/query/parameterize/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/query/parameterize/</guid>
      <description>

&lt;h1 id=&#34;parameterized-input-molecules:913d405893862d6b41d1b084193fb4f6&#34;&gt;Parameterized Input-molecules&lt;/h1&gt;

&lt;p&gt;(See &lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/attr/Input.scala&#34;&gt;parameterize tests&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Basically we can parameterize any molecule. Instead of a value we apply the placeholder &lt;code&gt;?&lt;/code&gt; as a value.
This signals to Molecule that we intend to supply a value later as input.&lt;/p&gt;

&lt;p&gt;By assigning parameterized &amp;ldquo;Input-molecules&amp;rdquo; to variables we can re-use those variables to query for
similar data structures where only some data part varies:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// 1 input parameter
val person = m(Person.name(?))

val john = person(&amp;quot;John&amp;quot;).get.head
val lisa = person(&amp;quot;Lisa&amp;quot;).get.head
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course more complex molecules would benefit even more from this approach.&lt;/p&gt;

&lt;h3 id=&#34;datomic-cache-and-optimization:913d405893862d6b41d1b084193fb4f6&#34;&gt;Datomic cache and optimization&lt;/h3&gt;

&lt;p&gt;Datomic will cache and optimize the queries from such Input-molecules. This gives us an additional
reason to use them.&lt;/p&gt;

&lt;h3 id=&#34;parameterized-expressions:913d405893862d6b41d1b084193fb4f6&#34;&gt;Parameterized expressions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val personName  = m(Person.name.(?))
val johnOrLisas = personName(&amp;quot;John&amp;quot; or &amp;quot;Lisa&amp;quot;).get // OR
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;multiple-parameters:913d405893862d6b41d1b084193fb4f6&#34;&gt;Multiple parameters&lt;/h3&gt;

&lt;p&gt;Molecules can have up to 3 &lt;code&gt;?&lt;/code&gt; placeholder parameters. Since we can apply expressions and logic to
them it seems likely that this will satisfy the majority of all parameterized queires.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val person      = m(Person.name(?).age(?))
val john        = person(&amp;quot;John&amp;quot; and 42).get.head // AND
val johnOrJonas = person((&amp;quot;John&amp;quot; and 42) or (&amp;quot;Jonas&amp;quot; and 38)).get // AND/OR
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mix-parameterized-and-static-expressions:913d405893862d6b41d1b084193fb4f6&#34;&gt;Mix parameterized and static expressions&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val americansYoungerThan = m(Person.name.age.&amp;lt;(?).Country.name(&amp;quot;USA&amp;quot;))
val americanKids         = americansYoungerThan(13).get
val americanBabies       = americansYoungerThan(1).get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more examples, please see the
&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/seattle/SeattleTests.scala&#34;&gt;Seattle examples&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Update/retract</title>
      <link>http://localhost:1313/manual/update/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/update/</guid>
      <description>

&lt;h1 id=&#34;update-retract-data:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Update/retract data&lt;/h1&gt;

&lt;h3 id=&#34;update:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Update&lt;/h3&gt;

&lt;p&gt;An &amp;ldquo;update&amp;rdquo; is a two-step process in Datomic:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Retract old fact&lt;/li&gt;
&lt;li&gt;Assert new fact&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Datomic doesn&amp;rsquo;t overwrite data. &amp;ldquo;Retract&amp;rdquo; is a statement that says &amp;ldquo;this data is no longer current&amp;rdquo; which means that it won&amp;rsquo;t turn up when you query for it &lt;em&gt;as of now&lt;/em&gt;. If you query for it &lt;em&gt;as of before&lt;/em&gt; you will see it!&lt;/p&gt;

&lt;p&gt;Being able to see how data develops over time is a brillant core feature of Datomic. We don&amp;rsquo;t need to administrate cumbersome historial changes manually. It&amp;rsquo;s all built in to Datomic.&lt;/p&gt;

&lt;h3 id=&#34;entities-are-updated:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Entities are updated&lt;/h3&gt;

&lt;p&gt;We need an entity id to update data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Grap entity id of the Belltown community
val belltownId = Community.e.name_(&amp;quot;belltown&amp;quot;).get.head

// Update name of the Belltown entity
Community(belltownId).name(&amp;quot;Belltown 2&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule uses the belltown id to&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;find the current &lt;code&gt;name&lt;/code&gt; value (&amp;ldquo;Belltown&amp;rdquo;) and retract that value&lt;/li&gt;
&lt;li&gt;assert the new &lt;code&gt;name&lt;/code&gt; value &amp;ldquo;Belltown 2&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;cardinality-many-values:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Cardinality-many values&lt;/h3&gt;

&lt;h4 id=&#34;updating:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Updating&lt;/h4&gt;

&lt;p&gt;Cardinality-many attributes have sets of values so we need to specify which of those values we want to update:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Cardinality-many attribute value updated
Community(belltownId).category(&amp;quot;news&amp;quot; -&amp;gt; &amp;quot;Cool news&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we tell that the &amp;ldquo;news&amp;rdquo; value should change to &amp;ldquo;Cool news&amp;rdquo;. As before the old value is retracted and the new value asserted so that we can go back in time and see what the values were before our update.&lt;/p&gt;

&lt;p&gt;We can update several values in one go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category(
  &amp;quot;Cool news&amp;quot; -&amp;gt; &amp;quot;Super cool news&amp;quot;,
  &amp;quot;events&amp;quot; -&amp;gt; &amp;quot;Super cool events&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;adding:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Adding&lt;/h4&gt;

&lt;p&gt;To add a value to the set of values a cardinality-many attriute can have we &lt;code&gt;add&lt;/code&gt; the value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category.add(&amp;quot;extra category&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;removing:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Removing&lt;/h4&gt;

&lt;p&gt;We can remove a specific value from a set of values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category.remove(&amp;quot;extra category&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;retract-attribute-value-s:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Retract attribute value(s)&lt;/h3&gt;

&lt;p&gt;Applying nothing (empty parenthesises) finds and retract all values of an attribute&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).name().category().update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that all values of a cardinality many attribute are retracted this way.&lt;/p&gt;

&lt;h3 id=&#34;retract-whole-entities:02280df5f63dd13cb1a7e40384d029f1&#34;&gt;Retract whole entities&lt;/h3&gt;

&lt;p&gt;To delete a whole entity with all its attribute values we call &lt;code&gt;retract&lt;/code&gt; on an entity id&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;belltownId.retract
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Query</title>
      <link>http://localhost:1313/manual/query/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/query/</guid>
      <description>

&lt;h1 id=&#34;molecule-queries:f7a7255cb61c59dcad3a015980d2faca&#34;&gt;Molecule Queries&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/manual/query/builder&#34;&gt;Building molecules&lt;/a&gt; with the builder pattern
(&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/attr/Attribute.scala&#34;&gt;tests&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.age.gender  // require values
Person.name.age_.gender // require but omit values (&amp;quot;tacet values&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/manual/query/mapped&#34;&gt;Maped values&lt;/a&gt; - mapped attribute values
(&lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/coretest/src/test/scala/molecule/attrMap&#34;&gt;tests&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.id.name.one === (
  1, 
  Map(
    &amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;,
    &amp;quot;de&amp;quot; -&amp;gt; &amp;quot;Dmitri Schostakowitsch&amp;quot;,
    &amp;quot;fr&amp;quot; -&amp;gt; &amp;quot;Dmitri Chostakovitch&amp;quot;,
    &amp;quot;es&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakóvich&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/manual/query/expressions&#34;&gt;Expressions&lt;/a&gt; - filter attribute values with expressions
(&lt;a href=&#34;https://github.com/scalamolecule/molecule/tree/master/coretest/src/test/scala/molecule/expression&#34;&gt;tests&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(42)                  // equal value
Person.age.!=(42)               // negate values
Person.age.&amp;lt;(42)                // compare values
Person.age.&amp;gt;(42)                // compare values
Person.age.&amp;lt;=(42)               // compare values
Person.age.&amp;gt;=(42)               // compare values
Person.name.contains(&amp;quot;John&amp;quot;)    // fulltext search
Person.name(&amp;quot;John&amp;quot; or &amp;quot;Jonas&amp;quot;)  // OR-logic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/manual/query/aggregates&#34;&gt;Aggregates&lt;/a&gt; - aggregate attribute values
(&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/dayOfDatomic/Aggregates.scala&#34;&gt;tests&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(min) 
Person.age(max) 
// rand, sample, count, countDistinct, sum, avg, median, variance, stddev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/manual/query/parameterize&#34;&gt;Parameterize&lt;/a&gt; - re-use molecules and let Datomic cache queries and optimize performance
(&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/attr/Input.scala&#34;&gt;tests&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val person = Person.name(?).age(?)

// Re-use `person`
val Johan  = person(&amp;quot;John&amp;quot;, 33).one
val Lisa   = person(&amp;quot;Lisa&amp;quot;, 27).one
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/manual/query/relationships&#34;&gt;Relationships&lt;/a&gt; - Connect namespaces with
(&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/ref&#34;&gt;tests&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.City.name.Country.name
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Relationships</title>
      <link>http://localhost:1313/manual/query/relationships/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/query/relationships/</guid>
      <description>

&lt;h1 id=&#34;relationships:c826c531212d0a54ebca2cc2d2da67b7&#34;&gt;Relationships&lt;/h1&gt;

&lt;p&gt;(See &lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/ref&#34;&gt;relationship tests&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Relationships are modelled in Molecule as &amp;ldquo;references between namespaces&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s not that namespaces automatically become entities referencing each other but rather that referenced entities will likely pick attributes from a certain namespace.&lt;/p&gt;

&lt;h3 id=&#34;one-to-one:c826c531212d0a54ebca2cc2d2da67b7&#34;&gt;One-to-One&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;Person&lt;/code&gt; could have a cardinality-one reference to &lt;code&gt;City&lt;/code&gt; having a cardinality-one reference to a &lt;code&gt;Country&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.City.name.Country.name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Strictly speaking we have an entity with an asserted &lt;code&gt;:person/name&lt;/code&gt; attribute value with a reference to another entity with an asserted &lt;code&gt;:city/name&lt;/code&gt; attribute value etc. But in practice we simply talk about &amp;ldquo;namespace A has a relationship/reference to namespace B&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A namespace is not like an SQL Table but rather organizes some attributes by a meaningful name - it&amp;rsquo;s, well, a &lt;em&gt;namespace&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;one-many-to-many:c826c531212d0a54ebca2cc2d2da67b7&#34;&gt;One/Many-to-Many&lt;/h3&gt;

&lt;p&gt;If we have an &lt;code&gt;Order&lt;/code&gt; with multiple &lt;code&gt;OrderLine&lt;/code&gt;s we would instead define a cardinality-many reference to the &lt;code&gt;OrderLine&lt;/code&gt; namespace in our Schema definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val orderLines = many[OrderLine]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would cause Molecule to generate boilerplate code that would allow us to for instance insert multiple products for an order in one go:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m(Order.id.LineItems * LineItem.product.price.quantity).insert(
  (&amp;quot;order1&amp;quot;, List((chocolateId, 48.00, 1), (whiskyId, 38.00, 2)))
  (&amp;quot;order2&amp;quot;, List((bread, 13.00, 4)))  
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then fetch the nested data&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m(Order.id.LineItems * LineItem.product.price.quantity).get === List(
  (&amp;quot;order1&amp;quot;, List((chocolateId, 48.00, 1), (whiskyId, 38.00, 2)))
  (&amp;quot;order2&amp;quot;, List((bread, 13.00, 4)))  
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The nested data structures can be arbitrarily deep (currently max 10 levels deep - can be expanded though if needed):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m(Order.orderid.LineItems * (LineItem.quantity.price.Comments * Comment.text.descr)).get === List(
  (23, List(
    (1, 48.00, List(
      (&amp;quot;first&amp;quot;, &amp;quot;1a&amp;quot;),
      (&amp;quot;product&amp;quot;, &amp;quot;1b&amp;quot;))),
    (2, 38.00, List(
      (&amp;quot;second&amp;quot;, &amp;quot;2b&amp;quot;),
      (&amp;quot;is&amp;quot;, &amp;quot;2b&amp;quot;),
      (&amp;quot;best&amp;quot;, &amp;quot;2c&amp;quot;)))
  ))
)
// etc...
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Bidirectional refs</title>
      <link>http://localhost:1313/manual/query/bidirectional%20refs/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 &#43;0100</pubDate>
      
      <guid>http://localhost:1313/manual/query/bidirectional%20refs/</guid>
      <description>

&lt;h1 id=&#34;bidirectional-references:202abaea8dbead8f4e14657c1559cf69&#34;&gt;Bidirectional references&lt;/h1&gt;

&lt;p&gt;(See &lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/bidirectional/&#34;&gt;bidirectional tests&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&#34;unidirectional-reference-limitations:202abaea8dbead8f4e14657c1559cf69&#34;&gt;Unidirectional reference limitations&lt;/h3&gt;

&lt;p&gt;Normal Datomic references are unidirectional. If we add a friend reference from Ann to Ben&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name(&amp;quot;Ann&amp;quot;).Friends.name(&amp;quot;Ben&amp;quot;).save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can naturally query to get friends of Ann&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name_(&amp;quot;Ann&amp;quot;).Friends.name.get === List(&amp;quot;Ben&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But what if we want to find friends of Ben? This will give us nothing since our reference only went from Ann to Ben:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name_(&amp;quot;Ben&amp;quot;).Friends.name.get === List()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead we would have to think backwards to get the back reference &amp;ldquo;who referenced Ben?&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt; Person.name.Friends.name_(&amp;quot;Ben&amp;quot;).get === List(&amp;quot;Ann&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we can&amp;rsquo;t know from which person a friendship reference is made we will always have to query
separately in both directions. If we were to traverse say 3 levels into a friendship graph we would end
 up with 6 queries - one in each direction for all three levels. It can quickly become a pain.&lt;/p&gt;

&lt;h3 id=&#34;bidirectional-refs-to-the-rescue:202abaea8dbead8f4e14657c1559cf69&#34;&gt;Bidirectional refs to the rescue&amp;hellip;&lt;/h3&gt;

&lt;p&gt;By defining a relationship in Molecule as bidirectional:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val friends = manyBi[Person]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can start treating friendship relationships uniformly in both directions and get the intuitively
expected results&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt; Person.name_(&amp;quot;Ann&amp;quot;).Friends.name.get === List(&amp;quot;Ben&amp;quot;)
 Person.name_(&amp;quot;Ben&amp;quot;).Friends.name.get === List(&amp;quot;Ann&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the graph example becomes easy&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt; Person.name_(&amp;quot;Ann&amp;quot;).Friends.Friends.Friends.name.get === List(...)
 
 // Or without recycling to Ann
 Person.name_(&amp;quot;Ann&amp;quot;).Friends.Friends.name_.not(&amp;quot;Ann&amp;quot;).Friends.name.not(&amp;quot;Ann&amp;quot;).get === List(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;direct-bidirectional-refs:202abaea8dbead8f4e14657c1559cf69&#34;&gt;Direct bidirectional refs&lt;/h2&gt;

&lt;p&gt;Single direct references to another entity can either go to the same namespace or to another namespace:&lt;/p&gt;

&lt;h3 id=&#34;a-a:202abaea8dbead8f4e14657c1559cf69&#34;&gt;A &amp;lt;&amp;mdash;&amp;gt; A&lt;/h3&gt;

&lt;p&gt;The friendship reference we saw above is a classic &amp;ldquo;self-reference&amp;rdquo; in that it&amp;rsquo;s a cardinality-many relationship
between same-kinds: Persons.&lt;/p&gt;

&lt;p&gt;A cardinality-one example would be&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val spouse = oneBi[Person]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where the relationship goes in both directions but only between two persons. If Ann is spouse to Ben, then Ben
is also spouse to Ann and we want to be able to query that information uniformly in both directions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt; Person.name_(&amp;quot;Ann&amp;quot;).Spouse.name.get === List(&amp;quot;Ben&amp;quot;)
 Person.name_(&amp;quot;Ben&amp;quot;).Spouse.name.get === List(&amp;quot;Ann&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-b:202abaea8dbead8f4e14657c1559cf69&#34;&gt;A &amp;lt;&amp;mdash;&amp;gt; B&lt;/h3&gt;

&lt;p&gt;In a zoo we could (admittedly a bit contrively) say that the caretakers are buddies with the animals they take care of,
and reversely the caretakers would be &amp;ldquo;buddies&amp;rdquo; of the animals. We define such bidirectional relationship with a
reference from each namespace to the other:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Person extends Person
trait Person {
  val buddies = manyBi[Animal.buddies.type]
  
  val name = oneString
}

object Animal extends Animal
trait Animal {
  val buddies = manyBi[Person.buddies.type]
  
  val name = oneString
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each &lt;code&gt;manyBi&lt;/code&gt; reference definition takes a type parameter that points back to the other definition. This is so that
 Molecule can keep track of the references back and forth.&lt;/p&gt;

&lt;p&gt;As with friends we can now query uniformly no matter from which end the reference was entered:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt; Person.name_(&amp;quot;Joe&amp;quot;).Buddies.name.get === List(&amp;quot;Leo&amp;quot;, &amp;quot;Gus&amp;quot;)
 Animal.name_(&amp;quot;Leo&amp;quot;).Buddies.name.get === List(&amp;quot;Joe&amp;quot;)
 Animal.name_(&amp;quot;Gus&amp;quot;).Buddies.name.get === List(&amp;quot;Joe&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting aspect is that we can give the reference attributes different names on each end. Say Persons have 1 Pet
and we model that as a bidirectional cardinality-one reference:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;object Person extends Person
trait Person {
  val pet = oneBi[Animal.master.type]
  
  val name = oneString
}

object Animal extends Animal
trait Animal {
  val master = oneBi[Person.pet.type]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we then enter a pet ownership&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name(&amp;quot;Liz&amp;quot;).Pet.name(&amp;quot;Rex&amp;quot;).save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we can get access to that information uniformly from both ends even though different attribute names are used:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt; Person.name_(&amp;quot;Liz&amp;quot;).Pet.name.get === List(&amp;quot;Rex&amp;quot;)
 Animal.name_(&amp;quot;Rex&amp;quot;).Master.name.get === List(&amp;quot;Liz&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;property-edges:202abaea8dbead8f4e14657c1559cf69&#34;&gt;Property edges&lt;/h2&gt;

&lt;p&gt;Taking bidirectionality to the next level involves &amp;ldquo;property edges&amp;rdquo;, a term taken from graph theory where an edge/relationship
between two vertices/entities has some property values attached to it. Molecule models this by using a bidirectional reference between one entity
and a (property edge) entity, and then between this property edge entity and another entity.&lt;/p&gt;

&lt;p&gt;This is actually what we do all the time with references except that they are normally unidirectional! In order to make them bidirectional
Molecule offers a convenient solution:&lt;/p&gt;

&lt;h3 id=&#34;a-edge-properties-a:202abaea8dbead8f4e14657c1559cf69&#34;&gt;A &amp;lt;&amp;mdash;&amp;gt; Edge.properties&amp;hellip; &amp;lt;&amp;mdash;&amp;gt; A&lt;/h3&gt;

&lt;p&gt;If we want to express &amp;ldquo;how well&amp;rdquo; two persons know each other we could model the above friendship example instead with at property edge
having a &lt;code&gt;weight&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Entity
object Person extends Person
trait Person {
  // A ==&amp;gt; edge -- a
  val knows = manyBiEdge[Knows.person.type]
  
  val name = oneString
}

// Property edge
object Knows extends Knows
trait Knows {
  // a --- edge ==&amp;gt; a
  val person: AnyRef = target[Person.knows.type]
  
  // Property
  val weight = oneInt
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we use the &lt;code&gt;manyBiEdge&lt;/code&gt; definition that takes a type parameter pointing to the reference in the edge namespace that points back here. In the
edge namespace we define the reference back with the &lt;code&gt;target&lt;/code&gt; definition.&lt;/p&gt;

&lt;p&gt;Now we can add some weighed friendships:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.Knows.*(Knows.weight.Person.name).insert(&amp;quot;Ann&amp;quot;, List((7, &amp;quot;Ben&amp;quot;), (8, &amp;quot;Joe&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And uniformly retrieve that information from any end:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name_(&amp;quot;Ann&amp;quot;).Knows.*(Knows.weight.Person.name).get.head === List((7, &amp;quot;Ben&amp;quot;), (8, &amp;quot;Joe&amp;quot;))
Person.name_(&amp;quot;Ben&amp;quot;).Knows.*(Knows.weight.Person.name).get.head === List((7, &amp;quot;Ann&amp;quot;))
Person.name_(&amp;quot;Joe&amp;quot;).Knows.*(Knows.weight.Person.name).get.head === List((8, &amp;quot;Ann&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-edge-properties-b:202abaea8dbead8f4e14657c1559cf69&#34;&gt;A &amp;lt;&amp;mdash;&amp;gt; Edge.properties&amp;hellip; &amp;lt;&amp;mdash;&amp;gt; B&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s add weight to the relationships between caretakers and animals. The edge namespace now has to reference both the Person and Animal
namespaces:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Entity A
object Person extends Person
trait Person {
  // Ref to edge
  // A ==&amp;gt; edge -- b
  val closeTo = manyBiEdge[CloseTo.animal.type]
  
  val name = oneString
}

// Property edge
object CloseTo extends CloseTo
trait CloseTo {
  // Ref to Person
  // a &amp;lt;== edge --- b
  val person: AnyRef = target[Person.closeTo.type]
  
  // Ref to Animal
  // a --- edge ==&amp;gt; b
  val animal: AnyRef = target[Animal.closeTo.type]
  
  // Property
  val weight = oneInt
}

// Entity B
object Animal extends Animal
trait Animal {
  // Ref to edge
  // a -- edge &amp;lt;== B
  val closeTo  = manyBiEdge[CloseTo.person.type]
  
  val name = oneString
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding data from one end (we could as well have done it from the Animal end)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.CloseTo.*(CloseTo.weight.Animal.name) insert List((&amp;quot;Joe&amp;quot;, List((7, &amp;quot;Gus&amp;quot;), (6, &amp;quot;Leo&amp;quot;))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now uniformly retrieve the weighed friendship information from any end:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Querying from Person
Person.name_(&amp;quot;Joe&amp;quot;).CloseTo.*(CloseTo.weight.Animal.name).get.head === List((7, &amp;quot;Gus&amp;quot;), (8, &amp;quot;Leo&amp;quot;))

// Querying from Animal
Animal.name_(&amp;quot;Gus&amp;quot;).CloseTo.*(CloseTo.weight.Person.name).get.head === List((7, &amp;quot;Joe&amp;quot;))
Animal.name_(&amp;quot;Leo&amp;quot;).CloseTo.*(CloseTo.weight.Person.name).get.head === List((8, &amp;quot;Joe&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;how-it-works:202abaea8dbead8f4e14657c1559cf69&#34;&gt;How it works&lt;/h3&gt;

&lt;p&gt;For each bidirectional reference created, Molecule creates a reverse reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ann --&amp;gt; Ben
Ben &amp;lt;-- Ann // reverse ref
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and for edges a full reverse edge entity with properties is created:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ann --&amp;gt; annLovesBen (7) --&amp;gt;  Ben
  \                         /
    &amp;lt;-- benLovesAnn (7) &amp;lt;--       // reverse edge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since Molecule is a closed eco-system it can manage this redundancy with 100% control. The advantages
of uniform queries should easily outweigh the impact of a bit of additional information for the reverse references.&lt;/p&gt;

&lt;h3 id=&#34;more-exampes:202abaea8dbead8f4e14657c1559cf69&#34;&gt;More exampes&amp;hellip;&lt;/h3&gt;

&lt;p&gt;Please have a look at the implementation of the
&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/gremlin/gettingStarted/&#34;&gt;Gremlin graph&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tx meta data</title>
      <link>http://localhost:1313/manual/query/txMetaData/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 CET</pubDate>
      
      <guid>http://localhost:1313/manual/query/txMetaData/</guid>
      <description>

&lt;h1 id=&#34;transaction-meta-data:8a55762a4668cbf851db116d659c13a7&#34;&gt;Transaction meta data&lt;/h1&gt;

&lt;p&gt;Transaction data in Datomic is basically a list of facts/datoms being asserted or retracted. If we take the
&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/dayOfDatomic/Provenance.scala&#34;&gt;Provenance&lt;/a&gt;
example we could add two Story entities each with two datoms (&lt;code&gt;title&lt;/code&gt; and &lt;code&gt;url&lt;/code&gt;) with this molecule:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Story.title.url insert List(
  (&amp;quot;ElastiCache in 6 minutes&amp;quot;, &amp;quot;blog.com/elasticache-in-5-minutes.html&amp;quot;),
  (&amp;quot;Keep Chocolate Love Atomic&amp;quot;, &amp;quot;blog.com/atomic-chocolate.html&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule translate this to a transaction list of 4 datoms:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  //  operation            entity id               attribute             value  
  List(:db/add,  #db/id[:db.part/user -1000001],  :story/title,  ElastiCache in 6 minutes              ),
  List(:db/add,  #db/id[:db.part/user -1000001],  :story/url  ,  blog.com/elasticache-in-5-minutes.html),
  List(:db/add,  #db/id[:db.part/user -1000002],  :story/title,  Keep Chocolate Love Atomic            ),
  List(:db/add,  #db/id[:db.part/user -1000002],  :story/url  ,  blog.com/atomic-chocolate.html        )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each Datom has 4 - and soon 5 - pieces of information:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entity id&lt;/li&gt;
&lt;li&gt;Attribute&lt;/li&gt;
&lt;li&gt;Value&lt;/li&gt;
&lt;li&gt;Tx&lt;/li&gt;
&lt;li&gt;Operation (add/retract)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Molecule simply passes our list to be transacted by Datomic. Datomic then creates a transaction entity and makes
 the association between all the datoms and this transaction id (the Tx part).&lt;/p&gt;

&lt;h2 id=&#34;annotating-a-transaction:8a55762a4668cbf851db116d659c13a7&#34;&gt;&amp;ldquo;Annotating&amp;rdquo; a transaction&lt;/h2&gt;

&lt;p&gt;If we want to &amp;ldquo;annotate&amp;rdquo; a transaction with some meta data like &amp;ldquo;who did it?&amp;rdquo; or &amp;ldquo;what use case?&amp;rdquo; etc, we could
simply add two more datoms to our list with this meta data. We don&amp;rsquo;t want to repeatedly add the meta data with
all the rows of data, so we use the special &lt;code&gt;tx_&lt;/code&gt; attribute that is available to all molecules and apply another
Molecule populated with our meta data. So now our &amp;ldquo;tx-annotated&amp;rdquo; molecule looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Story.title.url.tx_(MetaData.user_(stu).usecase_(&amp;quot;AddStories&amp;quot;)) insert List(
  (&amp;quot;ElastiCache in 6 minutes&amp;quot;, &amp;quot;blog.com/elasticache-in-5-minutes.html&amp;quot;),
  (&amp;quot;Keep Chocolate Love Atomic&amp;quot;, &amp;quot;blog.com/atomic-chocolate.html&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The insert data now includes two more datoms that are saved as part of the transaction entity:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  //  operation            entity id               attribute             value  
  List(:db/add,  #db/id[:db.part/user -1000001],  :story/title,      ElastiCache in 6 minutes              ),
  List(:db/add,  #db/id[:db.part/user -1000001],  :story/url  ,      blog.com/elasticache-in-5-minutes.html),
  List(:db/add,  #db/id[:db.part/user -1000002],  :story/title,      Keep Chocolate Love Atomic            ),
  List(:db/add,  #db/id[:db.part/user -1000002],  :story/url  ,      blog.com/atomic-chocolate.html        ),
  List(:db/add,  #db/id[:db.part/tx -1000049],    :metaData/user   , 17592186045423                        ),
  List(:db/add,  #db/id[:db.part/tx -1000049],    :metaData/usecase, AddStories                            )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;querying-transaction-meta-data:8a55762a4668cbf851db116d659c13a7&#34;&gt;Querying transaction meta data&lt;/h2&gt;

&lt;p&gt;Now we can find stories based on our transaction meta data knowledge:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Stories that Stu added (first meta information used)
Story.title.tx_(MetaData.user_(stu)).get === List(
  &amp;quot;Keep Chocolate Love Atomic&amp;quot;,
  &amp;quot;ElastiCache in 6 minutes&amp;quot;
)

// Stories that were added with the AddStories use case (second meta information used)
Story.title.tx_(MetaData.usecase_(&amp;quot;AddStories&amp;quot;)).get === List(
  &amp;quot;Keep Chocolate Love Atomic&amp;quot;,
  &amp;quot;ElastiCache in 6 minutes&amp;quot;
)

// Stories that Stu added with the AddStories use case (both meta data used)
Story.title.tx_(MetaData.user_(stu).usecase_(&amp;quot;AddStories&amp;quot;)).get === List(
  &amp;quot;Keep Chocolate Love Atomic&amp;quot;,
  &amp;quot;ElastiCache in 6 minutes&amp;quot;
)

// Stories and transactions where Stu added stories (`tx` is returned)
Story.title.tx(MetaData.user_(stu).usecase_(&amp;quot;AddStories&amp;quot;)).get === List(
  (&amp;quot;ElastiCache in 6 minutes&amp;quot;, stuTxId),
  (&amp;quot;Keep Chocolate Love Atomic&amp;quot;, stuTxId)
)

// Stories and names of who added them (Note that we can have referenced meta data!)
Story.title.tx_(MetaData.User.firstName.lastName).get === List(
  (&amp;quot;ElastiCache in 6 minutes&amp;quot;, &amp;quot;Stu&amp;quot;, &amp;quot;Halloway&amp;quot;),
  (&amp;quot;Keep Chocolate Love Atomic&amp;quot;, &amp;quot;Stu&amp;quot;, &amp;quot;Halloway&amp;quot;)
)

// Stories added by a user named &amp;quot;Stu&amp;quot;
Story.title.tx_(MetaData.User.firstName_(&amp;quot;Stu&amp;quot;)).get === List(
  &amp;quot;ElastiCache in 6 minutes&amp;quot;,
  &amp;quot;Keep Chocolate Love Atomic&amp;quot;
)

// Stories added by a user with email &amp;quot;stuarthalloway@datomic.com&amp;quot;
Story.title.tx_(MetaData.User.email_(&amp;quot;stuarthalloway@datomic.com&amp;quot;)).get === List(
  &amp;quot;ElastiCache in 6 minutes&amp;quot;,
  &amp;quot;Keep Chocolate Love Atomic&amp;quot;
)

// Count of stories added by a user with email &amp;quot;stuarthalloway@datomic.com&amp;quot;
Story.title(count).tx_(MetaData.User.email_(&amp;quot;stuarthalloway@datomic.com&amp;quot;)).get.head === 2

// Emails of users who added stories
Story.title_.tx_(MetaData.usecase_(&amp;quot;AddStories&amp;quot;).User.email).get === List(
  &amp;quot;stuarthalloway@datomic.com&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;transaction-history:8a55762a4668cbf851db116d659c13a7&#34;&gt;Transaction history&lt;/h2&gt;

&lt;p&gt;We can also annotate updates like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Story(elasticacheStory).title(&amp;quot;ElastiCache in 5 minutes&amp;quot;)
  .tx_(MetaData.user(ed).usecase_(&amp;quot;UpdateStory&amp;quot;)).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then use the &lt;code&gt;history&lt;/code&gt; of the database in combination with out meta data to follow who
created/updated:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Story.url_(ecURL).title.op.tx_(MetaData.usecase.User.firstName).history.get.reverse === List(
  (&amp;quot;ElastiCache in 6 minutes&amp;quot;, true, &amp;quot;AddStories&amp;quot;, &amp;quot;Stu&amp;quot;),  // Stu adds the story
  (&amp;quot;ElastiCache in 6 minutes&amp;quot;, false, &amp;quot;UpdateStory&amp;quot;, &amp;quot;Ed&amp;quot;), // retraction automatically added by Datomic
  (&amp;quot;ElastiCache in 5 minutes&amp;quot;, true, &amp;quot;UpdateStory&amp;quot;, &amp;quot;Ed&amp;quot;)   // Ed&#39;s update of the title
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a new fact is asserted for a cardinality-one attribute that already has a value, Datomic
automatically makes an extra datom with a retraction (&lt;code&gt;op false&lt;/code&gt;) to &amp;ldquo;cancel&amp;rdquo; the old value and
then adds our assertion datom.&lt;/p&gt;

&lt;p&gt;The current database is the latest snapshot of the history, so the ElastiCache now has the correct
title. We can therefore see if stories have been edited:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Stories with latest use case meta date
Story.title.tx_(MetaData.usecase).get === List(
  (&amp;quot;Keep Chocolate Love Atomic&amp;quot;, &amp;quot;AddStories&amp;quot;),
  (&amp;quot;ElastiCache in 5 minutes&amp;quot;, &amp;quot;UpdateStory&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can even look for data without certain transaction meta data&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Stories without use case meta data
Story.title.tx_(MetaData.usecase_(nil)).get === List(
  &amp;quot;Clojure Rationale&amp;quot;,
  &amp;quot;Beating the Averages&amp;quot;,
  &amp;quot;Teach Yourself Programming in Ten Years&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See also &lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/coretest/src/test/scala/molecule/transaction/TransactionMetaData.scala&#34;&gt;core tests&amp;hellip;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>