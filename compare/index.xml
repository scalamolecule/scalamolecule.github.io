<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compares on Molecule</title>
    <link>http://scalamolecule.org/compare/</link>
    <description>Recent content in Compares on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
    
    <lastBuildDate>Wed, 14 May 2014 02:13:50 UTC</lastBuildDate>
    <atom:link href="http://scalamolecule.org/compare/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Compare</title>
      <link>http://scalamolecule.org/compare/overview/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 UTC</pubDate>
      
      <guid>http://scalamolecule.org/compare/overview/</guid>
      <description>

&lt;h1 id=&#34;other-databases-vs-molecule:68f80267fa3a50980dbb745a782b8dca&#34;&gt;Other databases vs. Molecule&lt;/h1&gt;

&lt;p&gt;Every database/abstraction layer has its strengths and weaknesses and we&amp;rsquo;ll try here to compare existing systems with Molecule with some examples of how they accomplish similar tasks.&lt;/p&gt;

&lt;h3 id=&#34;others-consume-molecule-declares-data-structures:68f80267fa3a50980dbb745a782b8dca&#34;&gt;Others &lt;em&gt;consume&lt;/em&gt;, Molecule &lt;em&gt;declares&lt;/em&gt; data structures&lt;/h3&gt;

&lt;p&gt;Many systems lets you define data objects matching your domain that are then &lt;em&gt;consumed&lt;/em&gt; by the host language (Scala) in combination with DSLs.&lt;/p&gt;

&lt;p&gt;If we take &lt;a href=&#34;http://slick.typesafe.com/doc/3.0.0-M1/queries.html#joining-and-zipping&#34;&gt;Slick&lt;/a&gt; for instance we could say that it &amp;ldquo;&lt;em&gt;consumes&lt;/em&gt;&amp;rdquo; the data objects &lt;code&gt;coffees&lt;/code&gt; and &lt;code&gt;suppliers&lt;/code&gt; in this Scala sequence comprehension:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Slick
val implCrossJoin = for {
  c &amp;lt;- coffees
  s &amp;lt;- suppliers
} yield (c.name, s.name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas in Molecule, we only &lt;em&gt;declare&lt;/em&gt; which attributes we are interested in. Molecule attributes &lt;em&gt;themselves&lt;/em&gt; form the query - they are not &lt;em&gt;consumed&lt;/em&gt; by an outer construct. That way, the domain terms directly form the query without additional keywords and constructs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Molecule
val coffeeSupliers = Coffees.name.Suppliers.name.get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get the exact same type-inferred result back, a &lt;code&gt;Iterable[(String, String)]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://squeryl.org/selects.html&#34;&gt;Squeryl&lt;/a&gt; also &lt;em&gt;consumes&lt;/em&gt; data objects, now in a DSL construct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Squeryl
def songs = from(MusicDb.songs)(s =&amp;gt; where(s.artistId === id) select(s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Molecule we don&amp;rsquo;t need to use keywords like &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt; (apart from the final &lt;code&gt;get&lt;/code&gt; method). We instead get song entities (&lt;code&gt;e&lt;/code&gt;) filtered by Artist by simply applying a required value directly to the &lt;code&gt;artist&lt;/code&gt; attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Molecule
val songs = Song.e.artist(id).get
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;more-databases-to-compare:68f80267fa3a50980dbb745a782b8dca&#34;&gt;More databases to compare&amp;hellip;&lt;/h3&gt;

&lt;p&gt;Over time we&amp;rsquo;ll compare Molecule with as many database systems as possible. Those not linked yet below are on our wish list:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/compare/datomic&#34;&gt;Datomic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/compare/sql&#34;&gt;SQL&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://scalamolecule.org/compare/sql/slick&#34;&gt;Slick&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Squeryl&lt;/li&gt;
&lt;li&gt;Sqltyped tutorial&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Mongodb

&lt;ul&gt;
&lt;li&gt;Native&lt;/li&gt;
&lt;li&gt;Rogue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Titan&lt;/li&gt;
&lt;li&gt;Neo4j&lt;/li&gt;
&lt;li&gt;Gremlin&lt;/li&gt;
&lt;li&gt;More&amp;hellip;?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to translate one into Molecule, please feel free to submit a pull request or bring up ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Datomic</title>
      <link>http://scalamolecule.org/compare/datomic/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 UTC</pubDate>
      
      <guid>http://scalamolecule.org/compare/datomic/</guid>
      <description>

&lt;h1 id=&#34;compare-with-datomic-datalog:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Compare with Datomic/Datalog&lt;/h1&gt;

&lt;p&gt;Even though Molecule is adapting to Datomic we&amp;rsquo;ll have a look the other way around to see how Datomic compares to Molecule.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/scalamolecule/molecule/blob/master/examples/src/test/scala/molecule/examples/seattle/SeattleQueryTests.scala&#34;&gt;Follow along in the code&lt;/a&gt; from which we will pick a few examples based on the Seattle tutorial examples.&lt;/p&gt;

&lt;h3 id=&#34;querying-for-attribute-values:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Querying &lt;em&gt;for&lt;/em&gt; attribute values&lt;/h3&gt;

&lt;p&gt;The most basic query is to ask for entities with some attribute values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Datalog
[:find  ?b ?c (distinct ?d)
 :where [?a :community/name ?b]
        [?a :community/url ?c]
        [?a :community/category ?d]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Molecule we simply use the namespace name and add the attribute names:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Molecule
Community.name.url.category
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Datalog has a &lt;code&gt;:find&lt;/code&gt; and &lt;code&gt;:where&lt;/code&gt; section similar to &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;where&lt;/code&gt; in the SQL world. The &lt;code&gt;:find&lt;/code&gt; section defines which values to return and the where section defines one or more clauses filtering the result set.&lt;/p&gt;

&lt;p&gt;In this case we asked for the values of variable &lt;code&gt;?b&lt;/code&gt;, &lt;code&gt;?c&lt;/code&gt; and &lt;code&gt;?d&lt;/code&gt; each one bound in its where clause. With molecule we use the three attribute names all associated to the &lt;code&gt;Community&lt;/code&gt; namespace.&lt;/p&gt;

&lt;h3 id=&#34;querying-by-attribute-values:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Querying &lt;em&gt;by&lt;/em&gt; attribute values&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s query by an enumerated value for the &lt;code&gt;type&lt;/code&gt; attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :where [?a :community/name ?b]
        [?a :community/type &amp;quot;:community.type/twitter&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.type_(&amp;quot;twitter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note how we add an underscore to the &lt;code&gt;type&lt;/code&gt; attribute to tell Molecule that we want to omit returning this value in the result set (since it will have the value &amp;ldquo;twitter&amp;rdquo; for all returned entities).&lt;/p&gt;

&lt;p&gt;Since the &lt;code&gt;type&lt;/code&gt; attribute is defined as en enumeration Molecule checks the &amp;ldquo;twitter&amp;rdquo; value at &lt;em&gt;compile time&lt;/em&gt; against the defined enumeration values that we have definied in our schema for the &lt;code&gt;Community&lt;/code&gt; namespace to ensure that &amp;ldquo;twitter&amp;rdquo; is one of the enums. If it is not, our molecule won&amp;rsquo;t compile and we&amp;rsquo;ll get an error showing the available enum values.&lt;/p&gt;

&lt;p&gt;For a many-cardinality attribute like &lt;code&gt;category&lt;/code&gt; Datalog applies logical OR with Datalog rules:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :in    $ %
 :where [?a :community/name ?b]
        (rule1 ?a)]

INPUTS:
List(
  1 datomic.db.Db@xxx
  2 [[(rule1 ?a) [?a :community/category &amp;quot;news&amp;quot;]]
     [(rule1 ?a) [?a :community/category &amp;quot;arts&amp;quot;]]]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Molecule we can apply the two values either separated with &lt;code&gt;or&lt;/code&gt; or commas:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.category_(&amp;quot;news&amp;quot; or &amp;quot;arts&amp;quot;)

// Same as
Community.name.category_(&amp;quot;news&amp;quot;, &amp;quot;arts&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;querying-across-references:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Querying across references&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b ?e2
 :where [?a :community/name ?b]
        [?a :community/neighborhood ?c]
        [?c :neighborhood/district ?d]
        [?d :district/region ?e]
        [?e :db/ident ?e1]
        [(.getName ^clojure.lang.Keyword ?e1) ?e2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.Neighborhood.District.region
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parameterizing-queries:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Parameterizing queries&lt;/h3&gt;

&lt;p&gt;Community input molecule awaiting some type value&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b ?c2
 :in    $ ?c
 :where [?a :community/name ?b]
        [?a :community/type ?c]
        [?c :db/ident ?c1]
        [(.getName ^clojure.lang.Keyword ?c1) ?c2]]

INPUTS:
List(
  1 datomic.db.Db@xxx
  2 :community.type/twitter
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val communitiesOfType  = m(Community.name.type(?))
val twitterCommunities = communitiesOfType(&amp;quot;twitter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple input values for one attribute - logical OR&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b ?c2
 :in    $ ?c
 :where [?a :community/name ?b]
        [?a :community/type ?c]
        [?c :db/ident ?c1]
        [(.getName ^clojure.lang.Keyword ?c1) ?c2]]

INPUTS:
List(
  1 datomic.db.Db@xxx
  2 :community.type/twitter
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m(Community.name.`type`(?)).apply(&amp;quot;facebook_page&amp;quot; or &amp;quot;twitter&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Single tuple of input values for two attributes - logical AND&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :in    $ [[ ?c ?d ]]
 :where [?a :community/name ?b]
        [?a :community/type ?c]
        [?a :community/orgtype ?d]]

INPUTS:
List(
  1 datomic.db.Db@xxx
  2 [[:community.type/email_list, :community.orgtype/community]]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m(Community.name.type_(?).orgtype_(?))(&amp;quot;email_list&amp;quot; and &amp;quot;community&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple tuple of input values for two attributes - logical AND&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b ?c2 ?d2
 :in    $ [[ ?c ?d ]]
 :where [?a :community/name ?b]
        [?a :community/type ?c]
        [?c :db/ident ?c1]
        [(.getName ^clojure.lang.Keyword ?c1) ?c2]
        [?a :community/orgtype ?d]
        [?d :db/ident ?d1]
        [(.getName ^clojure.lang.Keyword ?d1) ?d2]]

INPUTS:
List(
  1 datomic.db.Db@xxx
  2 [[:community.type/email_list, :community.orgtype/community], 
     [:community.type/website, :community.orgtype/commercial]]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m(Community.name.`type`(?).orgtype(?))
.apply(Seq((&amp;quot;email_list&amp;quot;, &amp;quot;community&amp;quot;), (&amp;quot;website&amp;quot;, &amp;quot;commercial&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;invoking-functions-in-queries:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Invoking functions in queries&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :where [?a :community/name ?b]
        [(.compareTo ^String ?b &amp;quot;C&amp;quot;) ?b2]
        [(&amp;lt; ?b2 0)]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.&amp;lt;(&amp;quot;C&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fulltext-search:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Fulltext search&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :where [(fulltext $ :community/name &amp;quot;Wallingford&amp;quot;) [[ ?a ?b ]]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.contains(&amp;quot;Wallingford&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fulltext search on many-attribute (&lt;code&gt;category&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b (distinct ?d)
 :where [?a :community/name ?b]
        [?a :community/type &amp;quot;:community.type/website&amp;quot;]
        [(fulltext $ :community/category &amp;quot;food&amp;quot;) [[ ?a ?d ]]]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.type_(&amp;quot;website&amp;quot;).category.contains(&amp;quot;food&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;querying-with-rules-logical-or:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Querying with rules (logical OR)&lt;/h3&gt;

&lt;p&gt;Social media communities&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :in    $ %
 :where [?a :community/name ?b]
        (rule1 ?a)]

INPUTS:
List(
  1 datomic.db.Db@xxx
  2 [[(rule1 ?a) [?a :community/type &amp;quot;:community.type/twitter&amp;quot;]]
     [(rule1 ?a) [?a :community/type &amp;quot;:community.type/facebook_page&amp;quot;]]]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.type_(&amp;quot;twitter&amp;quot; or &amp;quot;facebook_page&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Social media communities in southern regions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :in    $ %
 :where [?a :community/name ?b]
        (rule1 ?a)
        [?a :community/neighborhood ?d]
        [?d :neighborhood/district ?e]
        (rule2 ?e)]

INPUTS:
List(
  1 datomic.db.Db@xxx
  2 [[(rule1 ?a) [?a :community/type &amp;quot;:community.type/twitter&amp;quot;]]
     [(rule1 ?a) [?a :community/type &amp;quot;:community.type/facebook_page&amp;quot;]]
     [(rule2 ?e) [?e :district/region &amp;quot;:district.region/sw&amp;quot;]]
     [(rule2 ?e) [?e :district/region &amp;quot;:district.region/s&amp;quot;]]
     [(rule2 ?e) [?e :district/region &amp;quot;:district.region/se&amp;quot;]]]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.type_(&amp;quot;twitter&amp;quot; or &amp;quot;facebook_page&amp;quot;)
  .Neighborhood.District.region_(&amp;quot;sw&amp;quot; or &amp;quot;s&amp;quot; or &amp;quot;se&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parameterized&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :in    $ %
 :where [?a :community/name ?b]
        [?a :community/type ?c]
        [?a :community/neighborhood ?d]
        [?d :neighborhood/district ?e]
        [?e :district/region ?f]
        (rule1 ?a)
        (rule2 ?e)]

INPUTS:
List(
  1 datomic.db.Db@xxx
  2 [[(rule1 ?a) [?a :community/type &amp;quot;:community.type/twitter&amp;quot;]]
     [(rule1 ?a) [?a :community/type &amp;quot;:community.type/facebook_page&amp;quot;]]
     [(rule2 ?e) [?e :district/region &amp;quot;:district.region/sw&amp;quot;]]
     [(rule2 ?e) [?e :district/region &amp;quot;:district.region/s&amp;quot;]]
     [(rule2 ?e) [?e :district/region &amp;quot;:district.region/se&amp;quot;]]]
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;m(Community.name.type_(?).Neighborhood.District.region_(?))
  .apply((&amp;quot;twitter&amp;quot; or &amp;quot;facebook_page&amp;quot;) and (&amp;quot;sw&amp;quot; or &amp;quot;s&amp;quot; or &amp;quot;se&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;working-with-time:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Working with time&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[:find  ?b
 :where [?a :db/txInstant ?b]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Db.txInstant
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inserting-data:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Inserting data&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/name        ,   AAA                             )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/url         ,   myUrl                           )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/type        ,   :community.type/twitter         )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/orgtype     ,   :community.orgtype/personal     )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/category    ,   my                              )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/category    ,   favorites                       )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/neighborhood,   #db/id[:db.part/user -1000002]  )
  List(  :db/add,   #db/id[:db.part/user -1000002],   :neighborhood/name     ,   myNeighborhood                  )
  List(  :db/add,   #db/id[:db.part/user -1000002],   :neighborhood/district ,   #db/id[:db.part/user -1000003]  )
  List(  :db/add,   #db/id[:db.part/user -1000003],   :district/name         ,   myDistrict                      )
  List(  :db/add,   #db/id[:db.part/user -1000003],   :district/region       ,   :district.region/nw             )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community
  .name(&amp;quot;AAA&amp;quot;)
  .url(&amp;quot;myUrl&amp;quot;)
  .`type`(&amp;quot;twitter&amp;quot;)
  .orgtype(&amp;quot;personal&amp;quot;)
  .category(&amp;quot;my&amp;quot;, &amp;quot;favorites&amp;quot;)
  .Neighborhood.name(&amp;quot;myNeighborhood&amp;quot;)
  .District.name(&amp;quot;myDistrict&amp;quot;).region(&amp;quot;nw&amp;quot;).save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple entities:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/name        ,   DDD Blogging Georgetown                        )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/url         ,   http://www.blogginggeorgetown.com/             )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/type        ,   :community.type/blog                           )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/orgtype     ,   :community.orgtype/commercial                  )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/category    ,   DD cat 1                                       )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/category    ,   DD cat 2                                       )
  List(  :db/add,   #db/id[:db.part/user -1000001],   :community/neighborhood,   #db/id[:db.part/user -1000002]                 )
  List(  :db/add,   #db/id[:db.part/user -1000002],   :neighborhood/name     ,   DD Georgetown                                  )
  List(  :db/add,   #db/id[:db.part/user -1000002],   :neighborhood/district ,   #db/id[:db.part/user -1000003]                 )
  List(  :db/add,   #db/id[:db.part/user -1000003],   :district/name         ,   Greater Duwamish                               )
  List(  :db/add,   #db/id[:db.part/user -1000003],   :district/region       ,   :district.region/s                             )
  
  List(  :db/add,   #db/id[:db.part/user -1000004],   :community/name        ,   DDD Interbay District Blog                     )
  List(  :db/add,   #db/id[:db.part/user -1000004],   :community/url         ,   http://interbayneighborhood.neighborlogs.com/  )
  List(  :db/add,   #db/id[:db.part/user -1000004],   :community/type        ,   :community.type/blog                           )
  List(  :db/add,   #db/id[:db.part/user -1000004],   :community/orgtype     ,   :community.orgtype/community                   )
  List(  :db/add,   #db/id[:db.part/user -1000004],   :community/category    ,   DD cat 3                                       )
  List(  :db/add,   #db/id[:db.part/user -1000004],   :community/neighborhood,   #db/id[:db.part/user -1000005]                 )
  List(  :db/add,   #db/id[:db.part/user -1000005],   :neighborhood/name     ,   DD Interbay                                    )
  List(  :db/add,   #db/id[:db.part/user -1000005],   :neighborhood/district ,   #db/id[:db.part/user -1000006]                 )
  List(  :db/add,   #db/id[:db.part/user -1000006],   :district/name         ,   Magnolia/Queen Anne                            )
  List(  :db/add,   #db/id[:db.part/user -1000006],   :district/region       ,   :district.region/w                             )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community.name.url.`type`.orgtype.category.Neighborhood.name.District.name.region insert List(
  (&amp;quot;DDD Blogging Georgetown&amp;quot;, &amp;quot;http://www.blogginggeorgetown.com/&amp;quot;, &amp;quot;blog&amp;quot;, &amp;quot;commercial&amp;quot;, Set(&amp;quot;DD cat 1&amp;quot;, &amp;quot;DD cat 2&amp;quot;), &amp;quot;DD Georgetown&amp;quot;, &amp;quot;Greater Duwamish&amp;quot;, &amp;quot;s&amp;quot;),
  (&amp;quot;DDD Interbay District Blog&amp;quot;, &amp;quot;http://interbayneighborhood.neighborlogs.com/&amp;quot;, &amp;quot;blog&amp;quot;, &amp;quot;community&amp;quot;, Set(&amp;quot;DD cat 3&amp;quot;), &amp;quot;DD Interbay&amp;quot;, &amp;quot;Magnolia/Queen Anne&amp;quot;, &amp;quot;w&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;updating-data:fce8223ee4fefc246edc14cd715d3099&#34;&gt;Updating data&lt;/h3&gt;

&lt;p&gt;Updating one-attribute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/add,   17592186045649,   :community/name,   belltown 2  )
  List(  :db/add,   17592186045649,   :community/url ,   url 2       )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).name(&amp;quot;belltown 2&amp;quot;).url(&amp;quot;url 2&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Updating many-attribute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/retract,   17592186045649,   :community/category,   news       )
  List(  :db/add    ,   17592186045649,   :community/category,   Cool news  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category(&amp;quot;news&amp;quot; -&amp;gt; &amp;quot;Cool news&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update multiple values of many-attribute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/retract,   17592186045649,   :community/category,   Cool news          )
  List(  :db/add    ,   17592186045649,   :community/category,   Super cool news    )
  List(  :db/retract,   17592186045649,   :community/category,   events             )
  List(  :db/add    ,   17592186045649,   :community/category,   Super cool events  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category(
  &amp;quot;Cool news&amp;quot; -&amp;gt; &amp;quot;Super cool news&amp;quot;,
  &amp;quot;events&amp;quot; -&amp;gt; &amp;quot;Super cool events&amp;quot;
).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update multiple values of many-attribute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/retract,   17592186045649,   :community/category,   Cool news          )
  List(  :db/add    ,   17592186045649,   :community/category,   Super cool news    )
  List(  :db/retract,   17592186045649,   :community/category,   events             )
  List(  :db/add    ,   17592186045649,   :community/category,   Super cool events  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category(
  &amp;quot;Cool news&amp;quot; -&amp;gt; &amp;quot;Super cool news&amp;quot;,
  &amp;quot;events&amp;quot; -&amp;gt; &amp;quot;Super cool events&amp;quot;
).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add a value to a many-attribute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/add,   17592186045649,   :community/category,   extra category  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category.add(&amp;quot;extra category&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remove value from a many-attribute&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/retract,   17592186045649,   :community/category,   Super cool events  )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).category.remove(&amp;quot;Super cool events&amp;quot;).update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mixing updates and deletes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List(
  List(  :db/add    ,   17592186045649,   :community/name    ,   belltown 3                      )
  List(  :db/retract,   17592186045649,   :community/url     ,   http://www.belltownpeople.com/  )
  List(  :db/retract,   17592186045649,   :community/category,   events                          )
  List(  :db/retract,   17592186045649,   :community/category,   news                            )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Community(belltownId).name(&amp;quot;belltown 3&amp;quot;).url().category().update
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>http://scalamolecule.org/compare/sql/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 UTC</pubDate>
      
      <guid>http://scalamolecule.org/compare/sql/</guid>
      <description>

&lt;h1 id=&#34;sql-vs-molecule-examples:d1babb582138b02a13547d2c6eb6df72&#34;&gt;SQL vs. Molecule examples&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;ll make a similar comparison to SQL as &lt;a href=&#34;http://slick.typesafe.com/doc/3.0.0-M1/sql-to-slick.html#sql-vs-slick-examples&#34;&gt;Slick&lt;/a&gt; does:&lt;/p&gt;

&lt;h4 id=&#34;select:d1babb582138b02a13547d2c6eb6df72&#34;&gt;SELECT *&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sql&amp;quot;select * from PERSON&amp;quot;.as[Person].list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In molecule we would declare each attribute we are interested in also to infer the exact return type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val persons: Iterable[(String, Int)] = Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;select-1:d1babb582138b02a13547d2c6eb6df72&#34;&gt;SELECT&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;sql&amp;quot;&amp;quot;&amp;quot;
  select AGE, concat(concat(concat(NAME,&#39; (&#39;),ID),&#39;)&#39;)
  from PERSON
&amp;quot;&amp;quot;&amp;quot;.as[(Int,String)].list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Molecule we would concatenate &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; with the returned result set:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.name.e.get map { case (age, name, id) =&amp;gt; (age, s&amp;quot;$name ($id)&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, Molecule treats attributes as mandatory values whereas Select-attributes in a SQL query could be Null values (if allowed). Molecule can also ask for optional values too if a &lt;code&gt;$&lt;/code&gt; sign is appended to an attribute name:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.firstName.middleName$.lastName.e.get map { 
  case (age, firstName, Some(middleName), lastName, id) =&amp;gt; (age, s&amp;quot;$firstName $middleName $lastName ($id)&amp;quot; 
  case (age, firstName, None, lastName, id)             =&amp;gt; (age, s&amp;quot;$firstName $lastName ($id)&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;where:d1babb582138b02a13547d2c6eb6df72&#34;&gt;WHERE&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;select * from PERSON where AGE &amp;gt;= 18 AND NAME = &#39;C. Vogt&#39;&amp;quot;.as[Person].list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule filter values by applying a required value to an attribute or supply a value to compare against (&lt;code&gt;&amp;gt;=(18)&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.&amp;gt;=(18).name(&amp;quot;C. Vogt&amp;quot;).get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Again we would define which attribute values we want to return)&lt;/p&gt;

&lt;h4 id=&#34;order-by:d1babb582138b02a13547d2c6eb6df72&#34;&gt;ORDER BY&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;select * from PERSON order by AGE asc, NAME&amp;quot;.as[Person].list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ordering is applied on the result set:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.name.get.toSeq.sortBy(_._1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;aggregations:d1babb582138b02a13547d2c6eb6df72&#34;&gt;Aggregations&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;select max(AGE) from PERSON&amp;quot;.as[Option[Int]].first
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aggregate functions like &lt;code&gt;max&lt;/code&gt; are all applied as a keyword value to an attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(max).get
// or get a range of top values
Person.age(max(3)).get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can aggregate values also with the counterpart &lt;code&gt;min&lt;/code&gt; or get a random value with &lt;code&gt;rand&lt;/code&gt;. Or perform aggregate calculations with &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;countDistinct&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;median&lt;/code&gt;, &lt;code&gt;variance&lt;/code&gt; and &lt;code&gt;stddev&lt;/code&gt; which are all built functions in Datomic.&lt;/p&gt;

&lt;h4 id=&#34;group-by:d1babb582138b02a13547d2c6eb6df72&#34;&gt;GROUP BY&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;&amp;quot;&amp;quot;
  select ADDRESS_ID, AVG(AGE)
  from PERSON
  group by ADDRESS_ID
&amp;quot;&amp;quot;&amp;quot;.as[(Int,Option[Int])].list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule automatically group by attributes not having an aggregate expression. In this case the query will group by &lt;code&gt;address&lt;/code&gt; and calculate the average &lt;code&gt;age&lt;/code&gt; for persons living there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.address.age(avg).get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;having:d1babb582138b02a13547d2c6eb6df72&#34;&gt;HAVING&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;&amp;quot;&amp;quot;
  select ADDRESS_ID
  from PERSON
  group by ADDRESS_ID
  having avg(AGE) &amp;gt; 50
&amp;quot;&amp;quot;&amp;quot;.as[Int].list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.address.age(avg).get.toSeq.filter(_._2 &amp;gt; 50)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;implicit-join:d1babb582138b02a13547d2c6eb6df72&#34;&gt;Implicit join&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;&amp;quot;&amp;quot;
  select P.NAME, A.CITY
  from PERSON P, ADDRESS A
  where P.ADDRESS_ID = A.id
&amp;quot;&amp;quot;&amp;quot;.as[(String,String)].list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.Address.city.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;explicit-join:d1babb582138b02a13547d2c6eb6df72&#34;&gt;Explicit join&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;&amp;quot;&amp;quot;
  select P.NAME, A.CITY
  from PERSON P
  join ADDRESS A on P.ADDRESS_ID = A.id
&amp;quot;&amp;quot;&amp;quot;.as[(String,String)].list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.Address.city.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;left-right-outer-join:d1babb582138b02a13547d2c6eb6df72&#34;&gt;left/right/outer join&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;&amp;quot;&amp;quot;
  select P.NAME,A.CITY
  from ADDRESS A
  left join PERSON P on P.ADDRESS_ID = A.id
&amp;quot;&amp;quot;&amp;quot;.as[(Option[String],String)].list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Add `$` to attribute name to get optional values
val persons: Iterable[(Option[String], String)] = Person.name$.Address.city.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;subquery:d1babb582138b02a13547d2c6eb6df72&#34;&gt;Subquery&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;&amp;quot;&amp;quot;
  select *
  from PERSON P
  where P.ADDRESS_ID in (select ID
                 from ADDRESS
                 where CITY = &#39;New York City&#39;)
&amp;quot;&amp;quot;&amp;quot;.as[Person].list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.name.Address.city_(&amp;quot;New York City&amp;quot;).get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;insert:d1babb582138b02a13547d2c6eb6df72&#34;&gt;INSERT&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sqlu&amp;quot;&amp;quot;&amp;quot;
  insert into PERSON (NAME, AGE, ADDRESS_ID) values (&#39;M Odersky&#39;, 12345, 1)
&amp;quot;&amp;quot;&amp;quot;.first
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name(&amp;quot;M Odersky&amp;quot;).age(12345).address(1).save
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;update:d1babb582138b02a13547d2c6eb6df72&#34;&gt;UPDATE&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sqlu&amp;quot;&amp;quot;&amp;quot;
  update PERSON set NAME=&#39;M. Odersky&#39;, AGE=54321 where NAME=&#39;M Odersky&#39;
&amp;quot;&amp;quot;&amp;quot;.first
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Find entity id with generic Molecule attribute `e`
// Omit `name` value by adding underscore `_` to attribute name   
val oderskyId = Person.e.name_(&amp;quot;M Odersky&amp;quot;).get.head
Person(oderskyId).name(&amp;quot;M. Odersky&amp;quot;).age(54321).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;delete:d1babb582138b02a13547d2c6eb6df72&#34;&gt;DELETE&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sqlu&amp;quot;&amp;quot;&amp;quot;
  delete PERSON where NAME=&#39;M. Odersky&#39;
&amp;quot;&amp;quot;&amp;quot;.first
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Retract entity
Person.e.name_(&amp;quot;M. Odersky&amp;quot;).get.head.retract
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;case:d1babb582138b02a13547d2c6eb6df72&#34;&gt;CASE&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sql&amp;quot;&amp;quot;&amp;quot;
  select
    case 
      when ADDRESS_ID = 1 then &#39;A&#39;
      when ADDRESS_ID = 2 then &#39;B&#39;
    end
  from PERSON P
&amp;quot;&amp;quot;&amp;quot;.as[Option[String]].list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.address(1 or 2).get map {
  case 1 =&amp;gt; &amp;quot;A&amp;quot;
  case 2 =&amp;gt; &amp;quot;B&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Slick</title>
      <link>http://scalamolecule.org/compare/sql/slick/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 UTC</pubDate>
      
      <guid>http://scalamolecule.org/compare/sql/slick/</guid>
      <description>

&lt;h1 id=&#34;slick-vs-molecule-examples:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;Slick vs. Molecule examples&lt;/h1&gt;

&lt;p&gt;Using examples from &lt;a href=&#34;http://slick.typesafe.com/doc/3.0.0-M1/sql-to-slick.html#sql-vs-slick-examples&#34;&gt;Slick&lt;/a&gt;:&lt;/p&gt;

&lt;h4 id=&#34;select-all-table-values:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;Select all table values&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Slick
people.run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In molecule we would declare each attribute we are interested in also to infer the exact return type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Molecule
Person.name.age.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;select-certain-columns:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;Select certain columns&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;people.map(p =&amp;gt; (p.age, p.name ++ &amp;quot; (&amp;quot; ++ p.id.asColumnOf[String] ++ &amp;quot;)&amp;quot;)).run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Molecule we would concatenate &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; with the returned result set:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.name.e.get map { case (age, name, id) =&amp;gt; (age, s&amp;quot;$name ($id)&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;filter-where:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;filter / WHERE&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.filter(p =&amp;gt; p.age &amp;gt;= 18 &amp;amp;&amp;amp; p.name === &amp;quot;C. Vogt&amp;quot;).run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule filter values by applying a required value to an attribute or supply a value to compare against (&lt;code&gt;&amp;gt;=(18)&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.&amp;gt;=(18).name(&amp;quot;C. Vogt&amp;quot;).get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Again we would define which attribute values we want to return)&lt;/p&gt;

&lt;h4 id=&#34;sortby-order-by:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;sortBy / ORDER BY&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.sortBy(p =&amp;gt; (p.age.asc, p.name)).run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ordering is applied on the result set in the application code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.name.get.toSeq sortBy(_._1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;aggregations:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;Aggregations&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.map(_.age).max.run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aggregate functions like &lt;code&gt;max&lt;/code&gt; are all applied as a keyword value to an attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age(max).get

// or get a range of top values
Person.age(max(3)).get
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can aggregate values also with the counterpart &lt;code&gt;min&lt;/code&gt; or get a random value with &lt;code&gt;rand&lt;/code&gt;. Or perform aggregate calculations with &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;countDistinct&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;median&lt;/code&gt;, &lt;code&gt;variance&lt;/code&gt; and &lt;code&gt;stddev&lt;/code&gt; which are all built functions in Datomic.&lt;/p&gt;

&lt;h4 id=&#34;groupby-group-by:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;groupBy / GROUP BY&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.groupBy(p =&amp;gt; p.addressId)
       .map{ case (addressId, group) =&amp;gt; (addressId, group.map(_.age).avg) }
       .list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Molecule automatically group by attributes not having an aggregate expression. In this case the query will group by &lt;code&gt;address&lt;/code&gt; and calculate the average &lt;code&gt;age&lt;/code&gt; for persons living there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.address.age(avg).get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;groupby-filter-having:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;groupBy+filter / HAVING&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.groupBy(p =&amp;gt; p.addressId)
       .map{ case (addressId, group) =&amp;gt; (addressId, group.map(_.age).avg) }
       .filter{ case (addressId, avgAge) =&amp;gt; avgAge &amp;gt; 50 }
       .map(_._1)
       .run
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.address.age(avg).get.filter(_._2 &amp;gt; 50)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;implicit-join:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;Implicit join&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.flatMap(p =&amp;gt;
  addresses.filter(a =&amp;gt; p.addressId === a.id)
           .map(a =&amp;gt; (p.name, a.city))
).run

// or equivalent for-expression:
(for(p &amp;lt;- people;
     a &amp;lt;- addresses if p.addressId === a.id
 ) yield (p.name, a.city)
).run
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.Address.city.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;explicit-join:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;Explicit join&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(people join addresses on (_.addressId === _.id))
  .map{ case (p, a) =&amp;gt; (p.name, a.city) }.run
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name.Address.city.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;left-right-outer-join:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;left/right/outer join&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;(addresses joinLeft people on (_.id === _.addressId))
  .map{ case (a, p) =&amp;gt; (p.map(_.name), a.city) }.run
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Add `$` to attribute name to get optional values
Person.name$.Address.city.get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;subquery:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;Subquery&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val address_ids = addresses.filter(_.city === &amp;quot;New York City&amp;quot;).map(_.id)
people.filter(_.id in address_ids).run // &amp;lt;- run as one query
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.age.name.Address.city_(&amp;quot;New York City&amp;quot;).get
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;insert:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;insert&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.map(p =&amp;gt; (p.name, p.age, p.addressId))
       .insert((&amp;quot;M Odersky&amp;quot;,12345,1))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.name(&amp;quot;M Odersky&amp;quot;).age(12345).address(1).save
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;update:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;update&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.filter(_.name === &amp;quot;M Odersky&amp;quot;)
       .map(p =&amp;gt; (p.name,p.age))
       .update((&amp;quot;M. Odersky&amp;quot;,54321))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Find entity id with generic Molecule attribute `e`
// Omit `name` value by adding underscore `_` to attribute name   
val oderskyId = Person.e.name_(&amp;quot;M Odersky&amp;quot;).get.head
Person(oderskyId).name(&amp;quot;M. Odersky&amp;quot;).age(54321).update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;delete:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;delete&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.filter(p =&amp;gt; p.name === &amp;quot;M. Odersky&amp;quot;)
       .delete
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.e.name_(&amp;quot;M. Odersky&amp;quot;).get.head.retract
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;case:ce7ebdb2cbbacd766a8940138f40260d&#34;&gt;case&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;people.map(p =&amp;gt;
  Case
    If(p.addressId === 1) Then &amp;quot;A&amp;quot;
    If(p.addressId === 2) Then &amp;quot;B&amp;quot;
).list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;Person.address(1 or 2).get map {
  case 1 =&amp;gt; &amp;quot;A&amp;quot;
  case 2 =&amp;gt; &amp;quot;B&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>