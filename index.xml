<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Molecule</title>
    <link>http://scalamolecule.org/</link>
    <description>Recent content in Home on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Oct 2019 02:13:50 +0000</lastBuildDate>
    
	<atom:link href="http://scalamolecule.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Cardinality one</title>
      <link>http://scalamolecule.org/manual/relationships/card-one/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/manual/relationships/card-one/</guid>
      <description>Card-one relationships Tests&amp;hellip;
In Molecule we model a cardinality-one relationship in our schema definition file with the one[&amp;lt;RefNamespace&amp;gt;] syntax:
object YourDomainDefinition { trait Person { val name = oneString val home = one[Addr] } trait Addr { val street = oneString val city = oneString } } The ref attribute home is a card-one relationship to namespace Addr. When our schema is then translated to Molecule boilerplate code our home ref attribute is accessible as a value by using its lower case name (home instead of Home):</description>
    </item>
    
    <item>
      <title>Datomic</title>
      <link>http://scalamolecule.org/compare/datomic/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/compare/datomic/</guid>
      <description>Compare with Datomic/Datalog Even though Molecule is adapting to Datomic we&amp;rsquo;ll have a look the other way around to see how Datomic compares to Molecule.
Follow along in the code from which we will pick a few examples based on the Seattle tutorial examples.
Querying for attribute values The most basic query is to ask for entities with some attribute values:
// Datalog [:find ?b ?c (distinct ?d) :where [?a :Community/name ?</description>
    </item>
    
    <item>
      <title>AsOf/Since</title>
      <link>http://scalamolecule.org/manual/time/asof-since/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/time/asof-since/</guid>
      <description>AsOf / Since Tests&amp;hellip;
getAsOf(t) and getSince are complementary functions that either get us a snapshop of the database at some point in time or a current snapshot filtered with only changes after a point in time. Like before/after scenarios.
AsOf AsOf test&amp;hellip;
Calling getAsOf(t) on a molecule gives us the data as of a certain point in time like t4:
As we saw in point in time, a t can be either a transaction entity id like txE4, a transaction number t4, the resulting transaction report tx4 from some transactional operation or a java.</description>
    </item>
    
    <item>
      <title>Building molecules</title>
      <link>http://scalamolecule.org/manual/attributes/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/attributes/basics/</guid>
      <description>Building molecules Tests&amp;hellip;
When we have defined a schema, Molecule generates the necessary boilerplate code so that we can build &amp;ldquo;molecular data structures&amp;rdquo; by building sequences of Attributes separated with dots (the &amp;ldquo;builder pattern&amp;rdquo;).
We could for instance build a molecule representing the data structure of Persons with name, age and gender Attributes:
Person.name.age.gender // etc The fundamental building blocks are Namespaces like Person and Attributes like name, age and gender.</description>
    </item>
    
    <item>
      <title>Datalog/data</title>
      <link>http://scalamolecule.org/manual/debug/datalog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/debug/datalog/</guid>
      <description>Show Datalog queries and data All molecule query commands have a corresponding debug command that will print debugging information to console.
 &amp;lt;molecule&amp;gt;.debugGet &amp;lt;molecule&amp;gt;.debugGetHistory &amp;lt;molecule&amp;gt;.debugGetAsOf(...) &amp;lt;molecule&amp;gt;.debugGetSince(...) &amp;lt;molecule&amp;gt;.debugGetWith(...)  debugGet Simply replace a get command on a molecule with debugGet to print debugging data when running the code in a test for instance:
// Molecule to be debugged Community.name.Neighborhood.District.region_(&amp;quot;ne&amp;quot; or &amp;quot;sw&amp;quot;).get(3) === List( &amp;quot;Beach Drive Blog&amp;quot;, &amp;quot;KOMO Communities - Green Lake&amp;quot;, &amp;quot;Delridge Produce Cooperative&amp;quot; ) // Debug `get` Community.</description>
    </item>
    
    <item>
      <title>Datom</title>
      <link>http://scalamolecule.org/manual/generic/datom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/generic/datom/</guid>
      <description>Datom API Tests&amp;hellip;
Datoms / quintuplets Attribute values are saved as quintuplets of information in Datomic:
The Datom API in Molecule let us retrieve each element generically for any molecule we are working on by providing the following &amp;ldquo;generic attributes&amp;rdquo; that we can add to our custom molecules:
 e - Entity id (Long) a - Attribute (String) v - Value (Any) t - Transaction point in time (Long alternatively Int) op - Operation: assertion / retraction (Boolean true/false)  The Transaction value has two more representations</description>
    </item>
    
    <item>
      <title>Save</title>
      <link>http://scalamolecule.org/manual/crud/save/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/crud/save/</guid>
      <description>Save Tests&amp;hellip;
In Molecule we can populate a molecule with data and save it:
Person.name(&amp;quot;Fred&amp;quot;).likes(&amp;quot;pizza&amp;quot;).age(38).save This will assert 3 facts in Datomic that all share the id of the new entity id fredId that is automatically created by Datomic:
fredId :Person/name &amp;quot;Fred&amp;quot; fredId :Person/likes &amp;quot;pizza&amp;quot; fredId :Person/age 38 Type-safety Type-safety is guaranteed since each attribute only accepts values of its defined type.
Asynchronous save All transactional operators have an asynchronous equivalent.</description>
    </item>
    
    <item>
      <title>Seattle</title>
      <link>http://scalamolecule.org/resources/tutorials/seattle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/resources/tutorials/seattle/</guid>
      <description>Seattle tutorial - with molecules  A first query Querying for an attribute&amp;rsquo;s value Querying by attribute values Querying across references Parameterizing queries - input molecules Invoking functions in queries Querying with fulltext search Querying with rules - logical OR Working with time Insert data Update and/or delete data  Credits: This tutorial is based on the original Datomic Seattle tutorial (there is also a new tutorial) and some text passages have been quoted as-is or been slightly modified to describe how Molecule works.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://scalamolecule.org/manual/quick-start/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/quick-start/introduction/</guid>
      <description>Molecule introduction Molecule let&amp;rsquo;s you model and query your domain data structures directly with the words of your domain.
Query Let&amp;rsquo;s say we want to find Persons in the Datomic database. Then we can build a molecule to get this data for us:
val persons: List[(String, Int)] = m(Person.name.age).get This fetches a List of tuples of Strings/Int&amp;rsquo;s that are the types of the name and age Attributes that we asked for.</description>
    </item>
    
    <item>
      <title>Performance</title>
      <link>http://scalamolecule.org/manual/quick-start/performance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/quick-start/performance/</guid>
      <description>Automatic Query optimization Molecule transparently optimize all queries sent to Datomic.
Most selective Clauses are automatically grouped first in the :where section of the Datomic query as per the recommendation in Datomic Best Practices.
This brings dramatic performance gains of in some cases beyond 100x compared to un-optimized queries. The optimization happens automatically in the background so that you can focus entirely on your domain without concern for the optimal order of attributes in your molecules.</description>
    </item>
    
    <item>
      <title>Cardinality many</title>
      <link>http://scalamolecule.org/manual/relationships/card-many/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/manual/relationships/card-many/</guid>
      <description>Card-many relationships Tests&amp;hellip;
Cardinality-many relationships in Molecule are modelled with the many[&amp;lt;RefNamespace&amp;gt;] syntax:
object OrderDefinition { trait Order { val id = oneString val items = many[LineItem].isComponent } trait LineItem { val qty = oneInt val product = oneString val price = oneDouble } } An Order can have multiple LineItems so we define a cardinality-many ref attribute items that points to the LineItem namespace.
Note how we also make LineItems a component with the isComponent option.</description>
    </item>
    
    <item>
      <title>Boilerplate</title>
      <link>http://scalamolecule.org/dev/boilerplate/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/dev/boilerplate/</guid>
      <description>Boilerplate code generation An attribute definition like
@InOut(3, 8) trait SeattleDefinition { trait Community { val name = oneString.fulltext } } would generate the following boilerplate code
object Community extends Community_0 { def apply(e: Long): Community_0 = ??? } trait Community { class name [Ns, In] extends OneString [Ns, In] with Fulltext[Ns, In] with Indexed } trait Community_0 extends Community with Out_0[Community_0, Community_1, Community_In_1_0, Community_In_1_1] { lazy val name : name[Community_1[String], Community_In_1_1[String, String]] with Community_1[String] = new name[Community_1[String], Community_In_1_1[String, String]] with Community_1[String] { override val _kw = &amp;quot;:Community/name&amp;quot; } lazy val name_ : name[Community_0, Community_In_1_0[String]] with Community_0 = ?</description>
    </item>
    
    <item>
      <title>Slick</title>
      <link>http://scalamolecule.org/compare/sql/slick/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/compare/sql/slick/</guid>
      <description>Slick vs. Molecule examples Using examples from Coming from SQL to Slick:
Select all table values // Slick people.result In molecule we would declare each attribute we are interested in also to infer the exact return type
// Molecule Person.name.age.get Select certain columns people.map(p =&amp;gt; (p.age, p.name ++ &amp;quot; (&amp;quot; ++ p.id.asColumnOf[String] ++ &amp;quot;)&amp;quot;)).result With Molecule we would concatenate name and id with the returned result set:
Person.age.name.e.get map { case (age, name, id) =&amp;gt; (age, s&amp;quot;$name ($id)&amp;quot; } filter / WHERE people.</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>http://scalamolecule.org/compare/sql/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/compare/sql/</guid>
      <description>SQL vs. Molecule examples We&amp;rsquo;ll make a similar comparison to SQL as Slick does:
SELECT * sql&amp;quot;select * from PERSON&amp;quot;.as[Person].list In molecule we would declare each attribute we are interested in also to infer the exact return type
val persons: List[(String, Int)] = Person.name.age.get SELECT sql&amp;quot;&amp;quot;&amp;quot; select AGE, concat(concat(concat(NAME,&#39; (&#39;),ID),&#39;)&#39;) from PERSON &amp;quot;&amp;quot;&amp;quot;.as[(Int,String)].list With Molecule we would concatenate name and id with the returned result set:
Person.age.name.e.get map { case (age, name, id) =&amp;gt; (age, s&amp;quot;$name ($id)&amp;quot; } Actually, Molecule treats attributes as mandatory values whereas Select-attributes in a SQL query could be Null values (if allowed).</description>
    </item>
    
    <item>
      <title>Indexes</title>
      <link>http://scalamolecule.org/manual/generic/indexes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/generic/indexes/</guid>
      <description>Index APIs Tests&amp;hellip;
Some index descriptions in the following sections respectfully quoted from the Datomic documentation.
Datomic maintains four indexes that contain ordered sets of datoms. Each of these indexes is named based on the sort order used. E, A, and V are always sorted in ascending order, while T is always in descending order:
 EAVT - Datoms sorted by Entity-Attribute-Value-Transaction. AVET - Datoms sorted by Attribute-Value-Entity-Transaction. AEVT - Datoms sorted by Attribute-Entity-Value-Transaction.</description>
    </item>
    
    <item>
      <title>Insert</title>
      <link>http://scalamolecule.org/manual/crud/insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/crud/insert/</guid>
      <description>Insert Tests&amp;hellip;
Data can be inserted by making a molecule that matches the values of each row.
One row of data can be applied directly with matching arguments
Person.name.likes.age.insert(&amp;quot;Fred&amp;quot;, &amp;quot;pizza&amp;quot;, 38) Multiple rows of data can be applied as any Iterable of tuples of data each matching the molecule attributes:
Person.name.likes.age insert List( (&amp;quot;Lisa&amp;quot;, &amp;quot;pizza&amp;quot;, 7), (&amp;quot;Ben&amp;quot;, &amp;quot;pasta&amp;quot;, 5) ) Type-safety Type-safety is guaranteed since the type of each tuple of data is enforced by the compiler to conform to the molecule type.</description>
    </item>
    
    <item>
      <title>Mandatory/Tacit/Optional</title>
      <link>http://scalamolecule.org/manual/attributes/modes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/attributes/modes/</guid>
      <description>3 attribute modes (All getters have an asynchronous equivalent. Synchronous getters shown for brevity)
1. Mandatory attr When we use a molecule to query the Datomic database we ask for entities having all our Attributes associated with them.
Note that this is different from selecting rows from a sql table where you can also get null values back!
If for instance we have entities representing Persons in our data set that haven&amp;rsquo;t got any age Attribute associated with them then this query will not return those entities:</description>
    </item>
    
    <item>
      <title>Molecule presentation</title>
      <link>http://scalamolecule.org/resources/videos/2017-04-25_Marc_Grue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/resources/videos/2017-04-25_Marc_Grue/</guid>
      <description>Molecule video presentation  Part 1: Datomic data model Part 2: Building a DSL with Scala macros Part 3: Tour of Molecule features Part 4: Molecule domain modelling  Molecule presentation in 4 parts by creator Marc Grue at a Scala MeetUp in Gothenburg 2017-04-25.
Attendees came with great suggestions for improvements that were incorporated in Molecule v0.11. Some of the slides in the videos below are updated to show the new API of v0.</description>
    </item>
    
    <item>
      <title>Setup</title>
      <link>http://scalamolecule.org/manual/setup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/setup/</guid>
      <description>Setup To use Molecule we need to define our database schema in a Schema definition file and then tell sbt about it. When compiling our project from the command line, all necessary boilerplate code is then automatically generated by the sbt MoleculePlugin.
1. SBT build settings Add the following to your build files:
project/build.properties:
sbt.version=1.3.10 project/buildinfo.sbt:
addSbtPlugin(&amp;quot;org.scalamolecule&amp;quot; % &amp;quot;sbt-molecule&amp;quot; % &amp;quot;0.9.0&amp;quot;) build.sbt:
lazy val yourProject = project.in(file(&amp;quot;app&amp;quot;)) .enablePlugins(MoleculePlugin) .settings( resolvers ++= Seq( &amp;quot;datomic&amp;quot; at &amp;quot;http://files.</description>
    </item>
    
    <item>
      <title>Transactions</title>
      <link>http://scalamolecule.org/manual/debug/debug-transactions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/debug/debug-transactions/</guid>
      <description>Debug transactions Transactional operations can be debugged with the following methods:
 &amp;lt;molecule&amp;gt;.debugSave &amp;lt;molecule&amp;gt;.debugInsert(data...) &amp;lt;molecule&amp;gt;.debugUpdate &amp;lt;entityId&amp;gt;.debugRetract &amp;lt;entityId&amp;gt;.Tx(transactionMolecule).debugRetract debugRetract(entityIds, txMetaDataMolecules*)  Calling these debug methods will print the produced transaction statements to console only and not perform any transaction on the database.
Debug Save If we are about to save a molecule we can instead call debugSave on the same molecule to see what transaction statements Molecule will send to Datomic.</description>
    </item>
    
    <item>
      <title>Tx bundle</title>
      <link>http://scalamolecule.org/manual/transactions/tx-bundle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/transactions/tx-bundle/</guid>
      <description>Transaction bundle Tests&amp;hellip;
Multiple actions in one atomic transaction save, insert, update and retract operations on molecules each execute in their own transaction. By bundling transactions statements from several of those operations we can execute a single transaction that will guarantee atomicity. The bundled transaction will either complete as a whole or abort if there are any transactional errors.
Each of the above operations has an equivalent method for getting the transaction statements it produces:</description>
    </item>
    
    <item>
      <title>Tx functions</title>
      <link>http://scalamolecule.org/manual/transactions/tx-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/transactions/tx-functions/</guid>
      <description>Transaction functions Tests&amp;hellip;
Atomic processing within the transaction Transaction functions
 run on the transactor inside of transactions can atomically analyze and transform database values can perform arbitrary logic must have no side effect must return transaction data (Seq[Seq[Statement]])  Since tx functions have access to the tx database value they are essential to guaranteeing atomicity in updates for instance. You can query the current db value within the transaction logic and thus be sure certain assertions hold before doing some operation.</description>
    </item>
    
    <item>
      <title>Tx meta data</title>
      <link>http://scalamolecule.org/manual/transactions/tx-meta-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/transactions/tx-meta-data/</guid>
      <description>Transaction meta data Tests&amp;hellip;
As we saw, a transaction in Datomic is also an entity with a timestamp fact. Since it&amp;rsquo;s an entity as any of our own entities, we can even add more facts that simply share the entity id of the transaction:
Save Depending on our domain we can tailor any tx meta data that we find valuable to associate with some transactions. We could for instance be interested in &amp;ldquo;who did it&amp;rdquo; and &amp;ldquo;in what use case&amp;rdquo; it happened and create some generic attributes user and uc in an Audit namespace:</description>
    </item>
    
    <item>
      <title>Gremlin</title>
      <link>http://scalamolecule.org/compare/gremlin/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/compare/gremlin/</guid>
      <description>Gremlin vs. Molecule examples Let&amp;rsquo;s compare the queries/traversals in the Gremlin Getting Started Tutorial with equivalent Molecule queries.
For the examples we&amp;rsquo;ll use the same &amp;ldquo;Modern&amp;rdquo; graph as the tutorial:
Insert data Gremlin is untyped, so data is inserted directly in a generic way where &amp;ldquo;types&amp;rdquo; are created on-the-go:
Graph graph = TinkerGraph.open(); (1) Vertex marko = graph.addVertex(T.label, &amp;quot;person&amp;quot;, T.id, 1, &amp;quot;name&amp;quot;, &amp;quot;marko&amp;quot;, &amp;quot;age&amp;quot;, 29); (2) Vertex vadas = graph.addVertex(T.label, &amp;quot;person&amp;quot;, T.</description>
    </item>
    
    <item>
      <title>Transformation</title>
      <link>http://scalamolecule.org/dev/transformation/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/dev/transformation/</guid>
      <description>Macro transformation Molecule performs a series of transformation of the molecules we write so that they in the end become a Datomic query:
1. Source code To find southern media communities we could make the following molecule
Community.name.`type`(&amp;quot;twitter&amp;quot; or &amp;quot;facebook_page&amp;quot;) .Neighborhood.District.region(&amp;quot;sw&amp;quot; or &amp;quot;s&amp;quot; or &amp;quot;se&amp;quot;) 2. Model AST The source code of our molecule is then pattern matched in Dsl2Model element by element in order to create an abstracted Model of Atoms and Bonds:</description>
    </item>
    
    <item>
      <title>Composites</title>
      <link>http://scalamolecule.org/manual/relationships/composites/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/relationships/composites/</guid>
      <description>Composites Tests&amp;hellip;
As we saw earlier, Entities are simply groups of facts that share an entity id:
The last fact is kind of a black sheep though since the :Site/cat attribute is not in the Person namespace.
Avoid non-intrinsic pollution Since entities can have attributes from any namespace we have a challenge of how to model this in our schema definiton. It would be quick and easy to just make a relationship from a Person namespace to the Site namespace:</description>
    </item>
    
    <item>
      <title>Errors</title>
      <link>http://scalamolecule.org/manual/debug/err/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/debug/err/</guid>
      <description>Common errors and solutions As errors and solutions are encountered this list is updated to help developers working with Molecule.
Compile time  Inferred: Cannot resolve overloaded method &amp;lsquo;inputMolecule&amp;rsquo; Compiled: overloaded method value apply with alternatives:  Runtime  JdbcSQLException: Connection is broken: &amp;ldquo;java.net.ConnectException: Connection refused  ☝︎ Cannot resolve overloaded method &amp;lsquo;inputMolecule&amp;rsquo; When forgetting to explicitly calling m on an input molecule
val inputMolecule = Community.name(?) inputMolecule(&amp;quot;Ben&amp;quot;) // will not compile and likely be inferred as an error in your IDE Input molecule needs to be declared explicitly with the m method</description>
    </item>
    
    <item>
      <title>History</title>
      <link>http://scalamolecule.org/manual/time/history/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/time/history/</guid>
      <description>History Tests&amp;hellip;
The history perspective gives us all the assertions and retractions that has happened over time.
Assertions and retractions Normally we get a snapshot of the database at a certain point in time. But when we call the getHistory method on a molecule we get all the assertions and retractions that has happened over time for the attributes of the molecule.
As an example we can imagine Fred being added in tx3 and then updated in tx6.</description>
    </item>
    
    <item>
      <title>Log</title>
      <link>http://scalamolecule.org/manual/generic/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/generic/log/</guid>
      <description>Log API Tests&amp;hellip;
Some index descriptions in the following sections respectfully quoted from the Datomic documentation.
Datomic&amp;rsquo;s database log is a recording of all transaction data in historic order, organized for efficient access by transaction. The Log is therefore an efficient source of finding data by transaction time.
Tx range and generic Log attributes The Molecule Log implementation takes two arguments to define a range of transactions between from (inclusive) and until (exclusive).</description>
    </item>
    
    <item>
      <title>Map attributes</title>
      <link>http://scalamolecule.org/manual/attributes/mapped/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/attributes/mapped/</guid>
      <description>Map Attributes Tests&amp;hellip;
Mapped values can be saved with mapped attributes in Molecule. It&amp;rsquo;s a special Molecule construct that makes it easy to save for instance multi-lingual data without having to create language-variations of each attribute. But they can also be used for any other key-value indexed data.
Say you want to save famous Persons names in multiple languages. Then you could use a mapString:
// In definition file val name = mapString // Insert mapped data Person.</description>
    </item>
    
    <item>
      <title>Schema</title>
      <link>http://scalamolecule.org/manual/schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/</guid>
      <description>Schema A Datomic schema defines the set of possible attributes that we can use.
In Molecule we make this definition in a Schema definition file:
Schema definition file Molecule provides an intuitive and type-safe dsl to model your schema in a Schema definition file. After each change you make in this file you need to compile your project with sbt compile so that the sbt-plugin can create a Molecule DSL from your definitions.</description>
    </item>
    
    <item>
      <title>Transaction</title>
      <link>http://scalamolecule.org/manual/schema/transaction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/schema/transaction/</guid>
      <description>Schema transaction To create our Datomic database we need to transact some schema transaction data in Datomic. This makes our defined attributes available in Datomic.
Schema transaction data Apart from generating our molecule boilerplate code, the sbt-MoleculePlugin also prepares our schema transaction data in a ready to transact format. It transforms our Schema definition file to basically a java.util.List containing a java.util.Map of schema transaction data for each attribute defined. Our name and url attributes for instance requires the following map of information to be transacted in Datomic:</description>
    </item>
    
    <item>
      <title>Bidirectional</title>
      <link>http://scalamolecule.org/manual/relationships/bidirectional/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/manual/relationships/bidirectional/</guid>
      <description>Bidirectional references Tests&amp;hellip;
Unidirectional reference limitations Normal Datomic references are unidirectional. If we add a friend reference from Ann to Ben
Person.name(&amp;quot;Ann&amp;quot;).Friends.name(&amp;quot;Ben&amp;quot;).save Then we can naturally query to get friends of Ann
Person.name_(&amp;quot;Ann&amp;quot;).Friends.name.get === List(&amp;quot;Ben&amp;quot;) But what if we want to find friends of Ben? This will give us nothing since our reference only went from Ann to Ben:
Person.name_(&amp;quot;Ben&amp;quot;).Friends.name.get === List() Instead we would have to think backwards to get the back reference &amp;ldquo;who referenced Ben?</description>
    </item>
    
    <item>
      <title>Attributes</title>
      <link>http://scalamolecule.org/manual/attributes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/attributes/</guid>
      <description>Attributes Molecules are built by chaining attributes together with the builder pattern. Here are some groups of different attribute types and their use with links to their manual pages:
Attribute basics, return types, arity, cardinality (tests)
val persons: List[(String, Int)] = Person.name.age.get Mandatory/Tacit/Optional attributes (tests)
Person.name.age.get // all required values (&amp;quot;mandatory value&amp;quot;) Person.name.age_.get // age is required but not returned (&amp;quot;tacit value&amp;quot;) Person.name.age$.get // optional age returned (&amp;quot;optional value&amp;quot;) Map attributes - mapped attribute values (tests)</description>
    </item>
    
    <item>
      <title>Expressions</title>
      <link>http://scalamolecule.org/manual/attributes/expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/attributes/expressions/</guid>
      <description>Expressions Tests&amp;hellip;
(All getters have an asynchronous equivalent. Synchronous getters shown for brevity)
Equality Tests&amp;hellip;
We can apply values to Attributes in order to filter the data structures we are looking for. We could for instance find people who like pizza:
Person.likes.apply(&amp;quot;pizza&amp;quot;) or simply
Person.likes(&amp;quot;pizza&amp;quot;) Since the applied value &amp;ldquo;pizza&amp;rdquo; ensures that the attributes returned has this value we will get redundant information back for the likes attribute (&amp;ldquo;pizza&amp;rdquo; is returned for all persons):</description>
    </item>
    
    <item>
      <title>Get</title>
      <link>http://scalamolecule.org/manual/crud/get/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/crud/get/</guid>
      <description>Get (read) Data We get/read data from the database by calling get on a molecule. This returns a List of tuples that match the molecule attributes (except for arity-1):
val persons1attr: List[String] = Person.name.get val persons2attrs: List[(String, Int)] = Person.name.age.get val persons3attrs: List[(String, Int, String)] = Person.name.age.likes.get // Etc.. to arity 22 Data can be returned in 5 different formats:
// List for convenient access to smaller data sets val list : List[(String, Int)] = m(Person.</description>
    </item>
    
    <item>
      <title>Schema</title>
      <link>http://scalamolecule.org/manual/generic/schema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/generic/schema/</guid>
      <description>Schema API Tests&amp;hellip;
The generic Schema interface provides attributes to build a Schema molecule that query the Schema structure of the current database. Datomic&amp;rsquo;s bootstrapped attributes are transparently filtered out so that only schema data of the current database is returned.
Generic Schema attributes The following Schema attributes can be used to build Schema molecules:
Querying the Schema structure // List of attribute entity ids val attrIds: Seq[Long] = Schema.id.get Partition/Namespace/Attribute names // Attribute name elements Schema.</description>
    </item>
    
    <item>
      <title>With</title>
      <link>http://scalamolecule.org/manual/time/with/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/time/with/</guid>
      <description>With Tests&amp;hellip;
By supplying some test transaction data to getWith(testTxData) we filter the current database with the test transaction data applied in-memory. This is a very powerful way of testing future-like &amp;ldquo;what-if&amp;rdquo; scenarios.
We could for instance add some transaction data tx8 to a Person molecule to see if we would get the extected persons back:
Person.name.likes.getWith(&amp;lt;tx8Data&amp;gt;) === ... // Persons after applying tx8 Applying transaction data To make it easier to supply transaction data to the getWith(txData) method, you can simply add Tx to a Molecule transaction function to get some valid transaction data:</description>
    </item>
    
    <item>
      <title>Aggregates</title>
      <link>http://scalamolecule.org/manual/attributes/aggregates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/attributes/aggregates/</guid>
      <description>Aggregates Core tests | Example tests
Molecule wraps Datomic&amp;rsquo;s native aggregate functions by applying special aggregate keyword objects to the attribute we want to aggregate on.
Aggregate functions either return a single value or a collection of values:
Aggregates returning a single value min/max Applying the min or max aggregate keyword object as a value to the age attribute returns the lowest/highest ages.
Person.age(min) // lowest age Person.age(max) // highest age min/max supports all attribute types.</description>
    </item>
    
    <item>
      <title>Entities</title>
      <link>http://scalamolecule.org/manual/entities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/entities/</guid>
      <description>Entities An entity in Datomic is a group of Datoms/facts that share an entity id:
Attributes with any seemingly unrelated namespaces can group as entities by simply sharing the entity id:
This demonstrates that Datomic/Molecule Namespaces are not like Tables in SQL. The above entity for instance has attributes asserted from 2 different namespaces that could be completely unrelated/have no reference to each other. Attributes from any number of namespaces could be asserted sharing the same entity id.</description>
    </item>
    
    <item>
      <title>Get Json</title>
      <link>http://scalamolecule.org/manual/crud/get-json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/crud/get-json/</guid>
      <description>Get Json formatted Data Tests&amp;hellip;
We can get data in json format directly from the database by calling getJson on a molecule. So instead of converting tuples of data to json with some 3rd party library we can call getJson and pass the json data string directly to an Angular table for instance.
Internally, Molecule builds the json string in a StringBuffer directly from the raw data coming from Datomic (with regards to types being quoted or not).</description>
    </item>
    
    <item>
      <title>Self-join</title>
      <link>http://scalamolecule.org/manual/relationships/self-join/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/relationships/self-join/</guid>
      <description>Self-join Please see the following Self-join examples of Molecule
Next CRUD operations&amp;hellip;</description>
    </item>
    
    <item>
      <title>Testing</title>
      <link>http://scalamolecule.org/manual/time/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/time/testing/</guid>
      <description>Testing TestDbAsOf, TestDbSince and TestDbWith
For more complex test scenarios we can use a &amp;ldquo;test database&amp;rdquo; where we can freely make multiple separate molecule queries against a temporary filtered database.
Test db All molecules expect an implicit connection object to be in scope. If we then set a temporary test database on such conn object we can subsequentially freely perform tests against this temporary filtered database as though it was a &amp;ldquo;branch&amp;rdquo; (think git).</description>
    </item>
    
    <item>
      <title>Parameterized</title>
      <link>http://scalamolecule.org/manual/attributes/parameterized/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/attributes/parameterized/</guid>
      <description>Parameterized Input-molecules Tests: 1 input, 2 inputs, 3 inputs
Molecules can be parameterized by applying the input placeholder ? as a value to an attribute. The molecule then expects input for that attribute at runtime.
By assigning parameterized &amp;ldquo;Input-molecules&amp;rdquo; to variables we can re-use those variables to query for similar data structures where only some data part varies:
// 1 input parameter val person = m(Person.name(?)) val john = person(&amp;quot;John&amp;quot;).get.head val lisa = person(&amp;quot;Lisa&amp;quot;).</description>
    </item>
    
    <item>
      <title>Relationships</title>
      <link>http://scalamolecule.org/manual/relationships/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/relationships/</guid>
      <description>Relationships Tests&amp;hellip;
To understand how Molecule treats relationships it is valuable to get an idea of how they work in Datomic.
Ref attributes connect entities A relationship in Datomic is simply when a ref attribute of entity A has an entity B id value. Then there is a relationship from A to B!
In the following example, entity 101 has a ref attribute :Person/home with a value 102. That makes the relationship between entity 101 and entity 102, or that Fred has an Address:</description>
    </item>
    
    <item>
      <title>Update</title>
      <link>http://scalamolecule.org/manual/crud/update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/crud/update/</guid>
      <description>Update data An &amp;ldquo;update&amp;rdquo; is a two-step process in Datomic:
 Retract old fact Assert new fact  Datomic doesn&amp;rsquo;t overwrite data. &amp;ldquo;Retract&amp;rdquo; is a statement that says &amp;ldquo;this data is no longer current&amp;rdquo; which means that it won&amp;rsquo;t turn up when you query for it as of now. If you query for it as of before you will see it!
Being able to see how data develops over time is a brillant core feature of Datomic.</description>
    </item>
    
    <item>
      <title>&#34;CRUD&#34;</title>
      <link>http://scalamolecule.org/manual/crud/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/crud/</guid>
      <description>&amp;ldquo;CRUD&amp;rdquo; Tests&amp;hellip;
The classical Create-Read-Update-Delete operations on data are a bit different using Datomic since it never overwrites or deletes data. Facts are only asserted or retracted in Datomic.
Molecule tries to bridge the vocabulary between these two worlds.
Transactions return TxReport All transactional operations on molecules return a TxReport with information about the transaction like what data was transacted and what entities were created and a timestamp of the transaction:</description>
    </item>
    
    <item>
      <title>Retract</title>
      <link>http://scalamolecule.org/manual/crud/retract/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/crud/retract/</guid>
      <description>Retract data Tests&amp;hellip;
In Datomic, retracting a fact saves a retracted Datom with the added operation set to false. Retracted datoms will not show up in queries of the current data. But if you query historical data with for instance asOf you&amp;rsquo;ll see what the value was before it was retracted. This mechanism provides Datomic with built-in auditing of all of its data since none is deleted!
Retract facts To retract individual attributre values apply empty parenthesises to the attribute we want to retract and then update the molecule:</description>
    </item>
    
    <item>
      <title>Transactions</title>
      <link>http://scalamolecule.org/manual/transactions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/transactions/</guid>
      <description>Transactions All assertions and retractions in Datomic happen within a transaction that guarantees ACID consistency. Along with the domain data involved, Datomic also automatically asserts a timestamp as part of a created Transaction entity for that transaction.
Say that we create a new person with entity id e5:
val e5 = Person.name(&amp;quot;Fred&amp;quot;).likes(&amp;quot;pizza&amp;quot;).save.eid Then the following assertions are made:
The 4th column of the quintuplets is the entity id of the transaction where the fact was asserted or retracted.</description>
    </item>
    
    <item>
      <title>Time</title>
      <link>http://scalamolecule.org/manual/time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/time/</guid>
      <description>Time Tests&amp;hellip;
Datomic has powerful ways of accessing the immutable data that accumulates over time in the database.
Molecule maps those to 5 data getters that we can illustrate with a time line of transactions.
The 5 ways of getting data have the following semantics:
 get - snapshot of tx 1-7 accumulated. This is the current view of the database (&amp;ldquo;as of now&amp;rdquo;) that we normally use. ☞ getAsOf(t4) - snapshot of tx 1-4 accumulated.</description>
    </item>
    
    <item>
      <title>Generic</title>
      <link>http://scalamolecule.org/manual/generic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/generic/</guid>
      <description>Generic attributes Tests&amp;hellip;
Molecule provides access to generic data about data and Schema with the following 7 generic interfaces (each with a little example - read more by clicking on each title):
Datom Get id of Ben entity with generic Datom attribute e
Person.e.name.get.head === (benEntityId, &amp;quot;Ben&amp;quot;) EAVT Index Attributes and values of entity e1
EAVT(e1).a.v.get === List( (&amp;quot;:Person/name&amp;quot;, &amp;quot;Ben&amp;quot;), (&amp;quot;:Person/age&amp;quot;, 42), (&amp;quot;:Golf/score&amp;quot;, 5.7) ) AVET Index Values, entities and transactions where attribute :Person/age is involved</description>
    </item>
    
    <item>
      <title>Debug</title>
      <link>http://scalamolecule.org/manual/debug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/manual/debug/</guid>
      <description>Debug molecules See debug docs&amp;hellip; 3 resources helping debugging molecules:
Show Datalog queries and data All molecule query commands have a corresponding debug command that will print debugging information to console.
 &amp;lt;molecule&amp;gt;.debugGet &amp;lt;molecule&amp;gt;.debugGetHistory &amp;lt;molecule&amp;gt;.debugGetAsOf(...) &amp;lt;molecule&amp;gt;.debugGetSince(...) &amp;lt;molecule&amp;gt;.debugGetWith(...)  Debug transactions Transactional operations can be debugged with the following methods:
 &amp;lt;molecule&amp;gt;.debugSave &amp;lt;molecule&amp;gt;.debugInsert(data...) &amp;lt;molecule&amp;gt;.debugUpdate &amp;lt;entityId&amp;gt;.debugRetract &amp;lt;entityId&amp;gt;.Tx(transactionMolecule).debugRetract debugRetract(entityIds, txMetaDataMolecules*)  Common errors and solutions List of possible compilation/runtime errors and solutions&amp;hellip;
Next Debug Datalog/data&amp;hellip;</description>
    </item>
    
    <item>
      <title>Changelog</title>
      <link>http://scalamolecule.org/changelog/</link>
      <pubDate>Sun, 20 Oct 2019 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/changelog/</guid>
      <description>Molecule changelog Github releases
 2020-05-17 v0.22.2 Upgrade to ScalaJS 1.1.0 2020-04-10 v0.22.1 Bugfix: Query optimization resolves fulltext search correctly 2020-04-07 v0.22.0 Automatic Query optimization 2019-12-20 v0.21.0 Optional nested data 2019-10-24 v0.20.0 Molecule for Scala.js 2019-10-20 v0.19.1 Date handling corrected 2019-09-22 v0.19.0 Cross-compiling to Scala 2.13.1 and 2.12.10 2019-05-17 v0.18.5 Adapting to sbt-molecule 0.8.1 2019-05-13 v0.18.4 Aggregates for card-many attributes 2019-04-02 v0.18.3 Bug fixes 2019-03-10 v0.18.2 Meta becomes Generic 2019-03-09 v0.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://scalamolecule.org/about/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/about/</guid>
      <description>About Creator Molecule is created by Marc Grue who both plays the double bass in the Gothenburg Symphony Orchestra of Sweden and programs a lot in Scala.
The plan is to use Molecule as the optimal database access DSL for a big website for all classical musicians that Marc works on.
Watch Molecule presentations

About Marc:
 marcgrue.com (not much there) Stackoverflow profile  Further development More developers are welcome to join with Pull requests and questions/discussions on gitter in the Molecule forum.</description>
    </item>
    
    <item>
      <title>Credits</title>
      <link>http://scalamolecule.org/credits/</link>
      <pubDate>Wed, 14 May 2014 02:13:50 +0000</pubDate>
      
      <guid>http://scalamolecule.org/credits/</guid>
      <description>Credits Author(s) Molecule is created by Marc Grue (bass player in the Gothenburg Symphony orchestra and a dedicated Scala programmer).
Inspired by  Rogue, type-safe Scala DSL for MongoDB Datomisca, a Scala API for Datomic SqlTyped, Embedding SQL as an external DSL into Scala JScala, Scala macro that produces JavaScript from Scala code Parboiled2, A macro-based PEG parser generator for Scala  </description>
    </item>
    
    <item>
      <title>Presentation</title>
      <link>http://scalamolecule.org/_presentation/presentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/_presentation/presentation/</guid>
      <description>Molecule presentation sample code snippets Person.id.nameMap.get.head === (101, Map( &amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;, &amp;quot;de&amp;quot; -&amp;gt; &amp;quot;Dmitri Schostakowitsch&amp;quot;, &amp;quot;fr&amp;quot; -&amp;gt; &amp;quot;Dmitri Chostakovitch&amp;quot; )) // By key Person.nameMapK(&amp;quot;fr&amp;quot;).get.head === &amp;quot;Dmitri Chostakovitch&amp;quot; // By value Person.id.nameMap_(&amp;quot;Dmitri Chostakovitch&amp;quot;).get.head === 101 Person.id.nameMap_(&amp;quot;.*Shosta.*&amp;quot;).get.head === 101 // By key and value Person.id.nameMap_(&amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;).get.head === 101 Person.id.nameMap_(&amp;quot;en&amp;quot;)(&amp;quot;.*Shosta.*&amp;quot;).get.head === 101 Person.id.nameMap.get.head === (101, Map( &amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;, &amp;quot;de&amp;quot; -&amp;gt; &amp;quot;Dmitri Schostakowitsch&amp;quot;, &amp;quot;fr&amp;quot; -&amp;gt; &amp;quot;Dmitri Chostakovitch&amp;quot; )) // By key Person.</description>
    </item>
    
    <item>
      <title>Presentation</title>
      <link>http://scalamolecule.org/_presentation/presentation1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/_presentation/presentation1/</guid>
      <description>Molecule presentation sample code snippets fredId.retract Person.name(&amp;quot;Fred&amp;quot;).get.size === 0 Person.id.nameMap.one === (101, Map( &amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;, &amp;quot;de&amp;quot; -&amp;gt; &amp;quot;Dmitri Schostakowitsch&amp;quot;, &amp;quot;fr&amp;quot; -&amp;gt; &amp;quot;Dmitri Chostakovitch&amp;quot; )) // By key Person.nameMapK(&amp;quot;fr&amp;quot;).one === &amp;quot;Dmitri Chostakovitch&amp;quot; // By value Person.id.nameMap_(&amp;quot;Dmitri Chostakovitch&amp;quot;).one === 101 Person.id.nameMap_(&amp;quot;.*Shosta.*&amp;quot;).one === 101 // By key and value Person.id.nameMap_(&amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;).one === 101 Person.id.nameMap_(&amp;quot;en&amp;quot;)(&amp;quot;.*Shosta.*&amp;quot;).one === 101 Person.id.nameMap.one === (101, Map( &amp;quot;en&amp;quot; -&amp;gt; &amp;quot;Dmitri Shostakovich&amp;quot;, &amp;quot;de&amp;quot; -&amp;gt; &amp;quot;Dmitri Schostakowitsch&amp;quot;, &amp;quot;fr&amp;quot; -&amp;gt; &amp;quot;Dmitri Chostakovitch&amp;quot; )) // By key Person.</description>
    </item>
    
    <item>
      <title>Tutorials</title>
      <link>http://scalamolecule.org/resources/tutorials/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/resources/tutorials/</guid>
      <description>Molecule tutorials  Seattle tutorial - all-round introduction to using Molecule  </description>
    </item>
    
    <item>
      <title>Videos</title>
      <link>http://scalamolecule.org/resources/videos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://scalamolecule.org/resources/videos/</guid>
      <description>Molecule videos  Scala Meetup presentation 2017-04-25 by Marc Grue  Part 1: Datomic data model Part 2: Building a DSL with Scala macros Part 3: Tour of Molecule features Part 4: Molecule domain modelling    </description>
    </item>
    
  </channel>
</rss>