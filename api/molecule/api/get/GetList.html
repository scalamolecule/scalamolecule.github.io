<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Molecule 0.22.8 - molecule.api.get.GetList</title><meta content="Molecule 0.22.8 - molecule.api.get.GetList" name="description"/><meta content="Molecule 0.22.8 molecule.api.get.GetList" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript" src="https://d3js.org/d3.v4.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title">Molecule<span id="doc-version">0.22.8</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><p class="shortcomment cmt"><img src="http://www.scalamolecule.org/img/logo/MoleculeLogo200.png"></p><div class="fullcomment"><div class="comment cmt"><p><img src="http://www.scalamolecule.org/img/logo/MoleculeLogo200.png"></p><p>Documentation/API for the Molecule library - a meta DSL for the <a href="https://www.datomic.com" target="_blank">Datomic</a> database.</p><p><a href="http://www.scalamolecule.org" target="_blank">Manual</a> |
<a href="http://www.scalamolecule.org" target="_blank">scalamolecule.org</a> |
<a href="https://github.com/scalamolecule/molecule" target="_blank">Github</a> |
<a href="https://groups.google.com/forum/#!forum/molecule-dsl" target="_blank">Forum</a></p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.molecule" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="molecule"></a><a id="molecule:molecule"></a> <span class="permalink"><a href="../../../molecule/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title="Molecule library - a Scala meta-DSL for the Datomic database."><span class="name">molecule</span></a></span><p class="shortcomment cmt"><a href="http://www.scalamolecule.org" target="_blank">Molecule</a> library - a Scala meta-DSL for the <a href="https://www.datomic.com" target="_blank">Datomic</a> database.</p><div class="fullcomment"><div class="comment cmt"><p><a href="http://www.scalamolecule.org" target="_blank">Molecule</a> library - a Scala meta-DSL for the <a href="https://www.datomic.com" target="_blank">Datomic</a> database.</p><p>See <a href="../index.html" name="molecule.api" id="molecule.api" class="extype">api</a> package for various api imports to start using Molecule.</p><h4> Sub-packages </h4><p><table>
  <tr>
    <td><a href="api/index.html">api</a><td>
    <td>Molecule API.</td>
  </tr>
  <tr>
    <td><a href="ast/index.html">ast</a><td>
    <td style="color:#888">Internal Molecule ASTs.</td>
  </tr>
  <tr>
    <td><a href="boilerplate/index.html">boilerplate</a><td>
    <td style="color:#888">Internal interfaces for auto-generated DSL boilerplate code.</td>
  </tr>
  <tr>
    <td><a href="composition/index.html">composition</a>&nbsp;&nbsp;&nbsp;<td>
    <td>Builder methods to compose molecules.</td>
  </tr>
  <tr>
    <td><a href="exception/index.html">exceptions</a><td>
    <td>Exceptions thrown by Molecule.</td>
  </tr>
  <tr>
    <td><a href="expression/index.html">expression</a><td>
    <td>Attribute expressions and operations.</td>
  </tr>
  <tr>
    <td><a href="facade/index.html">facade</a><td>
    <td>Molecule facades to Datomic.</td>
  </tr>
  <tr>
    <td><a href="factory/index.html">factory</a><td>
    <td>Implicit macro methods `m` to instantiate molecules from custom DSL molecule constructs.</td>
  </tr>
  <tr>
    <td><a href="input/index.html">input</a><td>
    <td>Input molecules awaiting input.</td>
  </tr>
  <tr>
    <td><a href="macro/index.html">macros</a><td>
    <td style="color:#888">Internal macros generating molecule code from custom DSL molecule constructs.</td>
  </tr>
  <tr>
    <td><a href="generic/index.html">generic</a><td>
    <td>Interfaces to generic information about datoms and Datomic database.</td>
  </tr>
  <tr>
    <td><a href="ops/index.html">ops</a><td>
    <td style="color:#888">Internal operational helpers for transforming DSL to molecule.</td>
  </tr>
  <tr>
    <td><a href="schema/index.html">schema</a><td>
    <td>Schema definition DSL.</td>
  </tr>
  <tr>
    <td><a href="ops/index.html">transform</a><td>
    <td style="color:#888">Internal transformers from DSL to Model/Query/Transaction.</td>
  </tr>
  <tr>
    <td><a href="util/index.html">util</a><td>
    <td style="color:#888">Internal Java database functions for Datomic.</td>
  </tr>
</table>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="molecule.api" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="api"></a><a id="api:api"></a> <span class="permalink"><a href="../../../molecule/api/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">api</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="molecule" id="molecule" class="extype">molecule</a></dd></dl></div></li><li class="indented3 " name="molecule.api.get" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="get"></a><a id="get:get"></a> <span class="permalink"><a href="../../../molecule/api/get/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title="Synchronous getter methods to retrieve data from Datomic."><span class="name">get</span></a></span><p class="shortcomment cmt">Synchronous getter methods to retrieve data from Datomic.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous getter methods to retrieve data from Datomic.</p><p>The Datomic On-Prem(ises) server model provides a Peer that returns data synchronously.
The Peer which lives in application memory caches data aggressively and for data
fitting in memory latency can be extremely low and queries return very fast. And
even when access to disk is needed, clever branching is used. Memcached is also
an option.</p><p>The Datomic Cloud model data returns data asynchronously. If Datomic creates a
Java API for the Cloud model, Molecule could relatively easy adapt to this model too.
In the meanwhile, Future-wrapped methods in this package can be used.</p><p>Molecule has 5 groups of synchronous getters, each returning data in various formats:</p><ul><li><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a> - fastest retrieved typed data set. Can be traversed with a fast <code>while</code> loop</li><li><a href="GetIterable.html" name="molecule.api.get.GetIterable" id="molecule.api.get.GetIterable" class="extype">GetIterable</a> - for lazily traversing row by row</li><li><a href="GetJson.html" name="molecule.api.get.GetJson" id="molecule.api.get.GetJson" class="extype">GetJson</a> - data formatted as Json string</li><li><a href="" name="molecule.api.get.GetList" id="molecule.api.get.GetList" class="extype">GetList</a> - default getter returning Lists of tuples. Convenient typed data, suitable for smaller data sets</li><li><a href="GetRaw.html" name="molecule.api.get.GetRaw" id="molecule.api.get.GetRaw" class="extype">GetRaw</a> - fastest retrieved raw un-typed data from Datomic</li></ul><p>Getters in each of the 5 groups come with 5 time-dependent variations:</p><ul><li>get [current data]</li><li>getAsOf</li><li>getSince</li><li>getWith</li><li>getHistory</li></ul><p>Each time variation has various overloads taking different parameters (see each group for more info).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="molecule.api" id="molecule.api" class="extype">api</a></dd><dt>See also</dt><dd><span class="cmt"><p>equivalent asynchronous getters in the <a href="../getAsync/index.html" name="molecule.api.getAsync" id="molecule.api.getAsync" class="extype">getAsync</a> package.</p></span></dd></dl></div></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetArray.html" title="Data getter methods on molecules returning Array[Tpl]." class="trait"></a><a href="GetArray.html" title="Data getter methods on molecules returning Array[Tpl].">GetArray</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetIterable.html" title="Data getter methods on molecules that return Iterable[Tpl]." class="trait"></a><a href="GetIterable.html" title="Data getter methods on molecules that return Iterable[Tpl].">GetIterable</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetJson.html" title="Data getter methods on molecules that return a Json String." class="trait"></a><a href="GetJson.html" title="Data getter methods on molecules that return a Json String.">GetJson</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="" title="Default data getter methods on molecules that return List[Tpl]." class="trait"></a><a href="" title="Default data getter methods on molecules that return List[Tpl].">GetList</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetRaw.html" title="Data getter methods on molecules that return raw untyped Datomic data." class="trait"></a><a href="GetRaw.html" title="Data getter methods on molecules that return raw untyped Datomic data.">GetRaw</a></li></ul></div></div><div id="content"><body class="trait type"><div id="definition"><div class="big-circle trait">t</div><p id="owner"><a href="../../index.html" name="molecule" id="molecule" class="extype">molecule</a>.<a href="../index.html" name="molecule.api" id="molecule.api" class="extype">api</a>.<a href="index.html" name="molecule.api.get" id="molecule.api.get" class="extype">get</a></p><h1>GetList<span class="permalink"><a href="../../../molecule/api/get/GetList.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><span class="name">GetList</span><span class="tparams">[<span name="Tpl">Tpl</span>]</span><span class="result"> extends <a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Default data getter methods on molecules that return List[Tpl].
<br><br>
For expected smaller result sets it's convenient to return Lists of tuples of data.
Considered as the default getter, no postfix has been added (<code>get</code> instead of <code>getList</code>).
</p></div><dl class="attributes block"><dt>Self Type</dt><dd><a href="../Molecule.html" name="molecule.api.Molecule" id="molecule.api.Molecule" class="extype">Molecule</a>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</dd><dt>Source</dt><dd><a href="https://github.com/scalamolecule/molecule/tree/master/molecule/jvm/src/main/scala-2.13+/molecule/api/get/GetList.scala#L1" target="_blank">GetList.scala</a></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>], <span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div><div class="toggleContainer"><div class="toggle block"><span>Known Subclasses</span><div class="subClasses hiddenContent"><a href="../Molecule.html" name="molecule.api.Molecule" id="molecule.api.Molecule" class="extype">Molecule</a>, <a href="../Molecule$$Molecule01.html" name="molecule.api.Molecule.Molecule01" id="molecule.api.Molecule.Molecule01" class="extype">Molecule01</a>, <a href="../Molecule$$Molecule02.html" name="molecule.api.Molecule.Molecule02" id="molecule.api.Molecule.Molecule02" class="extype">Molecule02</a>, <a href="../Molecule$$Molecule03.html" name="molecule.api.Molecule.Molecule03" id="molecule.api.Molecule.Molecule03" class="extype">Molecule03</a>, <a href="../Molecule$$Molecule04.html" name="molecule.api.Molecule.Molecule04" id="molecule.api.Molecule.Molecule04" class="extype">Molecule04</a>, <a href="../Molecule$$Molecule05.html" name="molecule.api.Molecule.Molecule05" id="molecule.api.Molecule.Molecule05" class="extype">Molecule05</a>, <a href="../Molecule$$Molecule06.html" name="molecule.api.Molecule.Molecule06" id="molecule.api.Molecule.Molecule06" class="extype">Molecule06</a>, <a href="../Molecule$$Molecule07.html" name="molecule.api.Molecule.Molecule07" id="molecule.api.Molecule.Molecule07" class="extype">Molecule07</a>, <a href="../Molecule$$Molecule08.html" name="molecule.api.Molecule.Molecule08" id="molecule.api.Molecule.Molecule08" class="extype">Molecule08</a>, <a href="../Molecule$$Molecule09.html" name="molecule.api.Molecule.Molecule09" id="molecule.api.Molecule.Molecule09" class="extype">Molecule09</a>, <a href="../Molecule$$Molecule10.html" name="molecule.api.Molecule.Molecule10" id="molecule.api.Molecule.Molecule10" class="extype">Molecule10</a>, <a href="../Molecule$$Molecule11.html" name="molecule.api.Molecule.Molecule11" id="molecule.api.Molecule.Molecule11" class="extype">Molecule11</a>, <a href="../Molecule$$Molecule12.html" name="molecule.api.Molecule.Molecule12" id="molecule.api.Molecule.Molecule12" class="extype">Molecule12</a>, <a href="../Molecule$$Molecule13.html" name="molecule.api.Molecule.Molecule13" id="molecule.api.Molecule.Molecule13" class="extype">Molecule13</a>, <a href="../Molecule$$Molecule14.html" name="molecule.api.Molecule.Molecule14" id="molecule.api.Molecule.Molecule14" class="extype">Molecule14</a>, <a href="../Molecule$$Molecule15.html" name="molecule.api.Molecule.Molecule15" id="molecule.api.Molecule.Molecule15" class="extype">Molecule15</a>, <a href="../Molecule$$Molecule16.html" name="molecule.api.Molecule.Molecule16" id="molecule.api.Molecule.Molecule16" class="extype">Molecule16</a>, <a href="../Molecule$$Molecule17.html" name="molecule.api.Molecule.Molecule17" id="molecule.api.Molecule.Molecule17" class="extype">Molecule17</a>, <a href="../Molecule$$Molecule18.html" name="molecule.api.Molecule.Molecule18" id="molecule.api.Molecule.Molecule18" class="extype">Molecule18</a>, <a href="../Molecule$$Molecule19.html" name="molecule.api.Molecule.Molecule19" id="molecule.api.Molecule.Molecule19" class="extype">Molecule19</a>, <a href="../Molecule$$Molecule20.html" name="molecule.api.Molecule.Molecule20" id="molecule.api.Molecule.Molecule20" class="extype">Molecule20</a>, <a href="../Molecule$$Molecule21.html" name="molecule.api.Molecule.Molecule21" id="molecule.api.Molecule.Molecule21" class="extype">Molecule21</a>, <a href="../Molecule$$Molecule22.html" name="molecule.api.Molecule.Molecule22" id="molecule.api.Molecule.Molecule22" class="extype">Molecule22</a></div></div></div><div id="inheritance-diagram-container" class="toggleContainer block diagram-container"><span class="toggle diagram-link">Type Hierarchy</span><div id="inheritance-diagram" class="diagram hiddenContent"><svg id="graph1" class="class-diagram" width="800" height="600"></svg><script type="text/dot" id="dot1">
digraph G {
  
  subgraph clusterAll {
  style = "invis"
  
  subgraph clusterThis {
  style="invis"
  node0 [URL="#inheritance-diagram-container", label="GetList[Tpl]", id="graph1_0", class="this trait", tooltip="molecule.api.get.GetList (this trait)"] ;
}
  
  
  
}
  
  node1 [URL="../Molecule.html#inheritance-diagram-container", label="Molecule[Tpl]", id="graph1_1", class="default", tooltip="molecule.api.Molecule"] ;
  node2 [URL="GetArray.html#inheritance-diagram-container", label="GetArray[Tpl]", id="graph1_2", class="default", tooltip="molecule.api.get.GetArray"] ;
  node2 -> node0 [arrowtail="empty", dir="back", id="graph1_2_0", class="inheritance", tooltip="GetList[Tpl] is a subtype of GetArray[Tpl]"] ;
  node0 -> node1 [arrowtail="empty", dir="back", id="graph1_0_1", class="inheritance", tooltip="Molecule[Tpl] is a subtype of GetList[Tpl]"] ;
}
</script><script>$("#inheritance-diagram").bind('beforeShow', function() {
  if ($("svg#graph1").children().length == 0) {
    var dot = document.querySelector("#dot1").text;
    var svg = d3.select("#graph1");
    var inner = svg.append("g");

    // Set up zoom support
    var zoom = d3.zoom()
        .on("zoom", function() {
          inner.attr("transform", d3.event.transform);
        });
    svg.call(zoom);

    var render = new dagreD3.render();
    var g = graphlibDot.read(dot);
    render(inner, g);

    inner.selectAll("g.node").each(function(v) {
      // https://stackoverflow.com/questions/27381452/wrapping-existing-inline-svg-g-element-with-a-element
      var tgt = $("#"+ g.node(v).id +" g.label text")[0];
      var parent = tgt.parentNode;
      var a = document.createElementNS('http://www.w3.org/2000/svg', 'a');
      a.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', g.node(v).URL);
      a.appendChild(tgt);
      parent.appendChild(a);
    });
  }
})</script></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="group out"><span>Grouped</span></li><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="molecule.api.get.GetList"><span>GetList</span></li><li class="in" name="molecule.api.get.GetArray"><span>GetArray</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object"></a><a id="clone():AnyRef"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean"></a><a id="equals(AnyRef):Boolean"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#get" group="get" fullComment="yes" data-isabs="false" visbl="pub"><a id="get(n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="get(Int)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#get(n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">get</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule.
<br><br>
Only n rows are type-casted.</p><pre>Person.name.age.get(<span class="num">1</span>) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>)
)</pre><p>Since retrieving a List is considered the default fetch format, the getter method is
simply named <code>get</code> (and not <code>getList</code>).
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of types matching the attributes of the molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsync(n:Int)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsync" id="molecule.api.getAsync.GetAsyncList#getAsync" class="extmbr">getAsync</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#get" group="get" fullComment="yes" data-isabs="false" visbl="pub"><a id="get(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="get(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#get(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">get</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule.</p><pre>Person.name.age.get === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>),
)</pre><p>Since retrieving a List is considered the default fetch format, the getter method is
simply named <code>get</code> (and not <code>getList</code>).
</p></div><dl class="paramcmts block"><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of types matching the attributes of the molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsync(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsync" id="molecule.api.getAsync.GetAsyncList#getAsync" class="extmbr">getAsync</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArray" group="get" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArray(n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArray(Int)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArray(n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArray</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule.</p><pre>Person.name.age.getArray(<span class="num">1</span>) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>)
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples. Setting n to -1 fetches
all rows (same as calling <code>getArray</code> without any number of rows parameter).
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>Number of rows. If -1, all rows are fetched.</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of types matching the attributes of the molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArray(n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArray" id="molecule.api.getAsync.GetAsyncArray#getAsyncArray" class="extmbr">getAsyncArray</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArray" group="get" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArray(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArray(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArray(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArray</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule.</p><pre>Person.name.age.getArray === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of types matching the attributes of the molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArray(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArray" id="molecule.api.getAsync.GetAsyncArray#getAsyncArray" class="extmbr">getAsyncArray</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayAsOf" group="getArrayAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayAsOf(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayAsOf(Date,Int)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayAsOf(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayAsOf</span><span class="params">(<span name="date">date: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#java.util.Date" name="java.util.Date" id="java.util.Date" class="extype">Date</a></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule as of date.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule as of date.
<br><br>
Get data at a human point in time (a java.util.Date).</p><pre><span class="kw">val</span> beforeInsert = <span class="kw">new</span> java.util.Date

<span class="cmt">// Insert</span>
<span class="kw">val</span> tx1 = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = tx1.eids
<span class="kw">val</span> afterInsert = <span class="kw">new</span> java.util.Date

<span class="cmt">// Update</span>
<span class="kw">val</span> tx2 = Person(ben).age(<span class="num">43</span>).update
<span class="kw">val</span> afterUpdate = <span class="kw">new</span> java.util.Date

<span class="cmt">// Get Array of all rows as of afterUpdate</span>
Person.name.age.getArrayAsOf(afterUpdate) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of n rows as of afterUpdate</span>
Person.name.age.getArrayAsOf(afterUpdate, <span class="num">1</span>) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>)
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples.
</p></div><dl class="paramcmts block"><dt class="param">date</dt><dd class="cmt"><p>java.util.Date</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayAsOf(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" class="extmbr">getAsyncArrayAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayAsOf" group="getArrayAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayAsOf(date:java.util.Date)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayAsOf(Date)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayAsOf(date:java.util.Date)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayAsOf</span><span class="params">(<span name="date">date: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#java.util.Date" name="java.util.Date" id="java.util.Date" class="extype">Date</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule as of date.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule as of date.
<br><br>
Get data at a human point in time (a java.util.Date).</p><pre><span class="kw">val</span> beforeInsert = <span class="kw">new</span> java.util.Date

<span class="cmt">// Insert</span>
<span class="kw">val</span> tx1 = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = tx1.eids
<span class="kw">val</span> afterInsert = <span class="kw">new</span> java.util.Date

<span class="cmt">// Update</span>
<span class="kw">val</span> tx2 = Person(ben).age(<span class="num">43</span>).update
<span class="kw">val</span> afterUpdate = <span class="kw">new</span> java.util.Date

<span class="cmt">// Retract</span>
<span class="kw">val</span> tx3 = ben.retract
<span class="kw">val</span> afterRetract = <span class="kw">new</span> java.util.Date

<span class="cmt">// No data yet before insert</span>
Person.name.age.getArrayAsOf(beforeInsert) === <span class="std">Array</span>()

<span class="cmt">// Get Array of all rows as of afterInsert</span>
Person.name.age.getArrayAsOf(afterInsert) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of all rows as of afterUpdate</span>
Person.name.age.getArrayAsOf(afterUpdate) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>), <span class="cmt">// Ben now 43</span>
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of all rows as of afterRetract</span>
Person.name.age.getArrayAsOf(afterRetract) === <span class="std">Array</span>(
  (<span class="lit">"Liz"</span>, <span class="num">37</span>) <span class="cmt">// Ben gone</span>
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">date</dt><dd class="cmt"><p>java.util.Date</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayAsOf(date:java.util.Date)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" class="extmbr">getAsyncArrayAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayAsOf" group="getArrayAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayAsOf(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayAsOf(TxReport,Int)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayAsOf(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayAsOf</span><span class="params">(<span name="tx">tx: <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule as of tx.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule as of tx.
<br><br>
Datomic's internal <code>asOf</code> method can take a transaction entity id as argument to retrieve a database
value as of that transaction (including).
<br><br>
Instead of supplying the transaction entity id, in Molecule we supply a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a>
that contains the transaction entity id (which is used as argument to Datomic internally). This is more
convenient when using Molecule since we get a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> from transaction
operations like <code>get</code>, <code>update</code>, <code>retract</code> etc.</p><pre><span class="cmt">// Insert (tx report 1)</span>
<span class="kw">val</span> tx1 = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = tx1.eids

<span class="cmt">// Update (tx report 2)</span>
<span class="kw">val</span> tx2 = Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// Get Array of all rows as of tx2 (after update)</span>
Person.name.age.getArrayAsOf(tx2) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of n rows as of tx2 (after update)</span>
Person.name.age.getArrayAsOf(tx2, <span class="num">1</span>) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>)
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples.
</p></div><dl class="paramcmts block"><dt class="param">tx</dt><dd class="cmt"><p><a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> (returned from all molecule transaction operations)</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayAsOf(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" class="extmbr">getAsyncArrayAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayAsOf" group="getArrayAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayAsOf(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayAsOf(TxReport)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayAsOf(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayAsOf</span><span class="params">(<span name="tx">tx: <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule as of tx.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule as of tx.
<br><br>
Datomic's internal <code>asOf</code> method can take a transaction entity id as argument to retrieve
a database value as of that transaction (including).
<br><br>
Instead of supplying the transaction entity id, in Molecule we supply a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a>
that contains the transaction entity id (which is used as argument to Datomic internally). This is more
convenient when using Molecule since we get a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> from transaction
operations like <code>get</code>, <code>update</code>, <code>retract</code> etc.</p><pre><span class="cmt">// Insert (tx report 1)</span>
<span class="kw">val</span> tx1 = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = tx1.eids

<span class="cmt">// Update (tx report 2)</span>
<span class="kw">val</span> tx2 = Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// Retract (tx report 3)</span>
<span class="kw">val</span> tx3 = ben.retract

<span class="cmt">// Get Array of all rows as of tx1 (after insert)</span>
Person.name.age.getArrayAsOf(tx1) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of all rows as of tx2 (after update)</span>
Person.name.age.getArrayAsOf(tx2) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>), <span class="cmt">// Ben now 43</span>
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of all rows as of tx3 (after retract)</span>
Person.name.age.getArrayAsOf(tx3) === <span class="std">Array</span>(
  (<span class="lit">"Liz"</span>, <span class="num">37</span>) <span class="cmt">// Ben gone</span>
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">tx</dt><dd class="cmt"><p><a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> (returned from all molecule transaction operations)</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayAsOf(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" class="extmbr">getAsyncArrayAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayAsOf" group="getArrayAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayAsOf(t:Long,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayAsOf(Long,Int)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayAsOf(t:Long,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayAsOf</span><span class="params">(<span name="t">t: <span name="scala.Long" class="extype">Long</span></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule as of transaction time <code>t</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule as of transaction time <code>t</code>.
<br><br>
Transaction time <code>t</code> is an auto-incremented transaction number assigned internally by Datomic.
<br><br>
<code>t</code> can for instance be retrieved in a getHistory call for an attribute and then be
used to get data as of that point in time (including that transaction):</p><pre><span class="cmt">// Insert (t 1028)</span>
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
) eids

<span class="cmt">// Update (t 1031)</span>
Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// History of Ben</span>
Person(ben).age.t.op.getHistory.sortBy(r <span class="kw">=&gt;</span> (r._2, r._3)) === <span class="std">List</span>(
  (<span class="num">42</span>, <span class="num">1028</span>, <span class="kw">true</span>),  <span class="cmt">// Insert:  42 asserted</span>
  (<span class="num">42</span>, <span class="num">1031</span>, <span class="kw">false</span>), <span class="cmt">// Update:  42 retracted</span>
  (<span class="num">43</span>, <span class="num">1031</span>, <span class="kw">true</span>),  <span class="cmt">//          43 asserted</span>
)

<span class="cmt">// Get Array of all rows as of transaction t 1031 (after update)</span>
Person.name.age.getArrayAsOf(<span class="num">1031</span>) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of n rows as of transaction t 1031 (after update)</span>
Person.name.age.getArrayAsOf(<span class="num">1031</span>, <span class="num">1</span>) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>)
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Long Transaction time t</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayAsOf(t:Long,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" class="extmbr">getAsyncArrayAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayAsOf" group="getArrayAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayAsOf(t:Long)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayAsOf(Long)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayAsOf(t:Long)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayAsOf</span><span class="params">(<span name="t">t: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule as of transaction time <code>t</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule as of transaction time <code>t</code>.
<br><br>
Transaction time <code>t</code> is an auto-incremented transaction number assigned internally by Datomic.
<br><br>
<code>t</code> can for instance be retrieved in a getHistory call for an attribute and then be
used to get data as of that point in time (including that transaction):</p><pre><span class="cmt">// Insert (t 1028)</span>
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
) eids

<span class="cmt">// Update (t 1031)</span>
Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// Retract (t 1032)</span>
ben.retract

<span class="cmt">// History of Ben</span>
Person(ben).age.t.op.getHistory.sortBy(r <span class="kw">=&gt;</span> (r._2, r._3)) === <span class="std">List</span>(
  (<span class="num">42</span>, <span class="num">1028</span>, <span class="kw">true</span>),  <span class="cmt">// Insert:  42 asserted</span>
  (<span class="num">42</span>, <span class="num">1031</span>, <span class="kw">false</span>), <span class="cmt">// Update:  42 retracted</span>
  (<span class="num">43</span>, <span class="num">1031</span>, <span class="kw">true</span>),  <span class="cmt">//          43 asserted</span>
  (<span class="num">43</span>, <span class="num">1032</span>, <span class="kw">false</span>)  <span class="cmt">// Retract: 43 retracted</span>
)

<span class="cmt">// Get Array of data as of transaction t 1028 (after insert)</span>
Person.name.age.getArrayAsOf(<span class="num">1028</span>) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of all rows as of transaction t 1031 (after update)</span>
Person.name.age.getArrayAsOf(<span class="num">1031</span>) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get Array of all rows as of transaction t 1032 (after retract)</span>
Person.name.age.getArrayAsOf(<span class="num">1032</span>) === <span class="std">Array</span>(
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Transaction time t</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayAsOf(t:Long)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayAsOf" class="extmbr">getAsyncArrayAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArraySince" group="getArraySince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArraySince(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArraySince(Date,Int)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArraySince(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArraySince</span><span class="params">(<span name="date">date: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#java.util.Date" name="java.util.Date" id="java.util.Date" class="extype">Date</a></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule since date.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule since date.
<br><br>
Get data added/retracted since a human point in time (a java.util.Date).</p><pre><span class="cmt">// Transact 3 times (`inst` retrieves transaction time/Date from tx report)</span>
<span class="kw">val</span> date1 = Person.name(<span class="lit">"Ann"</span>).save.inst
<span class="kw">val</span> date2 = Person.name(<span class="lit">"Ben"</span>).save.inst
<span class="kw">val</span> date3 = Person.name(<span class="lit">"Cay"</span>).save.inst

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since date1</span>
Person.name.getArraySince(date1) === <span class="std">Array</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since date1 - only n (1) rows returned</span>
Person.name.getArraySince(date1, <span class="num">1</span>) === <span class="std">Array</span>(<span class="lit">"Ben"</span>)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples.
</p></div><dl class="paramcmts block"><dt class="param">date</dt><dd class="cmt"><p>java.util.Date</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArraySince(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" id="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" class="extmbr">getAsyncArraySince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArraySince" group="getArraySince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArraySince(date:java.util.Date)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArraySince(Date)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArraySince(date:java.util.Date)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArraySince</span><span class="params">(<span name="date">date: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#java.util.Date" name="java.util.Date" id="java.util.Date" class="extype">Date</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule since date.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule since date.
<br><br>
Get data added/retracted since a human point in time (a java.util.Date).</p><pre><span class="cmt">// Transact 3 times (`inst` retrieves transaction time/Date from tx report)</span>
<span class="kw">val</span> date1 = Person.name(<span class="lit">"Ann"</span>).save.inst
<span class="kw">val</span> date2 = Person.name(<span class="lit">"Ben"</span>).save.inst
<span class="kw">val</span> date3 = Person.name(<span class="lit">"Cay"</span>).save.inst

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since date1</span>
Person.name.getArraySince(date1) === <span class="std">Array</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Cay added since date2</span>
Person.name.getArraySince(date2) === <span class="std">Array</span>(<span class="lit">"Cay"</span>)

<span class="cmt">// Nothing added since date3</span>
Person.name.getArraySince(date3) === Nil</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">date</dt><dd class="cmt"><p>java.util.Date</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArraySince(date:java.util.Date)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" id="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" class="extmbr">getAsyncArraySince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArraySince" group="getArraySince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArraySince(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArraySince(TxReport,Int)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArraySince(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArraySince</span><span class="params">(<span name="tx">tx: <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule since tx.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule since tx.
<br><br>
Datomic's internal <code>since</code> can take a transaction entity id as argument to retrieve a database
value since that transaction (excluding the transaction itself).
<br><br>
Instead of supplying the transaction entity id, in Molecule we supply a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> that contains
the transaction entity id (which is used as argument to Datomic internally). This is more convenient when using Molecule since we
getAsync a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> from transaction operations like <code>get</code>, <code>update</code>, <code>retract</code> etc.</p><pre><span class="cmt">// Get tx reports for 3 transactions</span>
<span class="kw">val</span> tx1 = Person.name(<span class="lit">"Ann"</span>).save
<span class="kw">val</span> tx2 = Person.name(<span class="lit">"Ben"</span>).save
<span class="kw">val</span> tx3 = Person.name(<span class="lit">"Cay"</span>).save

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since tx1</span>
Person.name.getArraySince(tx1) === <span class="std">Array</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since tx1 - only n (1) rows returned</span>
Person.name.getArraySince(tx1, <span class="num">1</span>) === <span class="std">Array</span>(<span class="lit">"Ben"</span>)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples.
</p></div><dl class="paramcmts block"><dt class="param">tx</dt><dd class="cmt"><p><a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArraySince(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" id="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" class="extmbr">getAsyncArraySince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArraySince" group="getArraySince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArraySince(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArraySince(TxReport)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArraySince(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArraySince</span><span class="params">(<span name="tx">tx: <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule since tx.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule since tx.
<br><br>
Datomic's internal <code>since</code> can take a transaction entity id as argument to retrieve a database
value since that transaction (excluding the transaction itself).
<br><br>
Instead of supplying the transaction entity id, in Molecule we supply a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> that contains
the transaction entity id (which is used as argument to Datomic internally). This is more convenient when using Molecule since we
getAsync a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> from transaction operations like <code>get</code>, <code>update</code>, <code>retract</code> etc.</p><pre><span class="cmt">// Get tx reports for 3 transactions</span>
<span class="kw">val</span> tx1 = Person.name(<span class="lit">"Ann"</span>).save
<span class="kw">val</span> tx2 = Person.name(<span class="lit">"Ben"</span>).save
<span class="kw">val</span> tx3 = Person.name(<span class="lit">"Cay"</span>).save

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since tx1</span>
Person.name.getArraySince(tx1) === <span class="std">Array</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Cay added since tx2</span>
Person.name.getArraySince(tx2) === <span class="std">Array</span>(<span class="lit">"Cay"</span>)

<span class="cmt">// Nothing added since tx3</span>
Person.name.getArraySince(tx3) === Nil</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">tx</dt><dd class="cmt"><p><a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArraySince(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" id="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" class="extmbr">getAsyncArraySince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArraySince" group="getArraySince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArraySince(t:Long,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArraySince(Long,Int)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArraySince(t:Long,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArraySince</span><span class="params">(<span name="t">t: <span name="scala.Long" class="extype">Long</span></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule since transaction time <code>t</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule since transaction time <code>t</code>.
<br><br>
Transaction time <code>t</code> is an auto-incremented transaction number assigned internally by Datomic.
<br><br>
<code>t</code> can for instance be retrieved by calling <code>t</code> on the tx report returned from transactional operations
and then be used to get data since that point in time (excluding that transaction):</p><pre><span class="cmt">// 3 transaction times `t`</span>
<span class="kw">val</span> t1 = Person.name(<span class="lit">"Ann"</span>).save.t
<span class="kw">val</span> t2 = Person.name(<span class="lit">"Ben"</span>).save.t
<span class="kw">val</span> t3 = Person.name(<span class="lit">"Cay"</span>).save.t

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since transaction time t 1028</span>
Person.name.getArraySince(t1) === <span class="std">Array</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since transaction time t 1028 - only n (1) rows returned</span>
Person.name.getArraySince(t1, <span class="num">1</span>) === <span class="std">Array</span>(<span class="lit">"Ben"</span>)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Transaction time t</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArraySince(t:Long,n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" id="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" class="extmbr">getAsyncArraySince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArraySince" group="getArraySince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArraySince(t:Long)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArraySince(Long)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArraySince(t:Long)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArraySince</span><span class="params">(<span name="t">t: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule since transaction time <code>t</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule since transaction time <code>t</code>.
<br><br>
Transaction time <code>t</code> is an auto-incremented transaction number assigned internally by Datomic.
<br><br>
<code>t</code> can for instance be retrieved by calling <code>t</code> on the tx report returned from transactional operations
and then be used to get data since that point in time (excluding that transaction):</p><pre><span class="cmt">// 3 transaction times `t`</span>
<span class="kw">val</span> t1 = Person.name(<span class="lit">"Ann"</span>).save.t
<span class="kw">val</span> t2 = Person.name(<span class="lit">"Ben"</span>).save.t
<span class="kw">val</span> t3 = Person.name(<span class="lit">"Cay"</span>).save.t

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since transaction time t 1028</span>
Person.name.getArraySince(t1) === <span class="std">Array</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Cay added since transaction time t 1030</span>
Person.name.getArraySince(t2) === <span class="std">Array</span>(<span class="lit">"Cay"</span>)

<span class="cmt">// Nothing added since transaction time t 1032</span>
Person.name.getArraySince(t3) === Nil</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Transaction time t</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArraySince(t:Long)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" id="molecule.api.getAsync.GetAsyncArray#getAsyncArraySince" class="extmbr">getAsyncArraySince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayWith" group="getArrayWith" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayWith(txData:java.util.List[_],n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayWith(List[_],Int)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayWith(txData:java.util.List[_],n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayWith</span><span class="params">(<span name="txData">txData: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#java.util.List" name="java.util.List" id="java.util.List" class="extype">List</a>[_]</span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule with applied raw transaction data.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule with applied raw transaction data.
<br><br>
Apply raw transaction data to in-memory "branch" of db without affecting db to see how it would then look:</p><pre><span class="cmt">// Live size of Person db</span>
Person.name.get.size === <span class="num">150</span>

<span class="cmt">// Read some transaction data from file</span>
<span class="kw">val</span> data_rdr2 = <span class="kw">new</span> FileReader(<span class="lit">"examples/resources/seattle/seattle-data1a.dtm"</span>)
<span class="kw">val</span> newDataTx = Util.readAll(data_rdr2).get(<span class="num">0</span>).asInstanceOf[java.util.<span class="std">List</span>[<span class="std">Object</span>]]

<span class="cmt">// Imagine future db - 100 persons would be added, apparently</span>
Person.name.getArrayWith(newDataTx).size === <span class="num">250</span>

<span class="cmt">// Imagine future db - Let's just take 10</span>
Person.name.getArrayWith(newDataTx, <span class="num">10</span>).size === <span class="num">10</span></pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples.
</p></div><dl class="paramcmts block"><dt class="param">txData</dt><dd class="cmt"><p>Raw transaction data as java.util.List[Object]</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/with/" target="_blank">Manual</a> on <code>with</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayWith(txData:java.util.List[_],n:Int)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayWith" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayWith" class="extmbr">getAsyncArrayWith</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayWith" group="getArrayWith" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayWith(txData:java.util.List[_])(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayWith(List[_])(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayWith(txData:java.util.List[_])(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayWith</span><span class="params">(<span name="txData">txData: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#java.util.List" name="java.util.List" id="java.util.List" class="extype">List</a>[_]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule with applied raw transaction data.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule with applied raw transaction data.
<br><br>
Apply raw transaction data to in-memory "branch" of db without affecting db to see how it would then look:</p><pre><span class="cmt">// Live size of Person db</span>
Person.name.get.size === <span class="num">150</span>

<span class="cmt">// Read some transaction data from file</span>
<span class="kw">val</span> data_rdr2 = <span class="kw">new</span> FileReader(<span class="lit">"examples/resources/seattle/seattle-data1a.dtm"</span>)
<span class="kw">val</span> newDataTx = Util.readAll(data_rdr2).get(<span class="num">0</span>).asInstanceOf[java.util.<span class="std">List</span>[<span class="std">Object</span>]]

<span class="cmt">// Imagine future db - 100 persons would be added, apparently</span>
Person.name.getArrayWith(newDataTx).size === <span class="num">250</span></pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">txData</dt><dd class="cmt"><p>Raw transaction data as java.util.List[Object]</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/with/" target="_blank">Manual</a> on <code>with</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayWith(txData:java.util.List[_])(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayWith" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayWith" class="extmbr">getAsyncArrayWith</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayWith" group="getArrayWith" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayWith(n:Int,txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayWith(Int,Seq[Seq[Statement]]*)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayWith(n:Int,txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayWith</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>, <span name="txMolecules">txMolecules: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../../ast/transactionModel$$Statement.html" name="molecule.ast.transactionModel.Statement" id="molecule.ast.transactionModel.Statement" class="extype">Statement</a>]]*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of n rows as tuples matching molecule with applied molecule transaction data.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of n rows as tuples matching molecule with applied molecule transaction data.
<br><br>
Apply one or more molecule transactions to in-memory "branch" of db without affecting db to see how it would then look:</p><pre><span class="cmt">// Current state</span>
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = Person.name.likes.insert(
  (<span class="lit">"Ben"</span>, <span class="lit">"pasta"</span>),
  (<span class="lit">"Liz"</span>, <span class="lit">"pizza"</span>)
).eids

<span class="cmt">// Test multiple transactions</span>
Person.name.likes.getArrayWith(
  Person(ben).likes(<span class="lit">"sushi"</span>).getUpdateTx,
  Person(liz).likes(<span class="lit">"cake"</span>).getUpdateTx
) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="lit">"sushi"</span>)
  (<span class="lit">"Liz"</span>, <span class="lit">"cake"</span>)
)

<span class="cmt">// Same as above, but only n (1) rows returned:</span>
Person.name.likes.getArrayWith(
  <span class="num">1</span>
  Person(ben).likes(<span class="lit">"sushi"</span>).getUpdateTx,
  Person(liz).likes(<span class="lit">"cake"</span>).getUpdateTx
) === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="lit">"sushi"</span>)
)</pre><p>Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
<br><br>
The Array is only populated with n rows of type-casted tuples.
</p></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">txMolecules</dt><dd class="cmt"><p>Transaction statements from applied Molecules with test data</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>Note</dt><dd><span class="cmt"><p>Note how the <code>n</code> parameter has to come before the <code>txMolecules</code> vararg.</p></span></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/with/" target="_blank">Manual</a> on <code>with</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayWith(n:Int,txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayWith" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayWith" class="extmbr">getAsyncArrayWith</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetArray#getArrayWith" group="getArrayWith" fullComment="yes" data-isabs="false" visbl="pub"><a id="getArrayWith(txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]"></a><a id="getArrayWith(Seq[Seq[Statement]]*)(Conn,ClassTag[Tpl]):Array[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getArrayWith(txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):Array[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getArrayWith</span><span class="params">(<span name="txMolecules">txMolecules: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../../ast/transactionModel$$Statement.html" name="molecule.ast.transactionModel.Statement" id="molecule.ast.transactionModel.Statement" class="extype">Statement</a>]]*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>, <span name="tplType">tplType: <span name="scala.reflect.ClassTag" class="extype">ClassTag</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span>)</span><span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>Array</code> of all rows as tuples matching molecule with applied molecule transaction data.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>Array</code> of all rows as tuples matching molecule with applied molecule transaction data.
<br><br>
Apply one or more molecule transactions to in-memory "branch" of db without affecting db to see how it would then look:</p><pre><span class="cmt">// Current state</span>
<span class="kw">val</span> ben = Person.name(<span class="lit">"Ben"</span>).likes(<span class="lit">"pasta"</span>).save.eid

<span class="cmt">// Base data</span>
Person.name.likes.getArrayWith(
  <span class="cmt">// apply imaginary transaction data</span>
  Person(ben).likes(<span class="lit">"sushi"</span>).getUpdateTx
) === <span class="std">Array</span>(
  <span class="cmt">// Effect: Ben would like sushi if tx was applied</span>
  (<span class="lit">"Ben"</span>, <span class="lit">"sushi"</span>)
)

<span class="cmt">// Current state is still the same</span>
Person.name.likes.get === <span class="std">Array</span>(
  (<span class="lit">"Ben"</span>, <span class="lit">"pasta"</span>)
)</pre><p>Multiple transactions can be applied to test more complex what-if scenarios!
<br><br>
Getting a pre-allocated Array populated with typed data is the fastest way to query
Datomic with Molecule. Looping the Array in a while loop with a mutable index pointer will
also be the fastest way to traverse the data set.
</p></div><dl class="paramcmts block"><dt class="param">txMolecules</dt><dd class="cmt"><p>Transaction statements from applied Molecules with test data</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt class="param">tplType</dt><dd class="cmt"><p>Implicit <code>ClassTag[Tpl]</code> to capture Tuple type for Array</p></dd><dt>returns</dt><dd class="cmt"><p>Array[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/with/" target="_blank">Manual</a> on <code>with</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncArray.html#getAsyncArrayWith(txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn,implicittplType:scala.reflect.ClassTag[Tpl]):scala.concurrent.Future[Array[Tpl]]" name="molecule.api.getAsync.GetAsyncArray#getAsyncArrayWith" id="molecule.api.getAsync.GetAsyncArray#getAsyncArrayWith" class="extmbr">getAsyncArrayWith</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getAsOf" group="getAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAsOf(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getAsOf(Date,Int)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getAsOf(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getAsOf</span><span class="params">(<span name="date">date: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#java.util.Date" name="java.util.Date" id="java.util.Date" class="extype">Date</a></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule as of date.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule as of date.
<br><br>
Get data at a human point in time (a java.util.Date).</p><pre><span class="kw">val</span> beforeInsert = <span class="kw">new</span> java.util.Date

<span class="cmt">// Insert</span>
<span class="kw">val</span> tx1 = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = tx1.eids
<span class="kw">val</span> afterInsert = <span class="kw">new</span> java.util.Date

<span class="cmt">// Update</span>
<span class="kw">val</span> tx2 = Person(ben).age(<span class="num">43</span>).update
<span class="kw">val</span> afterUpdate = <span class="kw">new</span> java.util.Date

<span class="cmt">// Get List of all rows as of afterUpdate</span>
Person.name.age.getAsOf(afterUpdate) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get List of n rows as of afterUpdate</span>
Person.name.age.getAsOf(afterUpdate, <span class="num">1</span>) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>)
)</pre></div><dl class="paramcmts block"><dt class="param">date</dt><dd class="cmt"><p>java.util.Date</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncAsOf(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" id="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" class="extmbr">getAsyncAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getAsOf" group="getAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAsOf(date:java.util.Date)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getAsOf(Date)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getAsOf(date:java.util.Date)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getAsOf</span><span class="params">(<span name="date">date: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#java.util.Date" name="java.util.Date" id="java.util.Date" class="extype">Date</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule as of date.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule as of date.
<br><br>
Get data at a human point in time (a java.util.Date).</p><pre><span class="kw">val</span> beforeInsert = <span class="kw">new</span> java.util.Date

<span class="cmt">// Insert</span>
<span class="kw">val</span> tx1 = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>),
)
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = tx1.eids
<span class="kw">val</span> afterInsert = <span class="kw">new</span> java.util.Date

<span class="cmt">// Update</span>
<span class="kw">val</span> tx2 = Person(ben).age(<span class="num">43</span>).update
<span class="kw">val</span> afterUpdate = <span class="kw">new</span> java.util.Date

<span class="cmt">// Retract</span>
<span class="kw">val</span> tx3 = ben.retract
<span class="kw">val</span> afterRetract = <span class="kw">new</span> java.util.Date

<span class="cmt">// No data yet before insert</span>
Person.name.age.getAsOf(beforeInsert) === Nil

<span class="cmt">// Get List of all rows as of afterInsert</span>
Person.name.age.getAsOf(afterInsert) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)´
)

<span class="cmt">// Get List of all rows as of afterUpdate</span>
Person.name.age.getAsOf(afterUpdate) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>), <span class="cmt">// Ben now 43</span>
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get List of all rows as of afterRetract</span>
Person.name.age.getAsOf(afterRetract) === <span class="std">List</span>(
  (<span class="lit">"Liz"</span>, <span class="num">37</span>) <span class="cmt">// Ben gone</span>
)</pre></div><dl class="paramcmts block"><dt class="param">date</dt><dd class="cmt"><p>java.util.Date</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncAsOf(date:java.util.Date)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" id="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" class="extmbr">getAsyncAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getAsOf" group="getAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAsOf(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getAsOf(TxReport,Int)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getAsOf(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getAsOf</span><span class="params">(<span name="tx">tx: <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule as of tx.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule as of tx.
<br><br>
Datomic's internal <code>asOf</code> method can take a transaction entity id as argument to retrieve a database
value as of that transaction (including).
<br><br>
Instead of supplying the transaction entity id, in Molecule we supply a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a>
that contains the transaction entity id (which is used as argument to Datomic internally). This is more
convenient when using Molecule since we get a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> from transaction
operations like <code>get</code>, <code>update</code>, <code>retract</code> etc.</p><pre><span class="cmt">// Insert (tx report 1)</span>
<span class="kw">val</span> tx1 = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = tx1.eids

<span class="cmt">// Update (tx report 2)</span>
<span class="kw">val</span> tx2 = Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// Current data</span>
Person.name.age.get === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get List of all rows as of tx2 (after update)</span>
Person.name.age.getAsOf(tx2) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get List of n rows as of tx2 (after update)</span>
Person.name.age.getAsOf(tx2, <span class="num">1</span>) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>)
)</pre></div><dl class="paramcmts block"><dt class="param">tx</dt><dd class="cmt"><p><a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> (returned from all molecule transaction operations)</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncAsOf(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" id="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" class="extmbr">getAsyncAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getAsOf" group="getAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAsOf(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getAsOf(TxReport)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getAsOf(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getAsOf</span><span class="params">(<span name="tx">tx: <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule as of tx.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule as of tx.
<br><br>
Datomic's internal <code>asOf</code> method can take a transaction entity id as argument to retrieve a
database value as of that transaction (including).
<br><br>
Instead of supplying the transaction entity id, in Molecule we supply a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a>
that contains the transaction entity id (which is used as argument to Datomic internally). This is more
convenient when using Molecule since we get a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> from transaction
operations like <code>get</code>, <code>update</code>, <code>retract</code> etc.</p><pre><span class="cmt">// Insert (tx report 1)</span>
<span class="kw">val</span> tx1 = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>),
)
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = tx1.eids

<span class="cmt">// Update (tx report 2)</span>
<span class="kw">val</span> tx2 = Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// Retract (tx report 3)</span>
<span class="kw">val</span> tx3 = ben.retract

<span class="cmt">// Get List of all rows as of tx1 (after insert)</span>
Person.name.age.getAsOf(tx1) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get List of all rows as of tx2 (after update)</span>
Person.name.age.getAsOf(tx2) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>), <span class="cmt">// Ben now 43</span>
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get List of all rows as of tx3 (after retract)</span>
Person.name.age.getAsOf(tx3) === <span class="std">List</span>(
  (<span class="lit">"Liz"</span>, <span class="num">37</span>) <span class="cmt">// Ben gone</span>
)</pre></div><dl class="paramcmts block"><dt class="param">tx</dt><dd class="cmt"><p><a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> (returned from all molecule transaction operations)</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncAsOf(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" id="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" class="extmbr">getAsyncAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getAsOf" group="getAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAsOf(t:Long,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getAsOf(Long,Int)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getAsOf(t:Long,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getAsOf</span><span class="params">(<span name="t">t: <span name="scala.Long" class="extype">Long</span></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule as of transaction time <code>t</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule as of transaction time <code>t</code>.
<br><br>
Transaction time <code>t</code> is an auto-incremented transaction number assigned internally by Datomic.
<br><br>
<code>t</code> can for instance be retrieved in a getHistory call for an attribute and then be
used to get data as of that point in time (including that transaction):</p><pre><span class="cmt">// Insert (t 1028)</span>
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>),
) eids

<span class="cmt">// Update (t 1031)</span>
Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// History of Ben</span>
Person(ben).age.t.op.getHistory.sortBy(r <span class="kw">=&gt;</span> (r._2, r._3)) === <span class="std">List</span>(
  (<span class="num">42</span>, <span class="num">1028</span>, <span class="kw">true</span>),  <span class="cmt">// Insert:  42 asserted</span>
  (<span class="num">42</span>, <span class="num">1031</span>, <span class="kw">false</span>), <span class="cmt">// Update:  42 retracted</span>
  (<span class="num">43</span>, <span class="num">1031</span>, <span class="kw">true</span>),  <span class="cmt">//          43 asserted</span>
)

<span class="cmt">// Get List of all all rows as of transaction t 1031 (after update)</span>
Person.name.age.getAsOf(<span class="num">1031</span>) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)

<span class="cmt">// Get List of n rows as of transaction t 1031 (after update)</span>
Person.name.age.getAsOf(<span class="num">1031</span>, <span class="num">1</span>) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">43</span>)
)</pre></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Long Transaction time t</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncAsOf(t:Long,n:Int)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" id="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" class="extmbr">getAsyncAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getAsOf" group="getAsOf" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAsOf(t:Long)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getAsOf(Long)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getAsOf(t:Long)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getAsOf</span><span class="params">(<span name="t">t: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule as of transaction time <code>t</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule as of transaction time <code>t</code>.
<br><br>
Transaction time <code>t</code> is an auto-incremented transaction number assigned internally by Datomic.
<br><br>
<code>t</code> can for instance be retrieved in a getHistory call for an attribute and then be
used to get data as of that point in time (including that transaction):</p><pre><span class="cmt">// Insert (t 1028)</span>
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>),
) eids

<span class="cmt">// Update (t 1031)</span>
Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// Retract (t 1032)</span>
ben.retract

<span class="cmt">// History of Ben</span>
Person(ben).age.t.op.getHistory.sortBy(r <span class="kw">=&gt;</span> (r._2, r._3)) === <span class="std">List</span>(
  (<span class="num">42</span>, <span class="num">1028</span>, <span class="kw">true</span>),  <span class="cmt">// Insert:  42 asserted</span>
  (<span class="num">42</span>, <span class="num">1031</span>, <span class="kw">false</span>), <span class="cmt">// Update:  42 retracted</span>
  (<span class="num">43</span>, <span class="num">1031</span>, <span class="kw">true</span>),  <span class="cmt">//          43 asserted</span>
  (<span class="num">43</span>, <span class="num">1032</span>, <span class="kw">false</span>)  <span class="cmt">// Retract: 43 retracted</span>
)

<span class="cmt">// Get List of all rows as of transaction t 1028 (after insert)</span>
Person.name.age.getAsOf(<span class="num">1028</span>) === <span class="std">List</span>(
  (<span class="lit">"Liz"</span>, <span class="num">37</span>),
  (<span class="lit">"Ben"</span>, <span class="num">42</span>)
)

<span class="cmt">// Get List of all rows as of transaction t 1031 (after update)</span>
Person.name.age.getAsOf(<span class="num">1031</span>) === <span class="std">List</span>(
  (<span class="lit">"Liz"</span>, <span class="num">37</span>),
  (<span class="lit">"Ben"</span>, <span class="num">43</span>)
)

<span class="cmt">// Get List of all rows as of transaction t 1032 (after retract)</span>
Person.name.age.getAsOf(<span class="num">1032</span>) === <span class="std">List</span>(
  (<span class="lit">"Liz"</span>, <span class="num">37</span>)
)</pre></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Transaction time t</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncAsOf(t:Long)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" id="molecule.api.getAsync.GetAsyncList#getAsyncAsOf" class="extmbr">getAsyncAsOf</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]"></a><a id="getClass():Class[_&lt;:AnyRef]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getHistory" group="getHistory" fullComment="yes" data-isabs="false" visbl="pub"><a id="getHistory(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getHistory(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getHistory(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getHistory</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get history of operations as <code>List</code> on an attribute in the db.</p><div class="fullcomment"><div class="comment cmt"><p>Get history of operations as <code>List</code> on an attribute in the db.
<br><br>
Generic datom attributes that can be called when <code>getHistory</code> is called:
<br>
<br> <code>e</code> - Entity id
<br> <code>a</code> - Attribute name
<br> <code>v</code> - Attribute value
<br> <code>ns</code> - Namespace name
<br> <code>tx</code> - <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a>
<br> <code>t</code> - Transaction time t
<br> <code>txInstant</code> - Transaction time as java.util.Date
<br> <code>op</code> - Operation: true (add) or false (retract)
<br><br>
Example:</p><pre><span class="cmt">// Insert (t 1028)</span>
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = Person.name.age insert <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="num">42</span>),
  (<span class="lit">"Liz"</span>, <span class="num">37</span>),
) eids

<span class="cmt">// Update (t 1031)</span>
Person(ben).age(<span class="num">43</span>).update

<span class="cmt">// Retract (t 1032)</span>
ben.retract

<span class="cmt">// History of Ben</span>
Person(ben).age.t.op.getHistory.sortBy(r <span class="kw">=&gt;</span> (r._2, r._3)) === <span class="std">List</span>(
  (<span class="num">42</span>, <span class="num">1028</span>, <span class="kw">true</span>),  <span class="cmt">// Insert:  42 asserted</span>
  (<span class="num">42</span>, <span class="num">1031</span>, <span class="kw">false</span>), <span class="cmt">// Update:  42 retracted</span>
  (<span class="num">43</span>, <span class="num">1031</span>, <span class="kw">true</span>),  <span class="cmt">//          43 asserted</span>
  (<span class="num">43</span>, <span class="num">1032</span>, <span class="kw">false</span>)  <span class="cmt">// Retract: 43 retracted</span>
)</pre></div><dl class="paramcmts block"><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/history/" target="_blank">manual</a> for more info on generic attributes.</p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncHistory(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncHistory" id="molecule.api.getAsync.GetAsyncList#getAsyncHistory" class="extmbr">getAsyncHistory</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getListOf" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="getListOf[T](implicitconn:molecule.facade.Conn):List[T]"></a><a id="getListOf[T](Conn):List[T]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getListOf[T](implicitconn:molecule.facade.Conn):List[T]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getListOf</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.getListOf.T" class="extype">T</span>]</span></span></li><li class="indented0 " name="molecule.api.get.GetList#getSince" group="getSince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getSince(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getSince(Date,Int)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getSince(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getSince</span><span class="params">(<span name="date">date: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#java.util.Date" name="java.util.Date" id="java.util.Date" class="extype">Date</a></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule since date.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule since date.
<br><br>
Get data added/retracted since a human point in time (a java.util.Date).</p><pre><span class="cmt">// Transact 3 times (`inst` retrieves transaction time/Date from tx report)</span>
<span class="kw">val</span> date1 = Person.name(<span class="lit">"Ann"</span>).save.inst
<span class="kw">val</span> date2 = Person.name(<span class="lit">"Ben"</span>).save.inst
<span class="kw">val</span> date3 = Person.name(<span class="lit">"Cay"</span>).save.inst

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since date1</span>
Person.name.getSince(date1) === <span class="std">List</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since date1 - only n (1) rows returned</span>
Person.name.getSince(date1, <span class="num">1</span>) === <span class="std">List</span>(<span class="lit">"Ben"</span>)</pre></div><dl class="paramcmts block"><dt class="param">date</dt><dd class="cmt"><p>java.util.Date</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncSince(date:java.util.Date,n:Int)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncSince" id="molecule.api.getAsync.GetAsyncList#getAsyncSince" class="extmbr">getAsyncSince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getSince" group="getSince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getSince(date:java.util.Date)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getSince(Date)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getSince(date:java.util.Date)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getSince</span><span class="params">(<span name="date">date: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#java.util.Date" name="java.util.Date" id="java.util.Date" class="extype">Date</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule since date.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule since date.
<br><br>
Get data added/retracted since a human point in time (a java.util.Date).</p><pre><span class="cmt">// Transact 3 times (`inst` retrieves transaction time/Date from tx report)</span>
<span class="kw">val</span> date1 = Person.name(<span class="lit">"Ann"</span>).save.inst
<span class="kw">val</span> date2 = Person.name(<span class="lit">"Ben"</span>).save.inst
<span class="kw">val</span> date3 = Person.name(<span class="lit">"Cay"</span>).save.inst

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since date1</span>
Person.name.getSince(date1) === <span class="std">List</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Cay added since date2</span>
Person.name.getSince(date2) === <span class="std">List</span>(<span class="lit">"Cay"</span>)

<span class="cmt">// Nothing added since date3</span>
Person.name.getSince(date3) === Nil</pre></div><dl class="paramcmts block"><dt class="param">date</dt><dd class="cmt"><p>java.util.Date</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncSince(date:java.util.Date)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncSince" id="molecule.api.getAsync.GetAsyncList#getAsyncSince" class="extmbr">getAsyncSince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getSince" group="getSince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getSince(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getSince(TxReport,Int)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getSince(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getSince</span><span class="params">(<span name="tx">tx: <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule since tx.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule since tx.
<br><br>
Datomic's internal <code>since</code> can take a transaction entity id as argument to retrieve a database
value since that transaction (excluding the transaction itself).
<br><br>
Instead of supplying the transaction entity id, in Molecule we supply a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> that contains
the transaction entity id (which is used as argument to Datomic internally). This is more convenient when using Molecule since we
getAsync a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> from transaction operations like <code>get</code>, <code>update</code>, <code>retract</code> etc.</p><pre><span class="cmt">// Get tx reports for 3 transactions</span>
<span class="kw">val</span> tx1 = Person.name(<span class="lit">"Ann"</span>).save
<span class="kw">val</span> tx2 = Person.name(<span class="lit">"Ben"</span>).save
<span class="kw">val</span> tx3 = Person.name(<span class="lit">"Cay"</span>).save

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since tx1</span>
Person.name.getSince(tx1) === <span class="std">List</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since tx1 - only n (1) rows returned</span>
Person.name.getSince(tx1, <span class="num">1</span>) === <span class="std">List</span>(<span class="lit">"Ben"</span>)</pre></div><dl class="paramcmts block"><dt class="param">tx</dt><dd class="cmt"><p><a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncSince(tx:molecule.facade.TxReport,n:Int)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncSince" id="molecule.api.getAsync.GetAsyncList#getAsyncSince" class="extmbr">getAsyncSince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getSince" group="getSince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getSince(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getSince(TxReport)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getSince(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getSince</span><span class="params">(<span name="tx">tx: <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule since tx.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule since tx.
<br><br>
Datomic's internal <code>since</code> can take a transaction entity id as argument to retrieve a database
value since that transaction (excluding the transaction itself).
<br><br>
Instead of supplying the transaction entity id, in Molecule we supply a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> that contains
the transaction entity id (which is used as argument to Datomic internally). This is more convenient when using Molecule since we
getAsync a <a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a> from transaction operations like <code>get</code>, <code>update</code>, <code>retract</code> etc.</p><pre><span class="cmt">// Get tx reports for 3 transactions</span>
<span class="kw">val</span> tx1 = Person.name(<span class="lit">"Ann"</span>).save
<span class="kw">val</span> tx2 = Person.name(<span class="lit">"Ben"</span>).save
<span class="kw">val</span> tx3 = Person.name(<span class="lit">"Cay"</span>).save

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since tx1</span>
Person.name.getSince(tx1) === <span class="std">List</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Cay added since tx2</span>
Person.name.getSince(tx2) === <span class="std">List</span>(<span class="lit">"Cay"</span>)

<span class="cmt">// Nothing added since tx3</span>
Person.name.getSince(tx3) === Nil</pre></div><dl class="paramcmts block"><dt class="param">tx</dt><dd class="cmt"><p><a href="../../facade/TxReport.html" name="molecule.facade.TxReport" id="molecule.facade.TxReport" class="extype">TxReport</a></p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncSince(tx:molecule.facade.TxReport)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncSince" id="molecule.api.getAsync.GetAsyncList#getAsyncSince" class="extmbr">getAsyncSince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getSince" group="getSince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getSince(t:Long,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getSince(Long,Int)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getSince(t:Long,n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getSince</span><span class="params">(<span name="t">t: <span name="scala.Long" class="extype">Long</span></span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule since transaction time <code>t</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule since transaction time <code>t</code>.
<br><br>
Transaction time <code>t</code> is an auto-incremented transaction number assigned internally by Datomic.
<br><br>
<code>t</code> can for instance be retrieved by calling <code>t</code> on the tx report returned from transactional operations
and then be used to get data since that point in time (excluding that transaction):</p><pre><span class="cmt">// 3 transaction times `t`</span>
<span class="kw">val</span> t1 = Person.name(<span class="lit">"Ann"</span>).save.t
<span class="kw">val</span> t2 = Person.name(<span class="lit">"Ben"</span>).save.t
<span class="kw">val</span> t3 = Person.name(<span class="lit">"Cay"</span>).save.t

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since transaction time t 1028</span>
Person.name.getSince(t1) === <span class="std">List</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since transaction time t 1028 - only n (1) rows returned</span>
Person.name.getSince(t1, <span class="num">1</span>) === <span class="std">List</span>(<span class="lit">"Ben"</span>)</pre></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Transaction time t</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncSince(t:Long,n:Int)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncSince" id="molecule.api.getAsync.GetAsyncList#getAsyncSince" class="extmbr">getAsyncSince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getSince" group="getSince" fullComment="yes" data-isabs="false" visbl="pub"><a id="getSince(t:Long)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getSince(Long)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getSince(t:Long)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getSince</span><span class="params">(<span name="t">t: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule since transaction time <code>t</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule since transaction time <code>t</code>.
<br><br>
Transaction time <code>t</code> is an auto-incremented transaction number assigned internally by Datomic.
<br><br>
<code>t</code> can for instance be retrieved by calling <code>t</code> on the tx report returned from transactional operations
and then be used to get data since that point in time (excluding that transaction):</p><pre><span class="cmt">// 3 transaction times `t`</span>
<span class="kw">val</span> t1 = Person.name(<span class="lit">"Ann"</span>).save.t
<span class="kw">val</span> t2 = Person.name(<span class="lit">"Ben"</span>).save.t
<span class="kw">val</span> t3 = Person.name(<span class="lit">"Cay"</span>).save.t

<span class="cmt">// Current values</span>
Person.name.get === <span class="std">List</span>(<span class="lit">"Ann"</span>, <span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Ben and Cay added since transaction time t 1028</span>
Person.name.getSince(t1) === <span class="std">List</span>(<span class="lit">"Ben"</span>, <span class="lit">"Cay"</span>)

<span class="cmt">// Cay added since transaction time t 1030</span>
Person.name.getSince(t2) === <span class="std">List</span>(<span class="lit">"Cay"</span>)

<span class="cmt">// Nothing added since transaction time t 1032</span>
Person.name.getSince(t3) === Nil</pre></div><dl class="paramcmts block"><dt class="param">t</dt><dd class="cmt"><p>Transaction time t</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/asof-since/" target="_blank">Manual</a> on <code>asof</code>/<code>since</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncSince(t:Long)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncSince" id="molecule.api.getAsync.GetAsyncList#getAsyncSince" class="extmbr">getAsyncSince</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getWith" group="getWith" fullComment="yes" data-isabs="false" visbl="pub"><a id="getWith(txData:java.util.List[_],n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getWith(List[_],Int)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getWith(txData:java.util.List[_],n:Int)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getWith</span><span class="params">(<span name="txData">txData: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#java.util.List" name="java.util.List" id="java.util.List" class="extype">List</a>[_]</span>, <span name="n">n: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule with applied raw transaction data.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule with applied raw transaction data.
<br><br>
Apply raw transaction data to in-memory "branch" of db without affecting db to see how it would then look:</p><pre><span class="cmt">// Live size of Person db</span>
Person.name.get.size === <span class="num">150</span>

<span class="cmt">// Read some transaction data from file</span>
<span class="kw">val</span> data_rdr2 = <span class="kw">new</span> FileReader(<span class="lit">"examples/resources/seattle/seattle-data1a.dtm"</span>)
<span class="kw">val</span> newDataTx = Util.readAll(data_rdr2).get(<span class="num">0</span>).asInstanceOf[java.util.<span class="std">List</span>[<span class="std">Object</span>]]

<span class="cmt">// Imagine future db - 100 persons would be added, apparently</span>
Person.name.getWith(newDataTx).size === <span class="num">250</span>

<span class="cmt">// Imagine future db - Let's just take 10</span>
Person.name.getWith(newDataTx, <span class="num">10</span>).size === <span class="num">10</span></pre></div><dl class="paramcmts block"><dt class="param">txData</dt><dd class="cmt"><p>Raw transaction data as java.util.List[Object]</p></dd><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/with/" target="_blank">Manual</a> on <code>with</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncWith(txData:java.util.List[_],n:Int)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncWith" id="molecule.api.getAsync.GetAsyncList#getAsyncWith" class="extmbr">getAsyncWith</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getWith" group="getWith" fullComment="yes" data-isabs="false" visbl="pub"><a id="getWith(txData:java.util.List[_])(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getWith(List[_])(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getWith(txData:java.util.List[_])(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getWith</span><span class="params">(<span name="txData">txData: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#java.util.List" name="java.util.List" id="java.util.List" class="extype">List</a>[_]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule with applied raw transaction data.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule with applied raw transaction data.
<br><br>
Apply raw transaction data to in-memory "branch" of db without affecting db to see how it would then look:</p><pre><span class="cmt">// Live size of Person db</span>
Person.name.get.size === <span class="num">150</span>

<span class="cmt">// Read some transaction data from file</span>
<span class="kw">val</span> data_rdr2 = <span class="kw">new</span> FileReader(<span class="lit">"examples/resources/seattle/seattle-data1a.dtm"</span>)
<span class="kw">val</span> newDataTx = Util.readAll(data_rdr2).get(<span class="num">0</span>).asInstanceOf[java.util.<span class="std">List</span>[<span class="std">Object</span>]]

<span class="cmt">// Imagine future db - 100 persons would be added, apparently</span>
Person.name.getWith(newDataTx).size === <span class="num">250</span></pre></div><dl class="paramcmts block"><dt class="param">txData</dt><dd class="cmt"><p>Raw transaction data as java.util.List[Object]</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/with/" target="_blank">Manual</a> on <code>with</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncWith(txData:java.util.List[_])(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncWith" id="molecule.api.getAsync.GetAsyncList#getAsyncWith" class="extmbr">getAsyncWith</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getWith" group="getWith" fullComment="yes" data-isabs="false" visbl="pub"><a id="getWith(n:Int,txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getWith(Int,Seq[Seq[Statement]]*)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getWith(n:Int,txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getWith</span><span class="params">(<span name="n">n: <span name="scala.Int" class="extype">Int</span></span>, <span name="txMolecules">txMolecules: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../../ast/transactionModel$$Statement.html" name="molecule.ast.transactionModel.Statement" id="molecule.ast.transactionModel.Statement" class="extype">Statement</a>]]*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of n rows as tuples matching molecule with applied molecule transaction data.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of n rows as tuples matching molecule with applied molecule transaction data.
<br><br>
Apply one or more molecule transactions to in-memory "branch" of db without affecting db to see how it would then look:</p><pre><span class="cmt">// Current state</span>
<span class="kw">val</span> <span class="std">List</span>(ben, liz) = Person.name.likes.insert(
  (<span class="lit">"Ben"</span>, <span class="lit">"pasta"</span>),
  (<span class="lit">"Liz"</span>, <span class="lit">"pizza"</span>)
).eids

<span class="cmt">// Test multiple transactions</span>
Person.name.likes.getWith(
  Person(ben).likes(<span class="lit">"sushi"</span>).getUpdateTx,
  Person(liz).likes(<span class="lit">"cake"</span>).getUpdateTx
) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="lit">"sushi"</span>)
  (<span class="lit">"Liz"</span>, <span class="lit">"cake"</span>)
)

<span class="cmt">// Same as above, but only n (1) rows returned:</span>
Person.name.likes.getWith(
  <span class="num">1</span>
  Person(ben).likes(<span class="lit">"sushi"</span>).getUpdateTx,
  Person(liz).likes(<span class="lit">"cake"</span>).getUpdateTx
) === <span class="std">List</span>(
  (<span class="lit">"Ben"</span>, <span class="lit">"sushi"</span>)
)</pre></div><dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>Int Number of rows returned</p></dd><dt class="param">txMolecules</dt><dd class="cmt"><p>Transaction statements from applied Molecules with test data</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>Note</dt><dd><span class="cmt"><p>Note how the <code>n</code> parameter has to come before the <code>txMolecules</code> vararg.</p></span></dd><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/with/" target="_blank">Manual</a> on <code>with</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncWith(n:Int,txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncWith" id="molecule.api.getAsync.GetAsyncList#getAsyncWith" class="extmbr">getAsyncWith</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.get.GetList#getWith" group="getWith" fullComment="yes" data-isabs="false" visbl="pub"><a id="getWith(txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn):List[Tpl]"></a><a id="getWith(Seq[Seq[Statement]]*)(Conn):List[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#getWith(txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn):List[Tpl]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getWith</span><span class="params">(<span name="txMolecules">txMolecules: <span name="scala.Seq" class="extype">Seq</span>[<span name="scala.Seq" class="extype">Seq</span>[<a href="../../ast/transactionModel$$Statement.html" name="molecule.ast.transactionModel.Statement" id="molecule.ast.transactionModel.Statement" class="extype">Statement</a>]]*</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="conn">conn: <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a></span>)</span><span class="result">: <span name="scala.List" class="extype">List</span>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</span></span><p class="shortcomment cmt">Get <code>List</code> of all rows as tuples matching molecule with applied molecule transaction data.</p><div class="fullcomment"><div class="comment cmt"><p>Get <code>List</code> of all rows as tuples matching molecule with applied molecule transaction data.
<br><br>
Apply one or more molecule transactions to in-memory "branch" of db without affecting db to see how it would then look:</p><pre><span class="cmt">// Current state</span>
<span class="kw">val</span> ben = Person.name(<span class="lit">"Ben"</span>).likes(<span class="lit">"pasta"</span>).save.eid

<span class="cmt">// Base data</span>
Person.name.likes.getWith(
  <span class="cmt">// apply imaginary transaction data</span>
  Person(ben).likes(<span class="lit">"sushi"</span>).getUpdateTx
) === <span class="std">List</span>(
  <span class="cmt">// Effect: Ben would like sushi if tx was applied</span>
  (<span class="lit">"Ben"</span>, <span class="lit">"sushi"</span>)
)

<span class="cmt">// Current state is still the same</span>
Person.name.likes.get === <span class="std">List</span>((<span class="lit">"Ben"</span>, <span class="lit">"pasta"</span>))</pre><p>Multiple transactions can be applied to test more complex what-if scenarios!
</p></div><dl class="paramcmts block"><dt class="param">txMolecules</dt><dd class="cmt"><p>Transaction statements from applied Molecules with test data</p></dd><dt class="param">conn</dt><dd class="cmt"><p>Implicit <a href="../../facade/Conn.html" name="molecule.facade.Conn" id="molecule.facade.Conn" class="extype">Conn</a> value in scope</p></dd><dt>returns</dt><dd class="cmt"><p>List[Tpl] where Tpl is a tuple of data matching molecule</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="http://www.scalamolecule.org/manual/time/with/" target="_blank">Manual</a> on <code>with</code></p></span><span class="cmt"><p>Equivalent asynchronous <a href="../getAsync/GetAsyncList.html#getAsyncWith(txMolecules:Seq[Seq[molecule.ast.transactionModel.Statement]]*)(implicitconn:molecule.facade.Conn):scala.concurrent.Future[List[Tpl]]" name="molecule.api.getAsync.GetAsyncList#getAsyncWith" id="molecule.api.getAsync.GetAsyncList#getAsyncWith" class="extmbr">getAsyncWith</a> method.</p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](=&gt;T0):T0"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a> <span class="permalink"><a href="../../../molecule/api/get/GetList.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="molecule.api.get.GetArray" class="parent"><h3>Inherited from <a href="GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a>[<span name="molecule.api.get.GetList.Tpl" class="extype">Tpl</span>]</h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="get" class="group"><h3>get</h3></div><div name="getArrayAsOf" class="group"><h3>getArrayAsOf</h3></div><div name="getArraySince" class="group"><h3>getArraySince</h3></div><div name="getArrayWith" class="group"><h3>getArrayWith</h3></div><div name="getAsOf" class="group"><h3>getAsOf</h3></div><div name="getHistory" class="group"><h3>getHistory</h3></div><div name="getSince" class="group"><h3>getSince</h3></div><div name="getWith" class="group"><h3>getWith</h3></div><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
