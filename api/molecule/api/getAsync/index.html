<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title>Molecule 0.22.8 - molecule.api.getAsync</title><meta content="Molecule 0.22.8 - molecule.api.getAsync" name="description"/><meta content="Molecule 0.22.8 molecule.api.getAsync" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript" src="https://d3js.org/d3.v4.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title">Molecule<span id="doc-version">0.22.8</span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_"></a><a id="root:_root_"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><p class="shortcomment cmt"><img src="http://www.scalamolecule.org/img/logo/MoleculeLogo200.png"></p><div class="fullcomment"><div class="comment cmt"><p><img src="http://www.scalamolecule.org/img/logo/MoleculeLogo200.png"></p><p>Documentation/API for the Molecule library - a meta DSL for the <a href="https://www.datomic.com" target="_blank">Datomic</a> database.</p><p><a href="http://www.scalamolecule.org" target="_blank">Manual</a> |
<a href="http://www.scalamolecule.org" target="_blank">scalamolecule.org</a> |
<a href="https://github.com/scalamolecule/molecule" target="_blank">Github</a> |
<a href="https://groups.google.com/forum/#!forum/molecule-dsl" target="_blank">Forum</a></p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.molecule" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="molecule"></a><a id="molecule:molecule"></a> <span class="permalink"><a href="../../../molecule/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title="Molecule library - a Scala meta-DSL for the Datomic database."><span class="name">molecule</span></a></span><p class="shortcomment cmt"><a href="http://www.scalamolecule.org" target="_blank">Molecule</a> library - a Scala meta-DSL for the <a href="https://www.datomic.com" target="_blank">Datomic</a> database.</p><div class="fullcomment"><div class="comment cmt"><p><a href="http://www.scalamolecule.org" target="_blank">Molecule</a> library - a Scala meta-DSL for the <a href="https://www.datomic.com" target="_blank">Datomic</a> database.</p><p>See <a href="../index.html" name="molecule.api" id="molecule.api" class="extype">api</a> package for various api imports to start using Molecule.</p><h4> Sub-packages </h4><p><table>
  <tr>
    <td><a href="api/index.html">api</a><td>
    <td>Molecule API.</td>
  </tr>
  <tr>
    <td><a href="ast/index.html">ast</a><td>
    <td style="color:#888">Internal Molecule ASTs.</td>
  </tr>
  <tr>
    <td><a href="boilerplate/index.html">boilerplate</a><td>
    <td style="color:#888">Internal interfaces for auto-generated DSL boilerplate code.</td>
  </tr>
  <tr>
    <td><a href="composition/index.html">composition</a>&nbsp;&nbsp;&nbsp;<td>
    <td>Builder methods to compose molecules.</td>
  </tr>
  <tr>
    <td><a href="exception/index.html">exceptions</a><td>
    <td>Exceptions thrown by Molecule.</td>
  </tr>
  <tr>
    <td><a href="expression/index.html">expression</a><td>
    <td>Attribute expressions and operations.</td>
  </tr>
  <tr>
    <td><a href="facade/index.html">facade</a><td>
    <td>Molecule facades to Datomic.</td>
  </tr>
  <tr>
    <td><a href="factory/index.html">factory</a><td>
    <td>Implicit macro methods `m` to instantiate molecules from custom DSL molecule constructs.</td>
  </tr>
  <tr>
    <td><a href="input/index.html">input</a><td>
    <td>Input molecules awaiting input.</td>
  </tr>
  <tr>
    <td><a href="macro/index.html">macros</a><td>
    <td style="color:#888">Internal macros generating molecule code from custom DSL molecule constructs.</td>
  </tr>
  <tr>
    <td><a href="generic/index.html">generic</a><td>
    <td>Interfaces to generic information about datoms and Datomic database.</td>
  </tr>
  <tr>
    <td><a href="ops/index.html">ops</a><td>
    <td style="color:#888">Internal operational helpers for transforming DSL to molecule.</td>
  </tr>
  <tr>
    <td><a href="schema/index.html">schema</a><td>
    <td>Schema definition DSL.</td>
  </tr>
  <tr>
    <td><a href="ops/index.html">transform</a><td>
    <td style="color:#888">Internal transformers from DSL to Model/Query/Transaction.</td>
  </tr>
  <tr>
    <td><a href="util/index.html">util</a><td>
    <td style="color:#888">Internal Java database functions for Datomic.</td>
  </tr>
</table>
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="molecule.api" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="api"></a><a id="api:api"></a> <span class="permalink"><a href="../../../molecule/api/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">api</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="molecule" id="molecule" class="extype">molecule</a></dd></dl></div></li><li class="indented3 " name="molecule.api.exception" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="exception"></a><a id="exception:exception"></a> <span class="permalink"><a href="../../../molecule/api/exception/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../exception/index.html" title=""><span class="name">exception</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="molecule.api" id="molecule.api" class="extype">api</a></dd></dl></div></li><li class="indented3 " name="molecule.api.get" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="get"></a><a id="get:get"></a> <span class="permalink"><a href="../../../molecule/api/get/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../get/index.html" title="Synchronous getter methods to retrieve data from Datomic."><span class="name">get</span></a></span><p class="shortcomment cmt">Synchronous getter methods to retrieve data from Datomic.</p><div class="fullcomment"><div class="comment cmt"><p>Synchronous getter methods to retrieve data from Datomic.</p><p>The Datomic On-Prem(ises) server model provides a Peer that returns data synchronously.
The Peer which lives in application memory caches data aggressively and for data
fitting in memory latency can be extremely low and queries return very fast. And
even when access to disk is needed, clever branching is used. Memcached is also
an option.</p><p>The Datomic Cloud model data returns data asynchronously. If Datomic creates a
Java API for the Cloud model, Molecule could relatively easy adapt to this model too.
In the meanwhile, Future-wrapped methods in this package can be used.</p><p>Molecule has 5 groups of synchronous getters, each returning data in various formats:</p><ul><li><a href="../get/GetArray.html" name="molecule.api.get.GetArray" id="molecule.api.get.GetArray" class="extype">GetArray</a> - fastest retrieved typed data set. Can be traversed with a fast <code>while</code> loop</li><li><a href="../get/GetIterable.html" name="molecule.api.get.GetIterable" id="molecule.api.get.GetIterable" class="extype">GetIterable</a> - for lazily traversing row by row</li><li><a href="../get/GetJson.html" name="molecule.api.get.GetJson" id="molecule.api.get.GetJson" class="extype">GetJson</a> - data formatted as Json string</li><li><a href="../get/GetList.html" name="molecule.api.get.GetList" id="molecule.api.get.GetList" class="extype">GetList</a> - default getter returning Lists of tuples. Convenient typed data, suitable for smaller data sets</li><li><a href="../get/GetRaw.html" name="molecule.api.get.GetRaw" id="molecule.api.get.GetRaw" class="extype">GetRaw</a> - fastest retrieved raw un-typed data from Datomic</li></ul><p>Getters in each of the 5 groups come with 5 time-dependent variations:</p><ul><li>get [current data]</li><li>getAsOf</li><li>getSince</li><li>getWith</li><li>getHistory</li></ul><p>Each time variation has various overloads taking different parameters (see each group for more info).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="molecule.api" id="molecule.api" class="extype">api</a></dd><dt>See also</dt><dd><span class="cmt"><p>equivalent asynchronous getters in the <a href="" name="molecule.api.getAsync" id="molecule.api.getAsync" class="extype">getAsync</a> package.</p></span></dd></dl></div></li><li class="indented3 current" name="molecule.api.getAsync" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getAsync"></a><a id="getAsync:getAsync"></a> <span class="permalink"><a href="../../../molecule/api/getAsync/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">getAsync</span></span><p class="shortcomment cmt">Asynchronous getter methods to retrieve data from Datomic.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous getter methods to retrieve data from Datomic.</p><p>For convenience, all synchronous getter methods from the <code>get</code> package are here wrapped in Futures.</p><p>The Datomic On-Prem(ises) server model provides a Peer that returns data synchronously.
The Peer which lives in application memory caches data aggressively and for data
fitting in memory latency can be extremely low and queries return very fast. And
even when access to disk is needed, clever branching is used. Memcached is also
an option.</p><p>The Datomic Cloud model data returns data asynchronously. If Datomic creates a
Java API for the Cloud model, Molecule could relatively easy adapt to this model too.
In the meanwhile, Future-wrapped methods in this package can be used.</p><p>Molecule has 5 groups of asynchronous getters, each returning Futures of data in various formats:</p><ul><li><a href="GetAsyncArray.html" name="molecule.api.getAsync.GetAsyncArray" id="molecule.api.getAsync.GetAsyncArray" class="extype">GetAsyncArray</a> - fastest retrieved typed data set. Can be traversed with a fast <code>while</code> loop</li><li><a href="GetAsyncIterable.html" name="molecule.api.getAsync.GetAsyncIterable" id="molecule.api.getAsync.GetAsyncIterable" class="extype">GetAsyncIterable</a> - for lazily traversing row by row</li><li><a href="GetAsyncJson.html" name="molecule.api.getAsync.GetAsyncJson" id="molecule.api.getAsync.GetAsyncJson" class="extype">GetAsyncJson</a> - data formatted as Json string</li><li><a href="GetAsyncList.html" name="molecule.api.getAsync.GetAsyncList" id="molecule.api.getAsync.GetAsyncList" class="extype">GetAsyncList</a> - default getter returning Lists of tuples. Convenient typed data, suitable for smaller data sets</li><li><a href="GetAsyncRaw.html" name="molecule.api.getAsync.GetAsyncRaw" id="molecule.api.getAsync.GetAsyncRaw" class="extype">GetAsyncRaw</a> - fastest retrieved raw un-typed data from Datomic</li></ul><p>Getters in each of the 5 groups come with 5 time-dependent variations:</p><ul><li>getAsync [current data]</li><li>getAsyncAsOf</li><li>getAsyncSince</li><li>getAsyncWith</li><li>getAsyncHistory</li></ul><p>Each time variation has various overloads taking different parameters (see each group for more info).
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="molecule.api" id="molecule.api" class="extype">api</a></dd><dt>See also</dt><dd><span class="cmt"><p>equivalent synchronous getters in the <a href="../get/index.html" name="molecule.api.get" id="molecule.api.get" class="extype">get</a> package.</p></span></dd></dl></div></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetAsyncArray.html" title="Asynchronous data getter methods on molecules returning Future[Array[Tpl]]." class="trait"></a><a href="GetAsyncArray.html" title="Asynchronous data getter methods on molecules returning Future[Array[Tpl]].">GetAsyncArray</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetAsyncIterable.html" title="Asynchronous data getter methods on molecules returning Future[Iterable[Tpl]]." class="trait"></a><a href="GetAsyncIterable.html" title="Asynchronous data getter methods on molecules returning Future[Iterable[Tpl]].">GetAsyncIterable</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetAsyncJson.html" title="Asynchronous data getter methods on molecules returning Future-wrapped Json String." class="trait"></a><a href="GetAsyncJson.html" title="Asynchronous data getter methods on molecules returning Future-wrapped Json String.">GetAsyncJson</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetAsyncList.html" title="Default asynchronous data getter methods on molecules returning Future[List[Tpl]]." class="trait"></a><a href="GetAsyncList.html" title="Default asynchronous data getter methods on molecules returning Future[List[Tpl]].">GetAsyncList</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="GetAsyncRaw.html" title="Asynchronous data getter methods on molecules returning raw untyped Datomic data." class="trait"></a><a href="GetAsyncRaw.html" title="Asynchronous data getter methods on molecules returning raw untyped Datomic data.">GetAsyncRaw</a></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../../index.html" name="molecule" id="molecule" class="extype">molecule</a>.<a href="../index.html" name="molecule.api" id="molecule.api" class="extype">api</a></p><h1>getAsync<span class="permalink"><a href="../../../molecule/api/getAsync/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">getAsync</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Asynchronous getter methods to retrieve data from Datomic.</p><p>For convenience, all synchronous getter methods from the <code>get</code> package are here wrapped in Futures.</p><p>The Datomic On-Prem(ises) server model provides a Peer that returns data synchronously.
The Peer which lives in application memory caches data aggressively and for data
fitting in memory latency can be extremely low and queries return very fast. And
even when access to disk is needed, clever branching is used. Memcached is also
an option.</p><p>The Datomic Cloud model data returns data asynchronously. If Datomic creates a
Java API for the Cloud model, Molecule could relatively easy adapt to this model too.
In the meanwhile, Future-wrapped methods in this package can be used.</p><p>Molecule has 5 groups of asynchronous getters, each returning Futures of data in various formats:</p><ul><li><a href="GetAsyncArray.html" name="molecule.api.getAsync.GetAsyncArray" id="molecule.api.getAsync.GetAsyncArray" class="extype">GetAsyncArray</a> - fastest retrieved typed data set. Can be traversed with a fast <code>while</code> loop</li><li><a href="GetAsyncIterable.html" name="molecule.api.getAsync.GetAsyncIterable" id="molecule.api.getAsync.GetAsyncIterable" class="extype">GetAsyncIterable</a> - for lazily traversing row by row</li><li><a href="GetAsyncJson.html" name="molecule.api.getAsync.GetAsyncJson" id="molecule.api.getAsync.GetAsyncJson" class="extype">GetAsyncJson</a> - data formatted as Json string</li><li><a href="GetAsyncList.html" name="molecule.api.getAsync.GetAsyncList" id="molecule.api.getAsync.GetAsyncList" class="extype">GetAsyncList</a> - default getter returning Lists of tuples. Convenient typed data, suitable for smaller data sets</li><li><a href="GetAsyncRaw.html" name="molecule.api.getAsync.GetAsyncRaw" id="molecule.api.getAsync.GetAsyncRaw" class="extype">GetAsyncRaw</a> - fastest retrieved raw un-typed data from Datomic</li></ul><p>Getters in each of the 5 groups come with 5 time-dependent variations:</p><ul><li>getAsync [current data]</li><li>getAsyncAsOf</li><li>getAsyncSince</li><li>getAsyncWith</li><li>getAsyncHistory</li></ul><p>Each time variation has various overloads taking different parameters (see each group for more info).
</p></div><dl class="attributes block"><dt>Source</dt><dd><a href="https://github.com/scalamolecule/molecule/tree/master/molecule/jvm/src/main/scala/molecule/api/getAsync/getAsync.scala#L1" target="_blank">getAsync.scala</a></dd><dt>See also</dt><dd><span class="cmt"><p>equivalent synchronous getters in the <a href="../get/index.html" name="molecule.api.get" id="molecule.api.get" class="extype">get</a> package.</p></span></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="template"><div id="allMembers"><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="molecule.api.getAsync.GetAsyncArray" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="GetAsyncArray[Tpl]extendsAnyRef"></a><a id="GetAsyncArray[Tpl]:GetAsyncArray[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/getAsync/GetAsyncArray.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="GetAsyncArray.html" title="Asynchronous data getter methods on molecules returning Future[Array[Tpl]]."><span class="name">GetAsyncArray</span></a><span class="tparams">[<span name="Tpl">Tpl</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Asynchronous data getter methods on molecules returning <code>Future[Array[Tpl]]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous data getter methods on molecules returning <code>Future[Array[Tpl]]</code>.
<br><br>
The fastest way of getting a large typed data set since data is applied to a super fast pre-allocated Array.
The Array can then be traversed with a fast <code>while</code> loop.</p><pre><span class="cmt">// Map over the Future</span>
Ns.int.getAsyncArray.map { result <span class="kw">=&gt;</span>
  result === <span class="std">Array</span>(<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>)

  <span class="cmt">// Fast while loop</span>
  <span class="kw">var</span> i = <span class="num">0</span>
  <span class="kw">val</span> length = result.length
  <span class="kw">while</span>(i &lt; length) {
    println(result(i)) <span class="cmt">// Do stuff with row...</span>
    i += <span class="num">1</span>
  }
}</pre><p>Each asynchronous getter in this package simply wraps the result of its equivalent synchronous getter (in the
<code>get</code> package) in a Future. <code>getAsyncArrayAsOf</code> thus wraps the result of <code>getArrayAsOf</code> in a Future and so on.
</p></div></div></li><li class="indented0 " name="molecule.api.getAsync.GetAsyncIterable" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="GetAsyncIterable[Tpl]extendsAnyRef"></a><a id="GetAsyncIterable[Tpl]:GetAsyncIterable[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/getAsync/GetAsyncIterable.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="GetAsyncIterable.html" title="Asynchronous data getter methods on molecules returning Future[Iterable[Tpl]]."><span class="name">GetAsyncIterable</span></a><span class="tparams">[<span name="Tpl">Tpl</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Asynchronous data getter methods on molecules returning <code>Future[Iterable[Tpl]]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous data getter methods on molecules returning <code>Future[Iterable[Tpl]]</code>.
<br><br>
Suitable for data sets that are lazily consumed.</p><pre><span class="kw">val</span> iterableFuture: Future[Iterable[(<span class="std">String</span>, <span class="std">Int</span>)]] = Person.name.age.getAsyncIterable
<span class="kw">for</span> {
  iterable <span class="kw">&lt;-</span> iterableFuture
} <span class="kw">yield</span> {
  iterable.iterator.next === (<span class="lit">"Ben"</span> <span class="num">42</span>)
}</pre><p>Each asynchronous getter in this package simply wraps the result of its equivalent synchronous getter (in the
<code>get</code> package) in a Future. <code>getAsyncIterableAsOf</code> thus wraps the result of <code>getIterableAsOf</code> in a Future and so on.
</p></div></div></li><li class="indented0 " name="molecule.api.getAsync.GetAsyncJson" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="GetAsyncJsonextendsAnyRef"></a><a id="GetAsyncJson:GetAsyncJson"></a> <span class="permalink"><a href="../../../molecule/api/getAsync/GetAsyncJson.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="GetAsyncJson.html" title="Asynchronous data getter methods on molecules returning Future-wrapped Json String."><span class="name">GetAsyncJson</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Asynchronous data getter methods on molecules returning Future-wrapped Json String.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous data getter methods on molecules returning Future-wrapped Json String.
<br><br>
Molecule builds a Json String directly from the untyped raw Datomic data.
<br><br>
Attributes names are used as Json field names. In order to distinguish
fields from each other, all attribute names are prepended with the namespace
name (in lowercase). For a namespace <code>Person</code> with an attribute <code>name</code> we get:</p><ul><li>"person.name"</li></ul><p>To distinguis fields of multiple relationships to the same namespace like <code>friends</code> and
<code>enemies</code> pointing to other <code>Person</code>'s require us to add a relationship name prefix too:</p><ul><li>"friends.person.name"</li><li>"enemies.person.name"</li></ul><p>Furthermore, if the attribute is part of a transaction meta-data molecule, we prefix that with <code>tx</code> too:</p><ul><li>"tx.person.name"</li><li>"tx.friends.person.name"</li></ul><p>Example:</p><pre><span class="kw">val</span> jsonFuture: Future[<span class="std">String</span>] = Person.name.age.getAsyncJson
<span class="kw">for</span> {
  json <span class="kw">&lt;-</span> jsonFuture
} <span class="kw">yield</span> {
  json ===
   <span class="lit">"""[
     |{"person.name": "Ben", "person.age": 42},
     |{"person.name": "Liz", "person.age": 37}
     |]""".stripMargin
}</span></pre><p>Each asynchronous getter in this package simply wraps the result of its equivalent synchronous getter (in the
<code>get</code> package) in a Future. <code>getAsyncIterableAsOf</code> thus wraps the result of <code>getIterableAsOf</code> in a Future and so on.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="https://github.com/scalamolecule/molecule/blob/master/coretests/src/test/scala/molecule/coretests/json" target="_blank">Json tests</a></p></span></dd></dl></div></li><li class="indented0 " name="molecule.api.getAsync.GetAsyncList" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="GetAsyncList[Tpl]extendsAnyRef"></a><a id="GetAsyncList[Tpl]:GetAsyncList[Tpl]"></a> <span class="permalink"><a href="../../../molecule/api/getAsync/GetAsyncList.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="GetAsyncList.html" title="Default asynchronous data getter methods on molecules returning Future[List[Tpl]]."><span class="name">GetAsyncList</span></a><span class="tparams">[<span name="Tpl">Tpl</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Default asynchronous data getter methods on molecules returning <code>Future[List[Tpl]]</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Default asynchronous data getter methods on molecules returning <code>Future[List[Tpl]]</code>.
<br><br>
For expected smaller result sets it's convenient to return Lists of tuples of data.
Considered as the default getter, no postfix has been added (<code>getAsync</code> instead of <code>getAsyncList</code>).</p><pre><span class="kw">val</span> futureList: Future[<span class="std">List</span>[(<span class="std">String</span>, <span class="std">Int</span>)]] = Person.name.age.getAsync
<span class="kw">for</span> {
  list <span class="kw">&lt;-</span> futureList
} <span class="kw">yield</span> {
  list === <span class="std">List</span>(
    (<span class="lit">"Ben"</span>, <span class="num">42</span>),
    (<span class="lit">"Liz"</span>, <span class="num">37</span>)
  )
}</pre><p>Each asynchronous getter in this package simply wraps the result of its equivalent synchronous getter (in the
<code>get</code> package) in a Future. <code>getAsyncAsOf</code> thus wraps the result of <code>getAsOf</code> in a Future and so on.
</p></div></div></li><li class="indented0 " name="molecule.api.getAsync.GetAsyncRaw" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="GetAsyncRawextendsAnyRef"></a><a id="GetAsyncRaw:GetAsyncRaw"></a> <span class="permalink"><a href="../../../molecule/api/getAsync/GetAsyncRaw.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="GetAsyncRaw.html" title="Asynchronous data getter methods on molecules returning raw untyped Datomic data."><span class="name">GetAsyncRaw</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">Asynchronous data getter methods on molecules returning raw untyped Datomic data.</p><div class="fullcomment"><div class="comment cmt"><p>Asynchronous data getter methods on molecules returning raw untyped Datomic data.
<br><br>
Returns a <code>Future</code> with raw untyped <code>java.util.Collection[java.util.List[Object]]</code> directly from Datomic and is
therefore the fastest (but untyped) way of retrieving data. Can be useful where typed data is
not needed.</p><pre><span class="kw">val</span> rawDataFuture: Future[java.util.Colleciton[java.util.<span class="std">List</span>[<span class="std">Object</span>]] = Person.name.age.getAsyncRaw
<span class="kw">for</span> {
  rawData <span class="kw">&lt;-</span> rawDataFuture
} <span class="kw">yield</span> {
  rawData.toString === <span class="lit">"""[["Ben" 42]["Liz" 37]]"""
}</span></pre><p>Each asynchronous getter in this package simply wraps the result of its equivalent synchronous getter (in the
<code>get</code> package) in a Future. <code>getAsyncRawAsOf</code> thus wraps the result of <code>getRawAsOf</code> in a Future and so on.
</p></div></div></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
