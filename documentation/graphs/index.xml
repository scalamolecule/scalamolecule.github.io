<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphs on Molecule</title>
    <link>http://scalamolecule.org/documentation/graphs/</link>
    <description>Recent content in Graphs on Molecule</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Jan 2015 22:06:44 +0100</lastBuildDate>
    
	<atom:link href="http://scalamolecule.org/documentation/graphs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Cardinality one</title>
      <link>http://scalamolecule.org/documentation/relationships/card-one/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/relationships/card-one/</guid>
      <description>One-to-one relationships One-to-One A Person could have a cardinality-one reference to City having a cardinality-one reference to a Country:
Person.name.City.name.Country.name  Strictly speaking we have an entity with an asserted :person/name attribute value with a reference to another entity with an asserted :city/name attribute value etc. But in practice we simply talk about &amp;ldquo;namespace A has a relationship/reference to namespace B&amp;rdquo;.
A namespace is not like an SQL Table but rather organizes some attributes by a meaningful name - it&amp;rsquo;s, well, a namespace.</description>
    </item>
    
    <item>
      <title>Self</title>
      <link>http://scalamolecule.org/documentation/graphs/self/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/graphs/self/</guid>
      <description>Bidirectional references (See bidirectional tests)
Unidirectional reference limitations Normal Datomic references are unidirectional. If we add a friend reference from Ann to Ben
Person.name(&amp;quot;Ann&amp;quot;).Friends.name(&amp;quot;Ben&amp;quot;).save  Then we can naturally query to get friends of Ann
Person.name_(&amp;quot;Ann&amp;quot;).Friends.name.get === List(&amp;quot;Ben&amp;quot;)  But what if we want to find friends of Ben? This will give us nothing since our reference only went from Ann to Ben:
Person.name_(&amp;quot;Ben&amp;quot;).Friends.name.get === List()  Instead we would have to think backwards to get the back reference &amp;ldquo;who referenced Ben?</description>
    </item>
    
    <item>
      <title>AsOf</title>
      <link>http://scalamolecule.org/documentation/time/asof/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/time/asof/</guid>
      <description> As of </description>
    </item>
    
    <item>
      <title>Basics</title>
      <link>http://scalamolecule.org/documentation/attributes/basics/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/attributes/basics/</guid>
      <description>Attribute builder pattern (See attribute tests)
When we have defined a schema, Molecule generates the necessary boilerplate code so that we can build &amp;ldquo;molecular data structures&amp;rdquo; by building sequences of Attributes separated with dots (the &amp;ldquo;builder pattern&amp;rdquo;).
We could for instance build a molecule representing the data structure of Persons with name, age and gender Attributes:
Person.name.age.gender // etc  The fundamental building blocks are Namespaces like Person and Attributes like name, age and gender.</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://scalamolecule.org/documentation/getting-started/introduction/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/getting-started/introduction/</guid>
      <description>Molecule introduction Molecule let&amp;rsquo;s you model and query your domain data structures directly with the words of your domain.
Query Describing our domain with Attributes grouped in Namespaces allow us to for instance find Persons in our Datomic database by composing molecules attribute by attribute with the builder pattern:
val personMolecule = m(Person.name.age)  An implicit macro method get will at compile time translate our molecule to a Datalog query.</description>
    </item>
    
    <item>
      <title>Save</title>
      <link>http://scalamolecule.org/documentation/crud/save/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/crud/save/</guid>
      <description>Save data We basically have 3 ways of entering data with Molecule:
1. Data-molecule We can insert data by populating a molecule with data by applying a value to each attribute and then simply save it. Molecule makes sure that each attribute only accepts values of the expected type.
Community .name(&amp;quot;AAA&amp;quot;) .url(&amp;quot;myUrl&amp;quot;) .`type`(&amp;quot;twitter&amp;quot;) .orgtype(&amp;quot;personal&amp;quot;) .category(&amp;quot;my&amp;quot;, &amp;quot;favorites&amp;quot;) // many cardinality allows multiple values .Neighborhood.name(&amp;quot;myNeighborhood&amp;quot;) .District.name(&amp;quot;myDistrict&amp;quot;).region(&amp;quot;nw&amp;quot;).save  Note also how we easily insert data across several namespaces in one go!</description>
    </item>
    
    <item>
      <title>Tx data</title>
      <link>http://scalamolecule.org/documentation/transactions/tx-data/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/transactions/tx-data/</guid>
      <description> Tx data </description>
    </item>
    
    <item>
      <title>Cardinality many</title>
      <link>http://scalamolecule.org/documentation/relationships/card-many/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/relationships/card-many/</guid>
      <description>One-to-many relationships One-to-One A Person could have a cardinality-one reference to City having a cardinality-one reference to a Country:
Person.name.City.name.Country.name  Strictly speaking we have an entity with an asserted :person/name attribute value with a reference to another entity with an asserted :city/name attribute value etc. But in practice we simply talk about &amp;ldquo;namespace A has a relationship/reference to namespace B&amp;rdquo;.
A namespace is not like an SQL Table but rather organizes some attributes by a meaningful name - it&amp;rsquo;s, well, a namespace.</description>
    </item>
    
    <item>
      <title>Demo quickstart</title>
      <link>http://scalamolecule.org/documentation/getting-started/quickstart/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/getting-started/quickstart/</guid>
      <description>Setup your project with Molecule To use Molecule we need to define our database schema in a Schema definition file and then tell sbt about it. When compiling our project from the command line, all necessary boilerplate code is then automatically generated.
1. SBT build settings Add the following to your build files:
project/build.properties:
sbt.version=0.13.13  project/buildinfo.sbt:
addSbtPlugin(&amp;quot;org.scalamolecule&amp;quot; % &amp;quot;sbt-molecule&amp;quot; % &amp;quot;0.3.3&amp;quot;)  build.sbt:
lazy val yourProject = project.in(file(&amp;quot;demo&amp;quot;)) .</description>
    </item>
    
    <item>
      <title>Insert</title>
      <link>http://scalamolecule.org/documentation/crud/insert/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/crud/insert/</guid>
      <description>Insert data We basically have 3 ways of entering data with Molecule:
1. Data-molecule We can insert data by populating a molecule with data by applying a value to each attribute and then simply save it. Molecule makes sure that each attribute only accepts values of the expected type.
Community.insert .name(&amp;quot;AAA&amp;quot;) .url(&amp;quot;myUrl&amp;quot;) .`type`(&amp;quot;twitter&amp;quot;) .orgtype(&amp;quot;personal&amp;quot;) .category(&amp;quot;my&amp;quot;, &amp;quot;favorites&amp;quot;) // many cardinality allows multiple values .Neighborhood.name(&amp;quot;myNeighborhood&amp;quot;) .District.name(&amp;quot;myDistrict&amp;quot;).region(&amp;quot;nw&amp;quot;).save  Note also how we easily insert data across several namespaces in one go!</description>
    </item>
    
    <item>
      <title>Mandatory/Tacet/Optional</title>
      <link>http://scalamolecule.org/documentation/attributes/modes/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/attributes/modes/</guid>
      <description>3 attribute modes 1. Mandatory attr When we use a molecule to query the Datomic database we ask for entities having all our Attributes associated with them.
Note that this is different from selecting rows from a sql table where you can also get null values back!
If for instance we have entities representing Persons in our data set that haven&amp;rsquo;t got any age Attribute associated with them then this query will not return those entities:</description>
    </item>
    
    <item>
      <title>Other</title>
      <link>http://scalamolecule.org/documentation/graphs/other/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/graphs/other/</guid>
      <description> Other&amp;hellip; </description>
    </item>
    
    <item>
      <title>Since</title>
      <link>http://scalamolecule.org/documentation/time/since/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/time/since/</guid>
      <description> Since </description>
    </item>
    
    <item>
      <title>Tx meta data</title>
      <link>http://scalamolecule.org/documentation/transactions/tx-meta-data/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/transactions/tx-meta-data/</guid>
      <description>Transaction meta data Transaction data in Datomic is basically a list of facts/datoms being asserted or retracted. If we take the Provenance example we could add two Story entities each with two datoms (title and url) with this molecule:
Story.title.url insert List( (&amp;quot;ElastiCache in 6 minutes&amp;quot;, &amp;quot;blog.com/elasticache-in-5-minutes.html&amp;quot;), (&amp;quot;Keep Chocolate Love Atomic&amp;quot;, &amp;quot;blog.com/atomic-chocolate.html&amp;quot;) )  Molecule translate this to a transaction list of 4 datoms:
List( // operation entity id attribute value List(:db/add, #db/id[:db.</description>
    </item>
    
    <item>
      <title>Nested</title>
      <link>http://scalamolecule.org/documentation/relationships/nested/</link>
      <pubDate>Sun, 24 Jul 2016 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/relationships/nested/</guid>
      <description>Nested relationships One-to-One A Person could have a cardinality-one reference to City having a cardinality-one reference to a Country:
Person.name.City.name.Country.name  Strictly speaking we have an entity with an asserted :person/name attribute value with a reference to another entity with an asserted :city/name attribute value etc. But in practice we simply talk about &amp;ldquo;namespace A has a relationship/reference to namespace B&amp;rdquo;.
A namespace is not like an SQL Table but rather organizes some attributes by a meaningful name - it&amp;rsquo;s, well, a namespace.</description>
    </item>
    
    <item>
      <title>Edge self</title>
      <link>http://scalamolecule.org/documentation/graphs/edge-self/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/graphs/edge-self/</guid>
      <description> Edge other&amp;hellip; </description>
    </item>
    
    <item>
      <title>Get</title>
      <link>http://scalamolecule.org/documentation/crud/get/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/crud/get/</guid>
      <description> Get (read) data </description>
    </item>
    
    <item>
      <title>Map attributes</title>
      <link>http://scalamolecule.org/documentation/attributes/mapped/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/attributes/mapped/</guid>
      <description>Map Attributes (See mapped tests)
Mapped values can be saved with mapped attributes in Molecule. It&amp;rsquo;s a special Molecule construct that makes it easy to save for instance multi-lingual data without having to create language-variations of each attribute. But they can also be used for any other key-value indexed data.
Say you want to save famous Persons names in multiple languages. Then you could use a mapString:
// In definition file val name = mapString // Insert mapped data Person.</description>
    </item>
    
    <item>
      <title>Project setup</title>
      <link>http://scalamolecule.org/documentation/getting-started/project-setup/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/getting-started/project-setup/</guid>
      <description>Setup your project with Molecule To use Molecule we need to define our database schema in a Schema definition file and then tell sbt about it. When compiling our project from the command line, all necessary boilerplate code is then automatically generated.
1. SBT build settings Add the following to your build files:
project/build.properties:
sbt.version=0.13.13  project/buildinfo.sbt:
addSbtPlugin(&amp;quot;org.scalamolecule&amp;quot; % &amp;quot;sbt-molecule&amp;quot; % &amp;quot;0.3.3&amp;quot;)  build.sbt:
lazy val yourProject = project.in(file(&amp;quot;demo&amp;quot;)) .</description>
    </item>
    
    <item>
      <title>Transaction</title>
      <link>http://scalamolecule.org/documentation/schema/transaction/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/schema/transaction/</guid>
      <description>Schema transaction To create our Datomic database we need to transact some schema transaction data.
Schema transaction data Molecule transforms our Schema definition file to basically a java.util.List containing a java.util.Map of schema transaction data for each attribute defined. Our name and url attributes for instance requires the following map of information to be transacted in Datomic:
object SeattleSchema extends Transaction { lazy val partitions = Util.list() lazy val namespaces = Util.</description>
    </item>
    
    <item>
      <title>Composites</title>
      <link>http://scalamolecule.org/documentation/relationships/composites/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/relationships/composites/</guid>
      <description>Composites 
Entities can have attributes from any namespace
Composite inserts A core feature of Datomic is that any attribute value can be associated with an entity. This allow us to &amp;ldquo;compose&amp;rdquo; entities with attribute values from un-related namespaces.
Say for instance if we want to tag various part of our domain. It would be tedious and counter-intuitive to have references between every single namespace to a tag namespace. Tags are not an intrinsic value of most entities and are therefore better modelled in isolation.</description>
    </item>
    
    <item>
      <title>Edge other</title>
      <link>http://scalamolecule.org/documentation/graphs/edge-other/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/graphs/edge-other/</guid>
      <description> Edge others&amp;hellip; </description>
    </item>
    
    <item>
      <title>Entities</title>
      <link>http://scalamolecule.org/documentation/entities/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/entities/</guid>
      <description>Entities Entities&amp;hellip;</description>
    </item>
    
    <item>
      <title>Expressions</title>
      <link>http://scalamolecule.org/documentation/attributes/expressions/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/attributes/expressions/</guid>
      <description>Expressions (See expression tests)
Equality We can apply values to Attributes in order to filter the data structures we are looking for. We could for instance look for names of female persons:
Person.age.apply(42)  or simply
Person.age(42)  OR-logic We can apply OR-logic to find a selection of alternatives
Person.age(40 or 41 or 42) // .. same as Person.age(40, 41, 42) // .. same as Person.age(List(40, 41, 42))  Negation We can exclude a certain attribute value</description>
    </item>
    
    <item>
      <title>Update</title>
      <link>http://scalamolecule.org/documentation/crud/update/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/crud/update/</guid>
      <description>Update data Update An &amp;ldquo;update&amp;rdquo; is a two-step process in Datomic:
 Retract old fact Assert new fact  Datomic doesn&amp;rsquo;t overwrite data. &amp;ldquo;Retract&amp;rdquo; is a statement that says &amp;ldquo;this data is no longer current&amp;rdquo; which means that it won&amp;rsquo;t turn up when you query for it as of now. If you query for it as of before you will see it!
Being able to see how data develops over time is a brillant core feature of Datomic.</description>
    </item>
    
    <item>
      <title>Aggregates</title>
      <link>http://scalamolecule.org/documentation/attributes/aggregates/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/attributes/aggregates/</guid>
      <description>Aggregates (See aggregates tests)
Datomic offers some built-in aggregate functions to aggregate attribute values.
Aggregates returning a single value min/max In Molecule you simply apply the aggregate function name as a keyword to your attribute.
Person.age(min) // lowest age Person.age(max) // highest age  Supports all types.
count Not to be confused with sum in that count counts the entities having attribute with some value
Person.age(count) // count of all persons with an age (not the sum of ages)  countDistinct Not to be confused with sum in that count counts the entities having attribute with some value</description>
    </item>
    
    <item>
      <title>Retract</title>
      <link>http://scalamolecule.org/documentation/crud/retract/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/crud/retract/</guid>
      <description>Retract data Update An &amp;ldquo;update&amp;rdquo; is a two-step process in Datomic:
 Retract old fact Assert new fact  Datomic doesn&amp;rsquo;t overwrite data. &amp;ldquo;Retract&amp;rdquo; is a statement that says &amp;ldquo;this data is no longer current&amp;rdquo; which means that it won&amp;rsquo;t turn up when you query for it as of now. If you query for it as of before you will see it!
Being able to see how data develops over time is a brillant core feature of Datomic.</description>
    </item>
    
    <item>
      <title>Parameterized</title>
      <link>http://scalamolecule.org/documentation/attributes/parameterized/</link>
      <pubDate>Fri, 02 Jan 2015 22:06:44 +0100</pubDate>
      
      <guid>http://scalamolecule.org/documentation/attributes/parameterized/</guid>
      <description>Parameterized Input-molecules (See parameterize tests)
Molecules can be parameterized by applying the input placeholder ? as a value to an attribute. The molecule then expects input for that attribute at runtime.
By assigning parameterized &amp;ldquo;Input-molecules&amp;rdquo; to variables we can re-use those variables to query for similar data structures where only some data part varies:
// 1 input parameter val person = m(Person.name(?)) val john = person(&amp;quot;John&amp;quot;).get.head val lisa = person(&amp;quot;Lisa&amp;quot;).</description>
    </item>
    
  </channel>
</rss>